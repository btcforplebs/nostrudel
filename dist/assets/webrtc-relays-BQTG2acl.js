import{d_ as u,d$ as p,t as l,e0 as v,aw as w,e1 as O,e2 as x,e3 as E,e4 as M,e5 as I,dW as P,e6 as D,e7 as W,dU as T,e8 as C}from"./index-C6wlVu-O.js";const h=25050,c=25051;class k extends u{log;signer;pool;peer;relays=[];iceServers=[];connection;channel;subscription;async isCaller(){var e;return this.offerEvent?await this.signer.getPublicKey()===((e=this.offerEvent)==null?void 0:e.pubkey):null}get offer(){var e;return(e=this.connection)==null?void 0:e.localDescription}offerEvent;get answer(){var e;return(e=this.connection)==null?void 0:e.remoteDescription}answerEvent;candidateQueue=[];constructor(e,t,s,n){super(),this.log=p.extend("NostrWebRTCPeer"),this.signer=e,this.pool=t,n&&(this.iceServers=n),s&&(this.relays=s),this.connection=new RTCPeerConnection({iceServers:this.iceServers}),this.log("Created local connection"),this.connection.onicecandidate=async({candidate:i})=>{i?this.candidateQueue.push(i.toJSON()):this.flushCandidateQueue()},this.connection.onicegatheringstatechange=this.flushCandidateQueue.bind(this),this.connection.onconnectionstatechange=i=>{var a;switch((a=this.connection)==null?void 0:a.connectionState){case"connected":this.emit("connected");break;case"disconnected":this.emit("disconnected");break}},this.connection.ondatachannel=({channel:i})=>{this.log("Got data channel",i.id,i.label),i.label==="nostr"&&(this.channel=i,this.channel.onclose=this.onChannelStateChange.bind(this),this.channel.onopen=this.onChannelStateChange.bind(this),this.channel.onmessage=this.handleChannelMessage.bind(this))}}async flushCandidateQueue(){var e;if(((e=this.connection)==null?void 0:e.iceGatheringState)==="complete"&&this.offerEvent&&this.answerEvent&&this.peer&&this.candidateQueue.length>0){const t=await this.signer.nip44.encrypt(this.peer,JSON.stringify(this.candidateQueue)),s=await this.signer.signEvent({kind:c,content:t,tags:[["e",this.offerEvent.id]],created_at:l().unix()});this.log(`Publishing ${this.candidateQueue.length} ICE candidates`),await this.pool.publish(this.relays,s),this.candidateQueue=[]}}async makeCall(e){if(this.peer)throw new Error("Already calling peer");const t=this.connection;this.channel=t.createDataChannel("nostr",{ordered:!0}),this.channel.onopen=this.onChannelStateChange.bind(this),this.channel.onclose=this.onChannelStateChange.bind(this),this.channel.onmessage=this.handleChannelMessage.bind(this),this.log(`Making call to ${e} `);const s=await t.createOffer(),n=await this.signer.nip44.encrypt(e,JSON.stringify(s)),i=await this.signer.signEvent({kind:h,content:n,tags:[["p",e],...this.relays.map(a=>["relay",a])],created_at:l().unix()});this.log("Created offer"),this.subscription=this.pool.subscribeMany(this.relays,[{kinds:[h,c],"#e":[i.id],authors:[e]}],{onevent:async a=>{if(this.offerEvent&&a.tags.some(r=>{var o;return r[0]==="e"&&r[1]===((o=this.offerEvent)==null?void 0:o.id)}))switch(console.log(a),a.kind){case h:await this.handleAnswer(a),await this.flushCandidateQueue();break;case c:await this.handleICEEvent(a);break}},onclose:()=>{this.log("Signaling subscription closed")}}),this.peer=e,this.log("Publishing event",i.id),await this.pool.publish(this.relays,i),await t.setLocalDescription(s),this.offerEvent=i}async handleAnswer(e){const t=this.connection;if(!t.localDescription)throw new Error("Got answer without offering");const s=await this.signer.nip44.decrypt(e.pubkey,e.content),n=JSON.parse(s);if(n.type!=="answer")throw new Error("Unexpected rtc description type");this.log("Got answer"),await t.setRemoteDescription(n),this.answerEvent=e}async answerCall(e){const t=this.connection;this.log(`Answering call ${e.id} from ${e.pubkey}`);const s=await this.signer.nip44.decrypt(e.pubkey,e.content),n=JSON.parse(s);if(n.type!=="offer")throw new Error("Unexpected rtc description type");this.relays=e.tags.filter(o=>o[0]==="relay"&&o[1]).map(o=>o[1]),this.log("Switching to callers signaling relays",this.relays),await t.setRemoteDescription(n);const i=await t.createAnswer(),a=await this.signer.nip44.encrypt(e.pubkey,JSON.stringify(i)),r=await this.signer.signEvent({kind:h,content:a,tags:[["p",e.pubkey],["e",e.id]],created_at:l().unix()});this.log("Created answer"),this.peer=e.pubkey,this.offerEvent=e,this.subscription=this.pool.subscribeMany(this.relays,[{kinds:[c],"#e":[e.id],authors:[e.pubkey]}],{onevent:async o=>{if(this.offerEvent&&o.tags.some(b=>{var y;return b[0]==="e"&&b[1]===((y=this.offerEvent)==null?void 0:y.id)}))switch(o.kind){case c:await this.handleICEEvent(o);break}},onclose:()=>{this.log("Signaling subscription closed")}}),this.log("Publishing event",r.id),await this.pool.publish(this.relays,r),await t.setLocalDescription(i),this.answerEvent=r,await this.flushCandidateQueue()}async handleICEEvent(e){if(!this.connection)throw new Error("Got ICE event without connection");const t=this.connection,s=await this.signer.nip44.decrypt(e.pubkey,e.content),n=JSON.parse(s);this.log(`Got ${n.length} candidates`);for(let i of n)await t.addIceCandidate(i)}onChannelStateChange(){var t;const e=(t=this.channel)==null?void 0:t.readyState;console.log("Send channel state is: "+e)}handleChannelMessage(e){typeof e.data=="string"&&this.emit("message",e.data)}send(e){var t;(t=this.channel)==null||t.send(e)}hangup(){this.log("Closing data channel"),this.channel&&this.channel.close(),this.log("Closing connection"),this.connection&&this.connection.close()}}class g extends u{log=p.extend("NostrWebRtcBroker");signer;pool;defaultRelays;iceServers=[];peers=new Map;signers=new Map;relays=new Map;constructor(e,t,s){super(),this.signer=e,this.pool=t,this.defaultRelays=s}getConnection(e){return this.peers.get(e)}async requestConnection(e){const{pubkey:t,relays:s,key:n}=g.parseNostrWebRtcURI(e),i=this.peers.get(t);if(i)return i;this.log(`Creating new connection for ${t}`);let a=this.signer;n&&(a=new v(n),this.signers.set(t,a)),s.length>0?this.relays.set(t,s):this.relays.set(t,this.defaultRelays);const r=new k(a,this.pool,s.length>0?s:this.defaultRelays,this.iceServers);return this.peers.set(t,r),await r.makeCall(t),r}setPeerSigner(e,t){this.signers.set(e,t)}async answerCall(e){if(this.peers.has(e.pubkey))throw new Error("Already have a peer connection for this pubkey");let t=this.signers.get(e.pubkey);t||(t=this.signer,this.signers.set(e.pubkey,t));const s=new k(t,this.pool,this.defaultRelays,this.iceServers);return this.peers.set(e.pubkey,s),await s.answerCall(e),s}closeConnection(e){const t=this.peers.get(e);t&&(this.log(`Hanging up connection to ${e}`),t.hangup(),this.peers.delete(e))}listening=!1;subscription;async listenForCalls(){if(this.listening)throw new Error("Already listening");this.log("Listening for calls"),this.listening=!0,this.subscription=this.pool.subscribeMany(this.defaultRelays,[{kinds:[h],"#p":[await this.signer.getPublicKey()],since:l().unix()}],{onevent:e=>{this.emit("call",e)},onclose:()=>{this.listening=!1}})}stopListening(){this.listening&&(this.log("Stop listening for calls"),this.subscription&&this.subscription.close(),this.subscription=void 0,this.listening=!1)}static parseNostrWebRtcURI(e){const t=typeof e=="string"?new URL(e):e;if(t.protocol!=="webrtc+nostr:")throw new Error("Incorrect protocol");const s=w.decode(t.pathname),n=t.searchParams.get("key"),i=t.searchParams.getAll("relay");if(s.type!=="npub")throw new Error("Incorrect npub");const a=s.data;if(n&&!O(n))throw new Error("Key must be in hex format");const r=n?x(n):null;return{pubkey:a,key:r,relays:i}}static createNostrWebRtcURI(e,t,s){const n=new URL(`webrtc+nostr:${w.npubEncode(e)}`);for(const i of t)n.searchParams.append("relay",i);return s===!0?n.searchParams.append("key",E(M())):s instanceof Uint8Array&&n.searchParams.append("key",E(s)),n.toString()}}class f extends EventTarget{binaryType="blob";bufferedAmount=0;extensions="";protocol="webrtc";peer;url;onclose=null;onerror=null;onmessage=null;onopen=null;constructor(e){var t;super(),this.peer=e,this.url="webrtc+nostr:"+((t=e.answerEvent)==null?void 0:t.pubkey),this.peer.on("message",this.handleMessage,this),this.peer.on("connected",this.handleConnect,this),this.peer.on("disconnected",this.handleDisconnect,this),this.readyState===f.OPEN&&setTimeout(()=>this.handleConnect(),100)}get readyState(){var t;switch((t=this.peer.connection)==null?void 0:t.connectionState){case"closed":case"disconnected":return this.CLOSED;case"failed":return this.CLOSED;case"connected":return this.OPEN;case"new":case"connecting":default:return this.CONNECTING}}handleMessage(e){var s;const t=new MessageEvent("message",{data:e});(s=this.onmessage)==null||s.call(this,t),this.dispatchEvent(t)}handleConnect(){var t;const e=new Event("open");(t=this.onopen)==null||t.call(this,e),this.dispatchEvent(e)}handleDisconnect(){var t;const e=new CloseEvent("close",{reason:"none"});(t=this.onclose)==null||t.call(this,e),this.dispatchEvent(e),this.peer.off("message",this.handleMessage,this),this.peer.off("connected",this.handleConnect,this),this.peer.off("disconnected",this.handleDisconnect,this)}send(e){if(typeof e=="string")this.peer.send(e);else throw new Error("Unsupported data type")}close(e,t){this.peer.hangup(),this.peer.off("message",this.handleMessage,this),this.peer.off("connected",this.handleConnect,this),this.peer.off("disconnected",this.handleDisconnect,this)}CONNECTING=WebSocket.CONNECTING;OPEN=WebSocket.OPEN;CLOSING=WebSocket.CLOSING;CLOSED=WebSocket.CLOSED;static CONNECTING=WebSocket.CONNECTING;static OPEN=WebSocket.OPEN;static CLOSING=WebSocket.CLOSING;static CLOSED=WebSocket.CLOSED}class S extends I{stats={events:{published:0,received:0}};constructor(e,t){var s;super("wss://example.com",t),this.url="webrtc+nostr:"+((s=e.answerEvent)==null?void 0:s.pubkey),this.connectionTimeout=3e4,this._WebSocket=function(){return new f(e)}}publish(e){return this.stats.events.published++,super.publish(e)}}class m extends u{log=p.extend("WebRtcRelayServer");peer;upstream;subscriptions=new Map;stats={events:{sent:0,received:0}};constructor(e,t){super(),this.peer=e,this.upstream=t,this.peer.on("message",this.handleMessage,this),this.peer.on("disconnected",this.handleDisconnect,this)}send(e){this.peer.send(JSON.stringify(e))}async handleMessage(e){let t;try{if(t=JSON.parse(e),!Array.isArray(t))throw new Error("Message is not an array");switch(t[0]){case"REQ":await this.handleSubscriptionMessage(t);break;case"EVENT":typeof t[1]!="string"&&await this.handleEventMessage(t);break;case"CLOSE":await this.handleCloseMessage(t);break}}catch(s){this.log("Failed to handle message",e,s)}return t}handleSubscriptionMessage(e){const[t,s,...n]=e;let i=this.subscriptions.get(s);i?(i.filters=n,i.fire()):i=this.upstream.subscribe(n,{onevent:a=>{this.stats.events.sent++,this.send(["EVENT",s,a])},onclose:a=>this.send(["CLOSED",s,a]),oneose:()=>this.send(["EOSE",s])})}handleCloseMessage(e){const[t,s]=e;let n=this.subscriptions.get(s);n&&(n.close(),this.subscriptions.delete(s))}async handleEventMessage(e){const[t,s]=e;try{const n=await this.upstream.publish(s);this.stats.events.received++,this.peer.send(JSON.stringify(["OK",s.id,!0,n]))}catch(n){n instanceof Error&&this.peer.send(JSON.stringify(["OK",s.id,!1,n.message]))}}handleDisconnect(){for(const[e,t]of this.subscriptions)t.close();this.subscriptions.clear()}destroy(){this.peer.off("message",this.handleMessage,this),this.peer.off("disconnected",this.handleDisconnect,this)}}class L{log=p.extend("NostrWebRtcBroker");broker;pubkey;upstream;approved=[];calls=[];get answered(){const e=[];for(const t of this.calls){const s=this.broker.peers.get(t.pubkey);s&&s.peer&&s.connection.connectionState!=="new"&&e.push({call:t,peer:s,pubkey:s.peer})}return e}get pendingOutgoing(){var t;const e=[];for(const s of this.calls){const n=(t=s.tags.find(a=>a[0]==="p"&&a[1]))==null?void 0:t[1];if(!n)continue;const i=this.broker.peers.get(n);i&&i.connection.connectionState==="new"&&e.push({call:s,peer:i})}return e}get pendingIncoming(){return this.calls.filter(e=>e.pubkey!==this.pubkey&&this.broker.peers.has(e.pubkey)===!1)}clients=new Map;servers=new Map;get relays(){return Array.from(this.clients.values())}constructor(e,t){this.upstream=t,this.broker=e,this.getPubkey()}async getPubkey(){const e=await this.broker.signer.getPublicKey();this.pubkey=e}async handleCall(e){if(this.calls.includes(e)||(this.log(`Received call from ${e.pubkey}`),this.calls.push(e)),this.approved.includes(e.pubkey)){this.log(`Answering call from ${e.pubkey}`);const t=await this.broker.answerCall(e);if(!t.peer)return;if(this.upstream){const n=new m(t,this.upstream);this.servers.set(t.peer,n)}const s=new S(t,{websocketImplementation:WebSocket,verifyEvent:C});this.clients.set(t.peer,s)}}async acceptCall(e){this.log(`Approving calls from ${e.pubkey}`),this.approved.push(e.pubkey),await this.handleCall(e)}async connect(e){this.log(`Connecting to ${e}`);const t=await this.broker.requestConnection(e);if(!t.peer)return;if(t.offerEvent&&this.calls.push(t.offerEvent),this.upstream){const n=new m(t,this.upstream);this.servers.set(t.peer,n)}const s=new S(t,{websocketImplementation:WebSocket,verifyEvent:C});this.clients.set(t.peer,s),await s.connect()}start(){this.broker.listenForCalls(),this.broker.on("call",this.handleCall,this)}stop(){this.broker.stopListening(),this.broker.off("call",this.handleCall,this)}}const A=new v(P.webRtcLocalIdentity.value),N=new g(A,new D,["wss://nos.lol","wss://nostrue.com"]);N.iceServers=W;const R=new L(N,T);R.start();window.webRtcRelaysService=R;export{g as N,R as w};
//# sourceMappingURL=webrtc-relays-BQTG2acl.js.map
