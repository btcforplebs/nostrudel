import { LRLanguage, LanguageSupport } from '@codemirror/language';
import { Diagnostic } from '@codemirror/lint';
import { StateField } from '@codemirror/state';
import { EditorView } from '@codemirror/view';
import { SyntaxNode } from '@lezer/common';

/** A language provider that provides JSON5 parsing. */
declare const json5Language: LRLanguage;
/** JSON5 language support, with the json5ParseCache and jsonCursorPath extensions enabled. */
declare function json5(): LanguageSupport;
/** A function to provide additional linting functionality on the parsed version of the object */
type StructureLinter<T = unknown> = (view: EditorView, parsed: T) => Diagnostic[] | Promise<Diagnostic[]>;
interface Json5SyntaxError extends SyntaxError {
    lineNumber: number;
    columnNumber: number;
}
/**
 * JSON5 linting support
 *
 * @param structureLinter Perform additional linting on the parsed object
 **/
declare function json5ParseLinter<T = unknown>(structureLinter?: StructureLinter<T>): (view: EditorView) => Diagnostic[] | Promise<Diagnostic[]>;
/** The parsed JSON5 value from the editor buffer */
interface Json5ParseCache {
    err: Json5SyntaxError | null;
    obj: unknown | undefined;
}
/** A cache to allow linters, autocomplete, etc. to not have to parse the
 * same text over and over again. */
declare const json5ParseCache: StateField<Json5ParseCache | null>;
interface JsonCursorPath {
    path: (string | number)[] | null;
    node: SyntaxNode | null;
}
/** jsonCursorPath calculates the path inside the JSON5 object that the cursor is over, and exposes
* that as a state field. */
declare const jsonCursorPath: StateField<JsonCursorPath>;

export { Json5ParseCache, JsonCursorPath, StructureLinter, json5, json5Language, json5ParseCache, json5ParseLinter, jsonCursorPath };
