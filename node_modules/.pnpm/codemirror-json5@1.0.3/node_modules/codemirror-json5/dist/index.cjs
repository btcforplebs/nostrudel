'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var language = require('@codemirror/language');
var state = require('@codemirror/state');
var highlight = require('@lezer/highlight');
var JSON5 = require('json5');
var lezerJson5 = require('lezer-json5');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var JSON5__default = /*#__PURE__*/_interopDefaultLegacy(JSON5);

function stripQuotes(s) {
    let first = s[0];
    let last = s[s.length - 1];
    if ((first === `'` && last === `'`) || (first === `"` && last === `"`)) {
        s = s.slice(1, -1);
    }
    return s;
}
function propertyKey(state, node) {
    if (node.name !== 'Property') {
        return null;
    }
    let key = node.getChild('PropertyName');
    if (!key) {
        return null;
    }
    return stripQuotes(state.sliceDoc(key.from, key.to));
}
function getParentProperty(node) {
    var _a;
    let cursor = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.cursor();
    if (!cursor) {
        return null;
    }
    while (cursor.node.name !== 'Property' && cursor.node.name !== 'Array') {
        if (!cursor.parent()) {
            return null;
        }
    }
    return cursor.node;
}
function getPathAtNode(state, node) {
    let keys = [];
    while (true) {
        let parent = getParentProperty(node);
        if (!parent) {
            break;
        }
        if (parent.name === 'Array') {
            let thisPos = node.from;
            let findNode = parent.firstChild;
            let index = 0;
            while (findNode && findNode.to < thisPos) {
                findNode = validNodeLookRight(findNode.nextSibling);
                index += 1;
            }
            keys.unshift(index);
        }
        else {
            let key = propertyKey(state, parent);
            if (key) {
                keys.unshift(key);
            }
        }
        node = parent;
    }
    return keys;
}
/** If the passed node is a comment, go right until a non-comment node is found */
function validNodeLookRight(node) {
    while (node && /Comment/.test(node.name)) {
        node = node.nextSibling;
    }
    return node;
}
function nodeAtCursor(state, cursorPos) {
    let tree = language.syntaxTree(state);
    let node = tree.resolveInner(cursorPos, -1);
    // If we're in whitespace between nodes, `resolveInner` will match on the parent node of the children
    // the cursor is between, so find the actual closest node.
    while (node) {
        let child = node.childBefore(cursorPos);
        if (!child) {
            break;
        }
        node = child;
    }
    return node;
}

/** A language provider that provides JSON5 parsing. */
const json5Language = language.LRLanguage.define({
    parser: lezerJson5.parser.configure({
        props: [
            language.indentNodeProp.add({
                Object: language.continuedIndent({ except: /^\s*\}/ }),
                Array: language.continuedIndent({ except: /^\s*\]/ }),
            }),
            language.foldNodeProp.add({
                'Object Array': language.foldInside,
            }),
            highlight.styleTags({
                String: highlight.tags.string,
                'PropertyName!': highlight.tags.propertyName,
                Number: highlight.tags.number,
                'True False': highlight.tags.bool,
                Null: highlight.tags.null,
                LineComment: highlight.tags.lineComment,
                BlockComment: highlight.tags.blockComment,
                ', PropertyColon': highlight.tags.separator,
                '[ ]': highlight.tags.squareBracket,
                '{ }': highlight.tags.brace,
            }),
        ],
    }),
    languageData: {
        closeBrackets: { brackets: ['[', '{', '"', `'`] },
        indentOnInput: /^\s*[}\]]$/,
        commentTokens: {
            line: '//',
            block: {
                open: '/*',
                clone: '*/',
            },
        },
    },
});
/** JSON5 language support, with the json5ParseCache and jsonCursorPath extensions enabled. */
function json5() {
    return new language.LanguageSupport(json5Language, [json5ParseCache.extension, jsonCursorPath.extension]);
}
function handleParseError(doc, e) {
    let pos = 0;
    if ('lineNumber' in e && 'columnNumber' in e) {
        pos = Math.min(doc.line(e.lineNumber).from + e.columnNumber - 1, doc.length);
    }
    return [
        {
            from: pos,
            to: pos,
            message: e.message,
            severity: 'error',
        },
    ];
}
/**
 * JSON5 linting support
 *
 * @param structureLinter Perform additional linting on the parsed object
 **/
function json5ParseLinter(structureLinter) {
    return (view) => {
        var _a, _b;
        let doc = view.state.doc;
        let cached = view.state.field(json5ParseCache, false);
        if (cached) {
            if (cached.err) {
                return handleParseError(doc, cached.err);
            }
            else if (cached.obj !== undefined) {
                return (_a = structureLinter === null || structureLinter === void 0 ? void 0 : structureLinter(view, cached.obj)) !== null && _a !== void 0 ? _a : [];
            }
        }
        try {
            let parsed = JSON5__default["default"].parse(doc.toString());
            return (_b = structureLinter === null || structureLinter === void 0 ? void 0 : structureLinter(view, parsed)) !== null && _b !== void 0 ? _b : [];
        }
        catch (e) {
            return handleParseError(doc, e);
        }
    };
}
/** A cache to allow linters, autocomplete, etc. to not have to parse the
 * same text over and over again. */
const json5ParseCache = state.StateField.define({
    create() {
        return null;
    },
    update(oldValue, tx) {
        if (!tx.docChanged) {
            return oldValue;
        }
        try {
            let parsed = JSON5__default["default"].parse(tx.newDoc.toString());
            return { err: null, obj: parsed };
        }
        catch (e) {
            return {
                err: e,
                obj: oldValue === null || oldValue === void 0 ? void 0 : oldValue.obj,
            };
        }
    },
});
/** jsonCursorPath calculates the path inside the JSON5 object that the cursor is over, and exposes
* that as a state field. */
const jsonCursorPath = state.StateField.define({
    create() {
        return { path: null, node: null };
    },
    update(oldValue, tx) {
        let cursorPos = tx.state.selection.main.to;
        let currentNode = nodeAtCursor(tx.state, cursorPos);
        let currentPath = currentNode ? getPathAtNode(tx.state, currentNode) : null;
        return {
            path: currentPath !== null && currentPath !== void 0 ? currentPath : null,
            node: currentNode,
        };
    },
});

exports.json5 = json5;
exports.json5Language = json5Language;
exports.json5ParseCache = json5ParseCache;
exports.json5ParseLinter = json5ParseLinter;
exports.jsonCursorPath = jsonCursorPath;
