"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONHover = exports.jsonSchemaHover = void 0;
const json_schema_library_1 = require("json-schema-library");
const jsonPointers_js_1 = require("./utils/jsonPointers.js");
const formatting_js_1 = require("./utils/formatting.js");
const debug_js_1 = require("./utils/debug.js");
const dom_js_1 = require("./utils/dom.js");
const state_js_1 = require("./state.js");
/**
 * provides a JSON schema enabled tooltip extension for codemirror
 * @group Codemirror Extensions
 */
function jsonSchemaHover(options) {
    const hover = new JSONHover(options);
    return async function jsonDoHover(view, pos, side) {
        return hover.doHover(view, pos, side);
    };
}
exports.jsonSchemaHover = jsonSchemaHover;
function formatComplexType(schema, type, draft) {
    return `${type}: ${(0, formatting_js_1.joinWithOr)(schema[type].map((s) => {
        var _a;
        return (_a = s.type) !== null && _a !== void 0 ? _a : draft.resolveRef(s).type;
    }))}`;
}
class JSONHover {
    constructor(opts) {
        this.opts = opts;
        this.schema = null;
        this.opts = Object.assign({ parser: JSON.parse }, this.opts);
    }
    getDataForCursor(view, pos, side) {
        const schema = (0, state_js_1.getJSONSchema)(view.state);
        if (!schema) {
            // todo: should we even do anything without schema
            // without taking over the existing mode responsibilties?
            return null;
        }
        this.schema = new json_schema_library_1.Draft04(schema);
        const pointer = (0, jsonPointers_js_1.jsonPointerForPosition)(view.state, pos, side);
        let data = undefined;
        // TODO: use the AST tree to return the right hand, data so that we don't have to parse the doc
        try {
            data = this.opts.parser(view.state.doc.toString());
        }
        catch (_a) { }
        if (!pointer) {
            return null;
        }
        // if the data is valid, we can infer a type for complex types
        let subSchema = this.schema.getSchema({
            pointer,
            data,
            withSchemaWarning: true,
        });
        if ((0, json_schema_library_1.isJsonError)(subSchema)) {
            if (subSchema === null || subSchema === void 0 ? void 0 : subSchema.data.schema["$ref"]) {
                subSchema = this.schema.resolveRef(subSchema);
            }
            else {
                subSchema = subSchema === null || subSchema === void 0 ? void 0 : subSchema.data.schema;
            }
        }
        return { schema: subSchema, pointer };
    }
    formatMessage(texts) {
        const { message, typeInfo } = texts;
        if (message) {
            return (0, dom_js_1.el)("div", { class: "cm6-json-schema-hover" }, [
                (0, dom_js_1.el)("div", {
                    class: "cm6-json-schema-hover--description",
                    text: message,
                }),
                (0, dom_js_1.el)("div", { class: "cm6-json-schema-hover--code-wrapper" }, [
                    typeInfo.includes("<code>")
                        ? (0, dom_js_1.el)("div", {
                            class: "cm6-json-schema-hover--code",
                            inner: typeInfo,
                        })
                        : (0, dom_js_1.el)("code", {
                            class: "cm6-json-schema-hover--code",
                            text: typeInfo,
                        }),
                ]),
            ]);
        }
        return (0, dom_js_1.el)("div", { class: "cm6-json-schema-hover" }, [
            (0, dom_js_1.el)("div", { class: "cm6-json-schema-hover--code-wrapper" }, [
                (0, dom_js_1.el)("code", { class: "cm6-json-schema-hover--code", text: typeInfo }),
            ]),
        ]);
    }
    getHoverTexts(data, draft) {
        let typeInfo = null;
        let message = null;
        const { schema } = data;
        if (schema.oneOf) {
            typeInfo = formatComplexType(schema, "oneOf", draft);
        }
        if (schema.anyOf) {
            typeInfo = formatComplexType(schema, "anyOf", draft);
        }
        if (schema.allOf) {
            typeInfo = formatComplexType(schema, "allOf", draft);
        }
        if (schema.type) {
            typeInfo = Array.isArray(schema.type)
                ? (0, formatting_js_1.joinWithOr)(schema.type)
                : schema.type;
        }
        if (schema.enum) {
            typeInfo = `<code>enum</code>: ${(0, formatting_js_1.joinWithOr)(schema.enum)}`;
        }
        if (schema.format) {
            typeInfo += ` <code>format</code>: ${schema.format}`;
        }
        if (schema.pattern) {
            typeInfo += ` <code>pattern</code>: ${schema.pattern}`;
        }
        if (schema.description) {
            message = schema.description;
        }
        return { message, typeInfo };
    }
    // return hover state for the current json schema property
    async doHover(view, pos, side) {
        var _a, _b, _c, _d;
        const start = pos, end = pos;
        try {
            const cursorData = this.getDataForCursor(view, pos, side);
            // if we don't have a (sub)schema, we can't show anything
            if (!(cursorData === null || cursorData === void 0 ? void 0 : cursorData.schema))
                return null;
            const getHoverTexts = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.getHoverTexts) !== null && _b !== void 0 ? _b : this.getHoverTexts;
            const hoverTexts = getHoverTexts(cursorData, this.schema);
            // allow users to override the hover
            const formatter = (_d = (_c = this.opts) === null || _c === void 0 ? void 0 : _c.formatHover) !== null && _d !== void 0 ? _d : this.formatMessage;
            const formattedDom = formatter(hoverTexts);
            return {
                pos: start,
                end,
                arrow: true,
                // to mimic similar modes for other editors
                // otherwise, it gets into a z-index battle with completion/etc
                above: true,
                create: (view) => {
                    return {
                        dom: formattedDom,
                    };
                },
            };
        }
        catch (err) {
            debug_js_1.debug.log(err);
            return null;
        }
    }
}
exports.JSONHover = JSONHover;
