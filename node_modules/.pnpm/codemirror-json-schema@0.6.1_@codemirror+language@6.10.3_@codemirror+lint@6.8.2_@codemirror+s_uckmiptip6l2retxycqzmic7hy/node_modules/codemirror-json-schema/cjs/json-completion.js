"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.json5Completion = exports.jsonCompletion = exports.JSONCompletion = void 0;
const autocomplete_1 = require("@codemirror/autocomplete");
const language_1 = require("@codemirror/language");
const debug_js_1 = require("./utils/debug.js");
const node_js_1 = require("./utils/node.js");
const state_js_1 = require("./state.js");
const json_schema_library_1 = require("json-schema-library");
const jsonPointers_js_1 = require("./utils/jsonPointers.js");
const constants_js_1 = require("./constants.js");
function json5PropertyInsertSnippet(rawWord, value) {
    if (rawWord.startsWith('"')) {
        return `"${value}"`;
    }
    if (rawWord.startsWith("'")) {
        return `'${value}'`;
    }
    return value;
}
class CompletionCollector {
    constructor() {
        this.completions = new Map();
        this.reservedKeys = new Set();
    }
    reserve(key) {
        this.reservedKeys.add(key);
    }
    add(completion) {
        if (this.reservedKeys.has(completion.label)) {
            return;
        }
        this.completions.set(completion.label, completion);
    }
}
class JSONCompletion {
    constructor(opts) {
        this.opts = opts;
        this.schema = null;
    }
    doComplete(ctx) {
        var _a, _b;
        this.schema = (0, state_js_1.getJSONSchema)(ctx.state);
        if (!this.schema) {
            // todo: should we even do anything without schema
            // without taking over the existing mode responsibilties?
            return [];
        }
        const result = {
            from: ctx.pos,
            to: ctx.pos,
            options: [],
            filter: false, // will be handled manually
        };
        const text = ctx.state.doc.sliceString(0);
        let node = (0, node_js_1.getNodeAtPosition)(ctx.state, ctx.pos);
        // position node word prefix (without quotes) for matching
        const prefix = ctx.state.sliceDoc(node.from, ctx.pos).replace(/^("|')/, "");
        debug_js_1.debug.log("xxx", "node", node, "prefix", prefix, "ctx", ctx);
        // Only show completions if we are filling out a word or right after the starting quote, or if explicitly requested
        if (!((0, node_js_1.isPrimitiveValueNode)(node) || (0, node_js_1.isPropertyNameNode)(node)) &&
            !ctx.explicit) {
            return result;
        }
        const currentWord = (0, node_js_1.getWord)(ctx.state.doc, node);
        const rawWord = (0, node_js_1.getWord)(ctx.state.doc, node, false);
        // Calculate overwrite range
        if (node && ((0, node_js_1.isPrimitiveValueNode)(node) || (0, node_js_1.isPropertyNameNode)(node))) {
            result.from = node.from;
            result.to = node.to;
        }
        else {
            const word = ctx.matchBefore(/[A-Za-z0-9._]*/);
            const overwriteStart = ctx.pos - currentWord.length;
            debug_js_1.debug.log("xxx", "overwriteStart after", overwriteStart, "ctx.pos", ctx.pos, "word", word, "currentWord", currentWord, "=>", text[overwriteStart - 1], "..", text[overwriteStart], "..", text);
            result.from =
                node.name === constants_js_1.TOKENS.INVALID ? (_a = word === null || word === void 0 ? void 0 : word.from) !== null && _a !== void 0 ? _a : ctx.pos : overwriteStart;
            result.to = ctx.pos;
        }
        const collector = new CompletionCollector();
        let addValue = true;
        if ((0, node_js_1.isPropertyNameNode)(node)) {
            const parent = node.parent;
            if (parent) {
                // get value node from parent
                const valueNode = (0, node_js_1.getChildValueNode)(parent);
                addValue =
                    !valueNode ||
                        (valueNode.name === constants_js_1.TOKENS.INVALID &&
                            valueNode.from - valueNode.to === 0);
                debug_js_1.debug.log("xxx", "addValue", addValue, (0, node_js_1.getChildValueNode)(parent), node);
                // find object node
                node =
                    (_b = [parent, parent.parent].find((p) => {
                        if ((p === null || p === void 0 ? void 0 : p.name) === constants_js_1.TOKENS.OBJECT) {
                            return true;
                        }
                        return false;
                    })) !== null && _b !== void 0 ? _b : null;
            }
        }
        debug_js_1.debug.log("xxx", node, currentWord, ctx);
        // proposals for properties
        if (node &&
            (node.name === constants_js_1.TOKENS.OBJECT || node.name === constants_js_1.TOKENS.JSON_TEXT) &&
            (0, node_js_1.isPropertyNameNode)((0, node_js_1.getNodeAtPosition)(ctx.state, ctx.pos))) {
            // don't suggest keys when the cursor is just before the opening curly brace
            if (node.from === ctx.pos) {
                return result;
            }
            // property proposals with schema
            this.getPropertyCompletions(this.schema, ctx, node, collector, addValue, rawWord);
        }
        else {
            // proposals for values
            const types = {};
            // value proposals with schema
            this.getValueCompletions(this.schema, ctx, types, collector);
        }
        // handle filtering
        result.options = Array.from(collector.completions.values()).filter((v) => (0, node_js_1.stripSurroundingQuotes)(v.label).startsWith(prefix));
        debug_js_1.debug.log("xxx", "result", result, "prefix", prefix, "collector.completions", collector.completions, "reservedKeys", collector.reservedKeys);
        return result;
    }
    applySnippetCompletion(completion) {
        return (0, autocomplete_1.snippetCompletion)(typeof completion.apply !== "string"
            ? completion.label
            : completion.apply, completion);
    }
    getPropertyCompletions(schema, ctx, node, collector, addValue, rawWord) {
        // don't suggest properties that are already present
        const properties = node.getChildren(constants_js_1.TOKENS.PROPERTY);
        debug_js_1.debug.log("xxx", "getPropertyCompletions", node, ctx, properties);
        properties.forEach((p) => {
            const key = (0, node_js_1.getWord)(ctx.state.doc, p.getChild(constants_js_1.TOKENS.PROPERTY_NAME));
            collector.reserve((0, node_js_1.stripSurroundingQuotes)(key));
        });
        // TODO: Handle separatorAfter
        // Get matching schemas
        const schemas = this.getSchemas(schema, ctx);
        schemas.forEach((s) => {
            if (typeof s !== "object") {
                return;
            }
            const properties = s.properties;
            if (properties) {
                Object.entries(properties).forEach(([key, value]) => {
                    var _a, _b;
                    if (typeof value === "object") {
                        const description = (_a = value.description) !== null && _a !== void 0 ? _a : "";
                        const type = (_b = value.type) !== null && _b !== void 0 ? _b : "";
                        const typeStr = Array.isArray(type) ? type.toString() : type;
                        const completion = {
                            // label is the unquoted key which will be displayed.
                            label: key,
                            apply: this.getInsertTextForProperty(key, addValue, rawWord, value),
                            type: "property",
                            detail: typeStr,
                            info: description,
                        };
                        collector.add(this.applySnippetCompletion(completion));
                    }
                });
            }
            const propertyNames = s.propertyNames;
            if (typeof propertyNames === "object") {
                if (propertyNames.enum) {
                    propertyNames.enum.forEach((v) => {
                        const label = v === null || v === void 0 ? void 0 : v.toString();
                        if (label) {
                            const completion = {
                                label,
                                apply: this.getInsertTextForProperty(label, addValue, rawWord),
                                type: "property",
                            };
                            collector.add(this.applySnippetCompletion(completion));
                        }
                    });
                }
                if (propertyNames.const) {
                    const label = propertyNames.const.toString();
                    const completion = {
                        label,
                        apply: this.getInsertTextForProperty(label, addValue, rawWord),
                        type: "property",
                    };
                    collector.add(this.applySnippetCompletion(completion));
                }
            }
        });
    }
    // apply is the quoted key which will be applied.
    // Normally the label needs to match the token
    // prefix i.e. if the token begins with `"to`, then the
    // label needs to have the quotes as well for it to match.
    // However we are manually filtering the results so we can
    // just use the unquoted key as the label, which is nicer
    // and gives us more control.
    // If no property value is present, then we add the colon as well.
    // Use snippetCompletion to handle insert value + position cursor e.g. "key": "#{}"
    // doc: https://codemirror.net/docs/ref/#autocomplete.snippetCompletion
    // idea: https://discuss.codemirror.net/t/autocomplete-cursor-position-in-apply-function/4088/3
    getInsertTextForProperty(key, addValue, rawWord, propertySchema) {
        var _a;
        // expand schema property if it is a reference
        propertySchema = propertySchema
            ? this.expandSchemaProperty(propertySchema, this.schema)
            : propertySchema;
        const isJSON5 = ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.mode) === "json5";
        let resultText = isJSON5
            ? json5PropertyInsertSnippet(rawWord, key)
            : `"${key}"`;
        if (!addValue) {
            return resultText;
        }
        resultText += ": ";
        let value;
        let nValueProposals = 0;
        if (typeof propertySchema === "object") {
            if (typeof propertySchema.default !== "undefined") {
                if (!value) {
                    value = this.getInsertTextForGuessedValue(propertySchema.default, "");
                }
                nValueProposals++;
            }
            else {
                if (propertySchema.enum) {
                    if (!value && propertySchema.enum.length === 1) {
                        value = this.getInsertTextForGuessedValue(propertySchema.enum[0], "");
                    }
                    nValueProposals += propertySchema.enum.length;
                }
                if (typeof propertySchema.const !== "undefined") {
                    if (!value) {
                        value = this.getInsertTextForGuessedValue(propertySchema.const, "");
                    }
                    nValueProposals++;
                }
                if (Array.isArray(propertySchema.examples) &&
                    propertySchema.examples.length) {
                    if (!value) {
                        value = this.getInsertTextForGuessedValue(propertySchema.examples[0], "");
                    }
                    nValueProposals += propertySchema.examples.length;
                }
                if (value === undefined && nValueProposals === 0) {
                    let type = Array.isArray(propertySchema.type)
                        ? propertySchema.type[0]
                        : propertySchema.type;
                    if (!type) {
                        if (propertySchema.properties) {
                            type = "object";
                        }
                        else if (propertySchema.items) {
                            type = "array";
                        }
                    }
                    switch (type) {
                        case "boolean":
                            value = "#{}";
                            break;
                        case "string":
                            value = isJSON5 ? "'#{}'" : '"#{}"';
                            break;
                        case "object":
                            value = "{#{}}";
                            break;
                        case "array":
                            value = "[#{}]";
                            break;
                        case "number":
                        case "integer":
                            value = "#{0}";
                            break;
                        case "null":
                            value = "#{null}";
                            break;
                        default:
                            // always advance the cursor after completing a property
                            value = "#{}";
                            break;
                    }
                }
            }
        }
        if (!value || nValueProposals > 1) {
            debug_js_1.debug.log("xxx", "value", value, "nValueProposals", nValueProposals, propertySchema);
            value = "#{}";
        }
        return resultText + value;
    }
    getInsertTextForGuessedValue(value, separatorAfter = "") {
        switch (typeof value) {
            case "object":
                if (value === null) {
                    return "${null}" + separatorAfter;
                }
                return this.getInsertTextForValue(value, separatorAfter);
            case "string": {
                let snippetValue = JSON.stringify(value);
                snippetValue = snippetValue.substr(1, snippetValue.length - 2); // remove quotes
                snippetValue = this.getInsertTextForPlainText(snippetValue); // escape \ and }
                return '"${' + snippetValue + '}"' + separatorAfter;
            }
            case "number":
            case "boolean":
                return "${" + JSON.stringify(value) + "}" + separatorAfter;
        }
        return this.getInsertTextForValue(value, separatorAfter);
    }
    getInsertTextForPlainText(text) {
        return text.replace(/[\\$}]/g, "\\$&"); // escape $, \ and }
    }
    getInsertTextForValue(value, separatorAfter) {
        const text = JSON.stringify(value, null, "\t");
        if (text === "{}") {
            return "{#{}}" + separatorAfter;
        }
        else if (text === "[]") {
            return "[#{}]" + separatorAfter;
        }
        return this.getInsertTextForPlainText(text + separatorAfter);
    }
    getValueCompletions(schema, ctx, types, collector) {
        let node = (0, language_1.syntaxTree)(ctx.state).resolveInner(ctx.pos, -1);
        let valueNode = null;
        let parentKey = undefined;
        debug_js_1.debug.log("xxx", "getValueCompletions", node, ctx);
        if (node && (0, node_js_1.isPrimitiveValueNode)(node)) {
            valueNode = node;
            node = node.parent;
        }
        if (!node) {
            this.addSchemaValueCompletions(schema, types, collector);
            return;
        }
        if (node.name === constants_js_1.TOKENS.PROPERTY) {
            const keyNode = node.getChild(constants_js_1.TOKENS.PROPERTY_NAME);
            if (keyNode) {
                parentKey = (0, node_js_1.getWord)(ctx.state.doc, keyNode);
                node = node.parent;
            }
        }
        debug_js_1.debug.log("xxx", "node", node, "parentKey", parentKey);
        if (node && (parentKey !== undefined || node.name === constants_js_1.TOKENS.ARRAY)) {
            // Get matching schemas
            const schemas = this.getSchemas(schema, ctx);
            for (const s of schemas) {
                if (typeof s !== "object") {
                    return;
                }
                if (node.name === constants_js_1.TOKENS.ARRAY && s.items) {
                    let c = collector;
                    if (s.uniqueItems) {
                        c = Object.assign(Object.assign({}, c), { add(completion) {
                                if (!c.completions.has(completion.label)) {
                                    collector.add(completion);
                                }
                            },
                            reserve(key) {
                                collector.reserve(key);
                            } });
                    }
                    if (Array.isArray(s.items)) {
                        let arrayIndex = 0;
                        if (valueNode) {
                            // get index of next node in array
                            const foundIdx = (0, node_js_1.findNodeIndexInArrayNode)(node, valueNode);
                            if (foundIdx >= 0) {
                                arrayIndex = foundIdx;
                            }
                        }
                        const itemSchema = s.items[arrayIndex];
                        if (itemSchema) {
                            this.addSchemaValueCompletions(itemSchema, types, c);
                        }
                    }
                    else {
                        this.addSchemaValueCompletions(s.items, types, c);
                    }
                }
                if (parentKey !== undefined) {
                    let propertyMatched = false;
                    if (s.properties) {
                        const propertySchema = s.properties[parentKey];
                        if (propertySchema) {
                            propertyMatched = true;
                            this.addSchemaValueCompletions(propertySchema, types, collector);
                        }
                    }
                    if (s.patternProperties && !propertyMatched) {
                        for (const pattern of Object.keys(s.patternProperties)) {
                            const regex = this.extendedRegExp(pattern);
                            if (regex === null || regex === void 0 ? void 0 : regex.test(parentKey)) {
                                propertyMatched = true;
                                const propertySchema = s.patternProperties[pattern];
                                if (propertySchema) {
                                    this.addSchemaValueCompletions(propertySchema, types, collector);
                                }
                            }
                        }
                    }
                    if (s.additionalProperties && !propertyMatched) {
                        const propertySchema = s.additionalProperties;
                        this.addSchemaValueCompletions(propertySchema, types, collector);
                    }
                }
                if (types["boolean"]) {
                    this.addBooleanValueCompletion(true, collector);
                    this.addBooleanValueCompletion(false, collector);
                }
                if (types["null"]) {
                    this.addNullValueCompletion(collector);
                }
            }
        }
    }
    addSchemaValueCompletions(schema, types, collector) {
        if (typeof schema === "object") {
            this.addEnumValueCompletions(schema, collector);
            this.addDefaultValueCompletions(schema, collector);
            this.collectTypes(schema, types);
            if (Array.isArray(schema.allOf)) {
                schema.allOf.forEach((s) => this.addSchemaValueCompletions(s, types, collector));
            }
            if (Array.isArray(schema.anyOf)) {
                schema.anyOf.forEach((s) => this.addSchemaValueCompletions(s, types, collector));
            }
            if (Array.isArray(schema.oneOf)) {
                schema.oneOf.forEach((s) => this.addSchemaValueCompletions(s, types, collector));
            }
        }
    }
    addDefaultValueCompletions(schema, collector, arrayDepth = 0) {
        let hasProposals = false;
        if (typeof schema.default !== "undefined") {
            let type = schema.type;
            let value = schema.default;
            for (let i = arrayDepth; i > 0; i--) {
                value = [value];
                type = "array";
            }
            const completionItem = {
                type: type === null || type === void 0 ? void 0 : type.toString(),
                label: this.getLabelForValue(value),
                detail: "Default value",
            };
            collector.add(completionItem);
            hasProposals = true;
        }
        if (Array.isArray(schema.examples)) {
            schema.examples.forEach((example) => {
                let type = schema.type;
                let value = example;
                for (let i = arrayDepth; i > 0; i--) {
                    value = [value];
                    type = "array";
                }
                collector.add({
                    type: type === null || type === void 0 ? void 0 : type.toString(),
                    label: this.getLabelForValue(value),
                });
                hasProposals = true;
            });
        }
        if (!hasProposals &&
            typeof schema.items === "object" &&
            !Array.isArray(schema.items) &&
            arrayDepth < 5 /* beware of recursion */) {
            this.addDefaultValueCompletions(schema.items, collector, arrayDepth + 1);
        }
    }
    addEnumValueCompletions(schema, collector) {
        var _a, _b;
        if (typeof schema.const !== "undefined") {
            collector.add({
                type: (_a = schema.type) === null || _a === void 0 ? void 0 : _a.toString(),
                label: this.getLabelForValue(schema.const),
                info: schema.description,
            });
        }
        if (Array.isArray(schema.enum)) {
            for (let i = 0, length = schema.enum.length; i < length; i++) {
                const enm = schema.enum[i];
                collector.add({
                    type: (_b = schema.type) === null || _b === void 0 ? void 0 : _b.toString(),
                    label: this.getLabelForValue(enm),
                    info: schema.description,
                });
            }
        }
    }
    addBooleanValueCompletion(value, collector) {
        collector.add({
            type: "boolean",
            label: value ? "true" : "false",
        });
    }
    addNullValueCompletion(collector) {
        collector.add({
            type: "null",
            label: "null",
        });
    }
    collectTypes(schema, types) {
        if (Array.isArray(schema.enum) || typeof schema.const !== "undefined") {
            return;
        }
        const type = schema.type;
        if (Array.isArray(type)) {
            type.forEach((t) => (types[t] = true));
        }
        else if (type) {
            types[type] = true;
        }
    }
    getSchemas(schema, ctx) {
        var _a;
        const draft = new json_schema_library_1.Draft07(this.schema);
        let pointer = (0, jsonPointers_js_1.jsonPointerForPosition)(ctx.state, ctx.pos);
        let subSchema = draft.getSchema({ pointer });
        if ((0, json_schema_library_1.isJsonError)(subSchema)) {
            subSchema = (_a = subSchema.data) === null || _a === void 0 ? void 0 : _a.schema;
        }
        // if we don't have a schema for the current pointer, try the parent pointer
        if (!subSchema ||
            subSchema.name === "UnknownPropertyError" ||
            subSchema.enum ||
            subSchema.type === "undefined") {
            pointer = pointer.replace(/\/[^/]*$/, "/");
            subSchema = draft.getSchema({ pointer });
        }
        debug_js_1.debug.log("xxx", "pointer..", JSON.stringify(pointer));
        // For some reason, it returns undefined schema for the root pointer
        if (!pointer || pointer === "/") {
            return [schema];
        }
        // const subSchema = new Draft07(this.schema).getSchema(pointer);
        debug_js_1.debug.log("xxx", "subSchema..", subSchema);
        if (!subSchema) {
            return [];
        }
        if (Array.isArray(subSchema.allOf)) {
            return [
                subSchema,
                ...subSchema.allOf.map((s) => this.expandSchemaProperty(s, schema)),
            ];
        }
        if (Array.isArray(subSchema.oneOf)) {
            return [
                subSchema,
                ...subSchema.oneOf.map((s) => this.expandSchemaProperty(s, schema)),
            ];
        }
        if (Array.isArray(subSchema.anyOf)) {
            return [
                subSchema,
                ...subSchema.anyOf.map((s) => this.expandSchemaProperty(s, schema)),
            ];
        }
        return [subSchema];
    }
    expandSchemaProperty(property, schema) {
        if (typeof property === "object" && property.$ref) {
            const refSchema = this.getReferenceSchema(schema, property.$ref);
            if (typeof refSchema === "object") {
                const dereferenced = Object.assign(Object.assign({}, property), refSchema);
                Reflect.deleteProperty(dereferenced, "$ref");
                return dereferenced;
            }
        }
        return property;
    }
    getReferenceSchema(schema, ref) {
        const refPath = ref.split("/");
        let curReference = schema;
        refPath.forEach((cur) => {
            if (!cur) {
                return;
            }
            if (cur === "#") {
                curReference = schema;
                return;
            }
            if (typeof curReference === "object") {
                curReference = curReference[cur];
            }
        });
        return curReference;
    }
    getLabelForValue(value) {
        return JSON.stringify(value);
    }
    getValueFromLabel(value) {
        return JSON.parse(value);
    }
    extendedRegExp(pattern) {
        let flags = "";
        if (pattern.startsWith("(?i)")) {
            pattern = pattern.substring(4);
            flags = "i";
        }
        try {
            return new RegExp(pattern, flags + "u");
        }
        catch (e) {
            // could be an exception due to the 'u ' flag
            try {
                return new RegExp(pattern, flags);
            }
            catch (e) {
                // invalid pattern
                return undefined;
            }
        }
    }
}
exports.JSONCompletion = JSONCompletion;
/**
 * provides a JSON schema enabled autocomplete extension for codemirror
 * @group Codemirror Extensions
 */
function jsonCompletion(opts = {}) {
    const completion = new JSONCompletion(opts);
    return function jsonDoCompletion(ctx) {
        return completion.doComplete(ctx);
    };
}
exports.jsonCompletion = jsonCompletion;
/**
 * provides a JSON schema enabled autocomplete extension for codemirror and json5
 * @group Codemirror Extensions
 */
function json5Completion(opts = {}) {
    const completion = new JSONCompletion(Object.assign(Object.assign({}, opts), { mode: "json5" }));
    return function jsonDoCompletion(ctx) {
        return completion.doComplete(ctx);
    };
}
exports.json5Completion = json5Completion;
