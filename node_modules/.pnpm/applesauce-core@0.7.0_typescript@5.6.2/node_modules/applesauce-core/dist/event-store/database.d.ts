/// <reference types="debug" />
/// <reference types="zen-observable" />
import { Filter, NostrEvent } from "nostr-tools";
import { LRU } from "../helpers/lru.js";
/**
 * An in-memory database for nostr events
 */
export declare class Database {
    protected log: import("debug").Debugger;
    /** Indexes */
    protected kinds: Map<number, Set<import("nostr-tools").Event>>;
    protected authors: Map<string, Set<import("nostr-tools").Event>>;
    protected tags: LRU<Set<import("nostr-tools").Event>>;
    protected created_at: NostrEvent[];
    /** LRU cache of last events touched */
    events: LRU<import("nostr-tools").Event>;
    private insertedSignal;
    private updatedSignal;
    private deletedSignal;
    /** A stream of events inserted into the database */
    inserted: {
        subscribe(observer: ZenObservable.Observer<import("nostr-tools").Event>): ZenObservable.Subscription;
        subscribe(onNext: (value: import("nostr-tools").Event) => void, onError?: ((error: any) => void) | undefined, onComplete?: (() => void) | undefined): ZenObservable.Subscription;
        forEach(callback: (value: import("nostr-tools").Event) => void): Promise<void>;
        map<R>(callback: (value: import("nostr-tools").Event) => R): import("zen-observable")<R>;
        filter<S extends import("nostr-tools").Event>(callback: (value: import("nostr-tools").Event) => value is S): import("zen-observable")<S>;
        filter(callback: (value: import("nostr-tools").Event) => boolean): import("zen-observable")<import("nostr-tools").Event>;
        reduce(callback: (previousValue: import("nostr-tools").Event, currentValue: import("nostr-tools").Event) => import("nostr-tools").Event, initialValue?: import("nostr-tools").Event | undefined): import("zen-observable")<import("nostr-tools").Event>;
        reduce<R_1>(callback: (previousValue: R_1, currentValue: import("nostr-tools").Event) => R_1, initialValue?: R_1 | undefined): import("zen-observable")<R_1>;
        flatMap<R_2>(callback: (value: import("nostr-tools").Event) => ZenObservable.ObservableLike<R_2>): import("zen-observable")<R_2>;
        concat<R_3>(...observable: import("zen-observable")<R_3>[]): import("zen-observable")<R_3>;
    };
    /** A stream of events that have been updated */
    updated: {
        subscribe(observer: ZenObservable.Observer<import("nostr-tools").Event>): ZenObservable.Subscription;
        subscribe(onNext: (value: import("nostr-tools").Event) => void, onError?: ((error: any) => void) | undefined, onComplete?: (() => void) | undefined): ZenObservable.Subscription;
        forEach(callback: (value: import("nostr-tools").Event) => void): Promise<void>;
        map<R>(callback: (value: import("nostr-tools").Event) => R): import("zen-observable")<R>;
        filter<S extends import("nostr-tools").Event>(callback: (value: import("nostr-tools").Event) => value is S): import("zen-observable")<S>;
        filter(callback: (value: import("nostr-tools").Event) => boolean): import("zen-observable")<import("nostr-tools").Event>;
        reduce(callback: (previousValue: import("nostr-tools").Event, currentValue: import("nostr-tools").Event) => import("nostr-tools").Event, initialValue?: import("nostr-tools").Event | undefined): import("zen-observable")<import("nostr-tools").Event>;
        reduce<R_1>(callback: (previousValue: R_1, currentValue: import("nostr-tools").Event) => R_1, initialValue?: R_1 | undefined): import("zen-observable")<R_1>;
        flatMap<R_2>(callback: (value: import("nostr-tools").Event) => ZenObservable.ObservableLike<R_2>): import("zen-observable")<R_2>;
        concat<R_3>(...observable: import("zen-observable")<R_3>[]): import("zen-observable")<R_3>;
    };
    /** A stream of events removed of the database */
    deleted: {
        subscribe(observer: ZenObservable.Observer<import("nostr-tools").Event>): ZenObservable.Subscription;
        subscribe(onNext: (value: import("nostr-tools").Event) => void, onError?: ((error: any) => void) | undefined, onComplete?: (() => void) | undefined): ZenObservable.Subscription;
        forEach(callback: (value: import("nostr-tools").Event) => void): Promise<void>;
        map<R>(callback: (value: import("nostr-tools").Event) => R): import("zen-observable")<R>;
        filter<S extends import("nostr-tools").Event>(callback: (value: import("nostr-tools").Event) => value is S): import("zen-observable")<S>;
        filter(callback: (value: import("nostr-tools").Event) => boolean): import("zen-observable")<import("nostr-tools").Event>;
        reduce(callback: (previousValue: import("nostr-tools").Event, currentValue: import("nostr-tools").Event) => import("nostr-tools").Event, initialValue?: import("nostr-tools").Event | undefined): import("zen-observable")<import("nostr-tools").Event>;
        reduce<R_1>(callback: (previousValue: R_1, currentValue: import("nostr-tools").Event) => R_1, initialValue?: R_1 | undefined): import("zen-observable")<R_1>;
        flatMap<R_2>(callback: (value: import("nostr-tools").Event) => ZenObservable.ObservableLike<R_2>): import("zen-observable")<R_2>;
        concat<R_3>(...observable: import("zen-observable")<R_3>[]): import("zen-observable")<R_3>;
    };
    get size(): number;
    protected claims: WeakMap<import("nostr-tools").Event, any>;
    /** Index helper methods */
    protected getKindIndex(kind: number): Set<import("nostr-tools").Event>;
    protected getAuthorsIndex(author: string): Set<import("nostr-tools").Event>;
    protected getTagIndex(tagAndValue: string): Set<import("nostr-tools").Event>;
    /** Moves an event to the top of the LRU cache */
    touch(event: NostrEvent): void;
    hasEvent(uid: string): import("nostr-tools").Event | undefined;
    getEvent(uid: string): import("nostr-tools").Event | undefined;
    /** Checks if the database contains a replaceable event without touching it */
    hasReplaceable(kind: number, pubkey: string, d?: string): boolean;
    /** Gets a replaceable event and touches it */
    getReplaceable(kind: number, pubkey: string, d?: string): import("nostr-tools").Event | undefined;
    /** Inserts an event into the database and notifies all subscriptions */
    addEvent(event: NostrEvent): import("nostr-tools").Event;
    /** Inserts and event into the database and notifies all subscriptions that the event has updated */
    updateEvent(event: NostrEvent): import("nostr-tools").Event;
    /** Deletes an event from the database and notifies all subscriptions */
    deleteEvent(eventOrUID: string | NostrEvent): boolean;
    /** Sets the claim on the event and touches it */
    claimEvent(event: NostrEvent, claim: any): void;
    /** Checks if an event is claimed by anything */
    isClaimed(event: NostrEvent): boolean;
    /** Removes a claim from an event */
    removeClaim(event: NostrEvent, claim: any): void;
    /** Removes all claims on an event */
    clearClaim(event: NostrEvent): void;
    iterateAuthors(authors: Iterable<string>): Generator<import("nostr-tools").Event, void, unknown>;
    iterateTag(tag: string, values: Iterable<string>): Generator<import("nostr-tools").Event, void, unknown>;
    iterateKinds(kinds: Iterable<number>): Generator<import("nostr-tools").Event, void, unknown>;
    iterateTime(since: number | undefined, until: number | undefined): Generator<never, Set<import("nostr-tools").Event>, unknown>;
    iterateIds(ids: Iterable<string>): Generator<import("nostr-tools").Event, void, unknown>;
    /** Returns all events that match the filter */
    getEventsForFilter(filter: Filter): Set<NostrEvent>;
    getForFilters(filters: Filter[]): Set<import("nostr-tools").Event>;
    /** Remove the oldest events that are not claimed */
    prune(limit?: number): number;
}
