import fetch from "cross-fetch";
import { bytesToHex } from "@noble/hashes/utils";
import { readFileAsArrayBuffer as readBlobAsArrayBuffer } from "./helpers.js";
const now = () => Math.floor(new Date().valueOf() / 1000);
const oneHour = () => now() + 60 * 60;
export const AUTH_EVENT_KIND = 24242;
export class HTTPError extends Error {
    constructor(response, body) {
        super(typeof body === "string" ? body : body.message);
        this.response = response;
        this.status = response.status;
        if (typeof body == "object")
            this.body = body;
    }
    static async handleErrorResponse(res) {
        if (!res.ok) {
            try {
                throw new HTTPError(res, await res.json());
            }
            catch (e) {
                if (e instanceof Error)
                    throw new HTTPError(res, e.message);
            }
        }
    }
}
export class BlossomClient {
    constructor(server, signer) {
        this.server = new URL("/", server);
        this.signer = signer;
    }
    static async getFileSha256(file) {
        const buffer = file instanceof File ? await file.arrayBuffer() : await readBlobAsArrayBuffer(file);
        let hash;
        if (crypto.subtle) {
            const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
            hash = new Uint8Array(hashBuffer);
        }
        else {
            const { sha256 } = await import("@noble/hashes/sha256");
            hash = sha256.create().update(new Uint8Array(buffer)).digest();
        }
        return bytesToHex(hash);
    }
    static async getGetAuth(signer, message = "Get Blobs", expiration = oneHour()) {
        return await signer({
            created_at: now(),
            kind: AUTH_EVENT_KIND,
            content: message,
            tags: [
                ["t", "get"],
                ["expiration", String(expiration)],
            ],
        });
    }
    static async getUploadAuth(file, signer, message = "Upload Blob", expiration = oneHour()) {
        const sha256 = await BlossomClient.getFileSha256(file);
        // add tags
        const tags = [];
        tags.push(["t", "upload"]);
        if (file instanceof File)
            tags.push(["name", file.name]);
        tags.push(["size", String(file.size)]);
        tags.push(["x", sha256]);
        tags.push(["expiration", String(expiration)]);
        return await signer({
            created_at: now(),
            kind: AUTH_EVENT_KIND,
            content: message,
            tags,
        });
    }
    static async getDeleteAuth(hash, signer, message = "Delete Blob", expiration = oneHour()) {
        return await signer({
            created_at: now(),
            kind: AUTH_EVENT_KIND,
            content: message,
            tags: [
                ["t", "delete"],
                ["x", hash],
                ["expiration", String(expiration)],
            ],
        });
    }
    static async getListAuth(signer, message = "List Blobs", expiration = oneHour()) {
        return await signer({
            created_at: now(),
            kind: AUTH_EVENT_KIND,
            content: message,
            tags: [
                ["t", "list"],
                ["expiration", String(expiration)],
            ],
        });
    }
    async getGetAuth(message, expiration) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await BlossomClient.getGetAuth(this.signer, message, expiration);
    }
    async getUploadAuth(file, message, expiration) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await BlossomClient.getUploadAuth(file, this.signer, message, expiration);
    }
    async getDeleteAuth(hash, message, expiration) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await BlossomClient.getDeleteAuth(hash, this.signer, message, expiration);
    }
    async getListAuth(message, expiration) {
        if (!this.signer)
            throw new Error("Missing signer");
        return await BlossomClient.getListAuth(this.signer, message, expiration);
    }
    static encodeAuthorizationHeader(event) {
        return "Nostr " + btoa(JSON.stringify(event));
    }
    static async getBlob(server, hash, auth) {
        const res = await fetch(new URL(hash, server), {
            headers: auth ? { authorization: BlossomClient.encodeAuthorizationHeader(auth) } : {},
        });
        await HTTPError.handleErrorResponse(res);
        return await res.blob();
    }
    async getBlob(hash, auth = false) {
        if (typeof auth === "boolean" && auth)
            auth = await this.getGetAuth();
        return BlossomClient.getBlob(this.server, hash, auth ? auth : undefined);
    }
    static async hasBlob(server, hash) {
        const res = await fetch(new URL(`/` + hash, server), { method: "HEAD" });
        await HTTPError.handleErrorResponse(res);
        return res.ok;
    }
    async hasBlob(hash) {
        return BlossomClient.hasBlob(this.server, hash);
    }
    static async listBlobs(server, pubkey, opts, auth) {
        const url = new URL(`/list/` + pubkey, server);
        if (opts?.since)
            url.searchParams.append("since", String(opts.since));
        if (opts?.until)
            url.searchParams.append("until", String(opts.until));
        const res = await fetch(url, {
            headers: auth ? { authorization: BlossomClient.encodeAuthorizationHeader(auth) } : {},
        });
        await HTTPError.handleErrorResponse(res);
        return (await res.json());
    }
    async listBlobs(pubkey, opts, auth = false) {
        if (typeof auth === "boolean" && auth)
            auth = await this.getListAuth();
        return BlossomClient.listBlobs(this.server, pubkey, opts, auth ? auth : undefined);
    }
    static async deleteBlob(server, hash, auth) {
        const res = await fetch(new URL("/" + hash, server), {
            method: "DELETE",
            headers: auth ? { authorization: BlossomClient.encodeAuthorizationHeader(auth) } : {},
        });
        await HTTPError.handleErrorResponse(res);
        return await res.text();
    }
    async deleteBlob(hash, auth = true) {
        if (typeof auth === "boolean" && auth)
            auth = await this.getDeleteAuth(hash);
        return BlossomClient.deleteBlob(this.server, hash, auth ? auth : undefined);
    }
    static async uploadBlob(server, file, auth) {
        const res = await fetch(new URL("/upload", server), {
            method: "PUT",
            body: file,
            headers: auth ? { authorization: BlossomClient.encodeAuthorizationHeader(auth) } : {},
        });
        await HTTPError.handleErrorResponse(res);
        return (await res.json());
    }
    async uploadBlob(file, auth = true) {
        if (typeof auth === "boolean" && auth)
            auth = await this.getUploadAuth(file);
        return BlossomClient.uploadBlob(this.server, file, auth ? auth : undefined);
    }
}
