{
  "version": 3,
  "sources": ["../../.pnpm/zen-observable@0.9.0/node_modules/zen-observable/lib/Observable.js", "../../.pnpm/zen-observable@0.9.0/node_modules/zen-observable/index.js", "../../.pnpm/zen-push@0.3.1/node_modules/zen-push/index.js", "../../.pnpm/nostr-tools@2.7.2_typescript@5.6.2/node_modules/nostr-tools/lib/esm/utils.js", "../../.pnpm/applesauce-core@0.7.0_typescript@5.6.2/node_modules/applesauce-core/dist/event-store/event-store.js", "../../.pnpm/applesauce-core@0.7.0_typescript@5.6.2/node_modules/applesauce-core/dist/event-store/database.js", "../../.pnpm/applesauce-core@0.7.0_typescript@5.6.2/node_modules/applesauce-core/dist/logger.js", "../../.pnpm/applesauce-core@0.7.0_typescript@5.6.2/node_modules/applesauce-core/dist/query-store/index.js"],
  "sourcesContent": ["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Observable = void 0;\n\n// === Symbol Support ===\nconst hasSymbol = name => Boolean(Symbol[name]);\n\nconst getSymbol = name => hasSymbol(name) ? Symbol[name] : '@@' + name;\n\nif (!hasSymbol('observable') && Object.isExtensible(Symbol)) {\n  Symbol.observable = Symbol('observable');\n}\n\nconst SymbolIterator = getSymbol('iterator');\nconst SymbolObservable = getSymbol('observable');\nconst SymbolSpecies = getSymbol('species'); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  let value = obj[key];\n  if (value == null) return undefined;\n  if (typeof value !== 'function') throw new TypeError(value + ' is not a function');\n  return value;\n}\n\nfunction getSpecies(obj) {\n  let ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(e) {\n  if (hostReportError.log) {\n    hostReportError.log(e);\n  } else {\n    setTimeout(() => {\n      throw e;\n    });\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(() => {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  let cleanup = subscription._cleanup;\n  if (cleanup === undefined) return;\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === 'function') {\n      cleanup();\n    } else {\n      let unsubscribe = getMethod(cleanup, 'unsubscribe');\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = 'closed';\n}\n\nfunction flushSubscription(subscription) {\n  let queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = 'ready';\n\n  for (let i = 0; i < queue.length; ++i) {\n    notifySubscription(subscription, queue[i].type, queue[i].value);\n    if (subscription._state === 'closed') break;\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = 'running';\n  let observer = subscription._observer;\n\n  try {\n    let m = getMethod(observer, type);\n\n    switch (type) {\n      case 'next':\n        if (m) m.call(observer, value);\n        break;\n\n      case 'error':\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case 'complete':\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === 'closed') cleanupSubscription(subscription);else if (subscription._state === 'running') subscription._state = 'ready';\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === 'closed') return;\n\n  if (subscription._state === 'buffering') {\n    subscription._queue.push({\n      type,\n      value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== 'ready') {\n    subscription._state = 'buffering';\n    subscription._queue = [{\n      type,\n      value\n    }];\n    enqueue(() => flushSubscription(subscription));\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nclass Subscription {\n  constructor(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = 'initializing';\n    let self = this;\n    let subscriptionObserver = {\n      get closed() {\n        return self._state === 'closed';\n      },\n\n      next(value) {\n        onNotify(self, 'next', value);\n      },\n\n      error(value) {\n        onNotify(self, 'error', value);\n      },\n\n      complete() {\n        onNotify(self, 'complete');\n      }\n\n    };\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === 'initializing') this._state = 'ready';\n  }\n\n  get closed() {\n    return this._state === 'closed';\n  }\n\n  unsubscribe() {\n    if (this._state !== 'closed') {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  }\n\n}\n\nclass Observable {\n  constructor(subscriber) {\n    if (!(this instanceof Observable)) throw new TypeError('Observable cannot be called as a function');\n    if (typeof subscriber !== 'function') throw new TypeError('Observable initializer must be a function');\n    this._subscriber = subscriber;\n  }\n\n  subscribe(observer) {\n    if (typeof observer !== 'object' || observer === null) {\n      observer = {\n        next: observer,\n        error: arguments[1],\n        complete: arguments[2]\n      };\n    }\n\n    return new Subscription(observer, this._subscriber);\n  }\n\n  forEach(fn) {\n    return new Promise((resolve, reject) => {\n      if (typeof fn !== 'function') {\n        reject(new TypeError(fn + ' is not a function'));\n        return;\n      }\n\n      function done() {\n        subscription.unsubscribe();\n        resolve();\n      }\n\n      let subscription = this.subscribe({\n        next(value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n\n        error: reject,\n        complete: resolve\n      });\n    });\n  }\n\n  map(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        try {\n          value = fn(value);\n        } catch (e) {\n          return observer.error(e);\n        }\n\n        observer.next(value);\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        observer.complete();\n      }\n\n    }));\n  }\n\n  filter(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        try {\n          if (!fn(value)) return;\n        } catch (e) {\n          return observer.error(e);\n        }\n\n        observer.next(value);\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        observer.complete();\n      }\n\n    }));\n  }\n\n  reduce(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    let hasSeed = arguments.length > 1;\n    let hasValue = false;\n    let seed = arguments[1];\n    let acc = seed;\n    return new C(observer => this.subscribe({\n      next(value) {\n        let first = !hasValue;\n        hasValue = true;\n\n        if (!first || hasSeed) {\n          try {\n            acc = fn(acc, value);\n          } catch (e) {\n            return observer.error(e);\n          }\n        } else {\n          acc = value;\n        }\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        if (!hasValue && !hasSeed) return observer.error(new TypeError('Cannot reduce an empty sequence'));\n        observer.next(acc);\n        observer.complete();\n      }\n\n    }));\n  }\n\n  async all() {\n    let values = [];\n    await this.forEach(value => values.push(value));\n    return values;\n  }\n\n  concat(...sources) {\n    let C = getSpecies(this);\n    return new C(observer => {\n      let subscription;\n      let index = 0;\n\n      function startNext(next) {\n        subscription = next.subscribe({\n          next(v) {\n            observer.next(v);\n          },\n\n          error(e) {\n            observer.error(e);\n          },\n\n          complete() {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n\n        });\n      }\n\n      startNext(this);\n      return () => {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  }\n\n  flatMap(fn) {\n    if (typeof fn !== 'function') throw new TypeError(fn + ' is not a function');\n    let C = getSpecies(this);\n    return new C(observer => {\n      let subscriptions = [];\n      let outer = this.subscribe({\n        next(value) {\n          if (fn) {\n            try {\n              value = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          }\n\n          let inner = C.from(value).subscribe({\n            next(value) {\n              observer.next(value);\n            },\n\n            error(e) {\n              observer.error(e);\n            },\n\n            complete() {\n              let i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n\n          });\n          subscriptions.push(inner);\n        },\n\n        error(e) {\n          observer.error(e);\n        },\n\n        complete() {\n          completeIfDone();\n        }\n\n      });\n\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) observer.complete();\n      }\n\n      return () => {\n        subscriptions.forEach(s => s.unsubscribe());\n        outer.unsubscribe();\n      };\n    });\n  }\n\n  [SymbolObservable]() {\n    return this;\n  }\n\n  static from(x) {\n    let C = typeof this === 'function' ? this : Observable;\n    if (x == null) throw new TypeError(x + ' is not an object');\n    let method = getMethod(x, SymbolObservable);\n\n    if (method) {\n      let observable = method.call(x);\n      if (Object(observable) !== observable) throw new TypeError(observable + ' is not an object');\n      if (isObservable(observable) && observable.constructor === C) return observable;\n      return new C(observer => observable.subscribe(observer));\n    }\n\n    if (hasSymbol('iterator')) {\n      method = getMethod(x, SymbolIterator);\n\n      if (method) {\n        return new C(observer => {\n          enqueue(() => {\n            if (observer.closed) return;\n\n            for (let item of method.call(x)) {\n              observer.next(item);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n    }\n\n    if (Array.isArray(x)) {\n      return new C(observer => {\n        enqueue(() => {\n          if (observer.closed) return;\n\n          for (let i = 0; i < x.length; ++i) {\n            observer.next(x[i]);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n\n    throw new TypeError(x + ' is not observable');\n  }\n\n  static of(...items) {\n    let C = typeof this === 'function' ? this : Observable;\n    return new C(observer => {\n      enqueue(() => {\n        if (observer.closed) return;\n\n        for (let i = 0; i < items.length; ++i) {\n          observer.next(items[i]);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    });\n  }\n\n  static get [SymbolSpecies]() {\n    return this;\n  }\n\n}\n\nexports.Observable = Observable;\nObject.defineProperty(Observable, Symbol('extensions'), {\n  value: {\n    symbol: SymbolObservable,\n    hostReportError\n  },\n  configurable: true\n});", "module.exports = require('./lib/Observable.js').Observable;\n", "'use strict';\n\nvar Observable = require('zen-observable');\n\nfunction send(p, message, value) {\n  if (p._observer) {\n    sendMessage(p._observer, message, value);\n  } else if (p._observers) {\n    var list = [];\n    p._observers.forEach(function(to) { list.push(to); });\n    list.forEach(function(to) { sendMessage(to, message, value); });\n  }\n}\n\nfunction sendMessage(observer, message, value) {\n  if (observer.closed) {\n    return;\n  }\n  switch (message) {\n    case 'next': return observer.next(value);\n    case 'error': return observer.error(value);\n    case 'complete': return observer.complete();\n  }\n}\n\nfunction hasObserver(p) {\n  return p._observer || p._observers && p._observers.size > 0;\n}\n\nfunction addObserver(p, observer) {\n  if (p._observers) {\n    p._observers.add(observer);\n  } else if (!p._observer) {\n    p._observer = observer;\n  } else {\n    p._observers = new Set();\n    p._observers.add(p._observer);\n    p._observers.add(observer);\n    p._observer = null;\n  }\n}\n\nfunction deleteObserver(p, observer) {\n  if (p._observers) {\n    p._observers.delete(observer);\n  } else if (p._observer === observer) {\n    p._observer = null;\n  }\n}\n\nfunction notifyStart(p, opts) {\n  !hasObserver(p) && opts && opts.start && opts.start();\n}\n\nfunction notifyPause(p, opts) {\n  !hasObserver(p) && opts && opts.pause && opts.pause();\n}\n\nclass PushStream {\n  constructor(opts) {\n    this._observer = null;\n    this._observers = null;\n    this._observable = new Observable((observer) => {\n      notifyStart(this, opts);\n      addObserver(this, observer);\n      return () => {\n        deleteObserver(this, observer);\n        notifyPause(this, opts);\n      };\n    });\n  }\n\n  get observable() {\n    return this._observable;\n  }\n\n  get observed() {\n    return hasObserver(this);\n  }\n\n  next(x) {\n    send(this, 'next', x);\n  }\n\n  error(e) {\n    send(this, 'error', e);\n  }\n\n  complete() {\n    send(this, 'complete');\n  }\n\n  static multicast(observable) {\n    let stream = new this();\n    observable.subscribe(stream);\n    return stream.observable;\n  }\n}\n\nmodule.exports = PushStream;\n", "// utils.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  if (url.indexOf(\"://\") === -1)\n    url = \"wss://\" + url;\n  let p = new URL(url);\n  p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n  if (p.pathname.endsWith(\"/\"))\n    p.pathname = p.pathname.slice(0, -1);\n  if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n    p.port = \"\";\n  p.searchParams.sort();\n  p.hash = \"\";\n  return p.toString();\n}\nfunction insertEventIntoDescendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return b.created_at - event.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction insertEventIntoAscendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return event.created_at - b.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction binarySearch(arr, compare) {\n  let start = 0;\n  let end = arr.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const cmp = compare(arr[mid]);\n    if (cmp === 0) {\n      return [mid, true];\n    }\n    if (cmp < 0) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return [start, false];\n}\nvar QueueNode = class {\n  value;\n  next = null;\n  prev = null;\n  constructor(message) {\n    this.value = message;\n  }\n};\nvar Queue = class {\n  first;\n  last;\n  constructor() {\n    this.first = null;\n    this.last = null;\n  }\n  enqueue(value) {\n    const newNode = new QueueNode(value);\n    if (!this.last) {\n      this.first = newNode;\n      this.last = newNode;\n    } else if (this.last === this.first) {\n      this.last = newNode;\n      this.last.prev = this.first;\n      this.first.next = newNode;\n    } else {\n      newNode.prev = this.last;\n      this.last.next = newNode;\n      this.last = newNode;\n    }\n    return true;\n  }\n  dequeue() {\n    if (!this.first)\n      return null;\n    if (this.first === this.last) {\n      const target2 = this.first;\n      this.first = null;\n      this.last = null;\n      return target2.value;\n    }\n    const target = this.first;\n    this.first = target.next;\n    return target.value;\n  }\n};\nexport {\n  Queue,\n  QueueNode,\n  binarySearch,\n  insertEventIntoAscendingList,\n  insertEventIntoDescendingList,\n  normalizeURL,\n  utf8Decoder,\n  utf8Encoder\n};\n", "import { insertEventIntoDescendingList } from \"nostr-tools/utils\";\nimport Observable from \"zen-observable\";\nimport { Database } from \"./database.js\";\nimport { getEventUID, getReplaceableUID } from \"../helpers/event.js\";\nimport { matchFilters } from \"../helpers/filter.js\";\nimport { addSeenRelay } from \"../helpers/relays.js\";\nexport class EventStore {\n    database;\n    singles = new Map();\n    streams = new Map();\n    timelines = new Map();\n    constructor() {\n        this.database = new Database();\n    }\n    /** Adds an event to the database */\n    add(event, fromRelay) {\n        const inserted = this.database.addEvent(event);\n        if (fromRelay)\n            addSeenRelay(inserted, fromRelay);\n        return inserted;\n    }\n    /** Add an event to the store and notifies all subscribes it has updated */\n    update(event) {\n        return this.database.updateEvent(event);\n    }\n    getAll(filters) {\n        return this.database.getForFilters(filters);\n    }\n    hasEvent(uid) {\n        return this.database.hasEvent(uid);\n    }\n    getEvent(uid) {\n        return this.database.getEvent(uid);\n    }\n    hasReplaceable(kind, pubkey, d) {\n        return this.database.hasReplaceable(kind, pubkey, d);\n    }\n    getReplaceable(kind, pubkey, d) {\n        return this.database.getReplaceable(kind, pubkey, d);\n    }\n    /** Creates an observable that updates a single event */\n    event(uid) {\n        return new Observable((observer) => {\n            let current = this.database.getEvent(uid);\n            if (current) {\n                observer.next(current);\n                this.database.claimEvent(current, observer);\n            }\n            // subscribe to future events\n            const inserted = this.database.inserted.subscribe((event) => {\n                if (getEventUID(event) === uid && (!current || event.created_at > current.created_at)) {\n                    // remove old claim\n                    if (current)\n                        this.database.removeClaim(current, observer);\n                    current = event;\n                    observer.next(event);\n                    // claim new event\n                    this.database.claimEvent(current, observer);\n                }\n            });\n            // subscribe to updates\n            const updated = this.database.updated.subscribe((event) => {\n                if (event === current)\n                    observer.next(event);\n            });\n            // subscribe to deleted events\n            const deleted = this.database.deleted.subscribe((event) => {\n                if (getEventUID(event) === uid && current) {\n                    this.database.removeClaim(current, observer);\n                    current = undefined;\n                    observer.next(undefined);\n                }\n            });\n            this.singles.set(observer, uid);\n            return () => {\n                inserted.unsubscribe();\n                deleted.unsubscribe();\n                updated.unsubscribe();\n                this.singles.delete(observer);\n                if (current)\n                    this.database.removeClaim(current, observer);\n            };\n        });\n    }\n    /** Creates an observable that subscribes to multiple events */\n    events(uids) {\n        return new Observable((observer) => {\n            const events = new Map();\n            for (const uid of uids) {\n                const e = this.getEvent(uid);\n                if (e) {\n                    events.set(uid, e);\n                    this.database.claimEvent(e, observer);\n                }\n            }\n            observer.next(events);\n            // subscribe to future events\n            const inserted = this.database.inserted.subscribe((event) => {\n                const uid = getEventUID(event);\n                if (uids.includes(uid)) {\n                    const current = events.get(uid);\n                    // remove old claim\n                    if (!current || event.created_at > current.created_at) {\n                        if (current)\n                            this.database.removeClaim(current, observer);\n                        events.set(uid, event);\n                        observer.next(events);\n                        // claim new event\n                        this.database.claimEvent(event, observer);\n                    }\n                }\n            });\n            // subscribe to updates\n            const updated = this.database.updated.subscribe((event) => {\n                const uid = getEventUID(event);\n                if (uids.includes(uid))\n                    observer.next(events);\n            });\n            // subscribe to deleted events\n            const deleted = this.database.deleted.subscribe((event) => {\n                const uid = getEventUID(event);\n                if (uids.includes(uid)) {\n                    const current = events.get(uid);\n                    if (current) {\n                        this.database.removeClaim(current, observer);\n                        events.delete(uid);\n                        observer.next(events);\n                    }\n                }\n            });\n            return () => {\n                inserted.unsubscribe();\n                deleted.unsubscribe();\n                updated.unsubscribe();\n                for (const [_uid, event] of events) {\n                    this.database.removeClaim(event, observer);\n                }\n            };\n        });\n    }\n    /** Creates an observable that updates a single replaceable event */\n    replaceable(kind, pubkey, d) {\n        return this.event(getReplaceableUID(kind, pubkey, d));\n    }\n    /** Creates an observable that streams all events that match the filter */\n    stream(filters) {\n        return new Observable((observer) => {\n            let claimed = new Set();\n            let events = this.database.getForFilters(filters);\n            for (const event of events) {\n                observer.next(event);\n                this.database.claimEvent(event, observer);\n                claimed.add(event);\n            }\n            // subscribe to future events\n            const sub = this.database.inserted.subscribe((event) => {\n                if (matchFilters(filters, event)) {\n                    observer.next(event);\n                    this.database.claimEvent(event, observer);\n                    claimed.add(event);\n                }\n            });\n            this.streams.set(observer, filters);\n            return () => {\n                sub.unsubscribe();\n                this.streams.delete(observer);\n                // remove all claims\n                for (const event of claimed)\n                    this.database.removeClaim(event, observer);\n                claimed.clear();\n            };\n        });\n    }\n    /** Creates an observable that updates with an array of sorted events */\n    timeline(filters) {\n        return new Observable((observer) => {\n            const seen = new Map();\n            const timeline = [];\n            // build initial timeline\n            const events = this.database.getForFilters(filters);\n            for (const event of events) {\n                insertEventIntoDescendingList(timeline, event);\n                this.database.claimEvent(event, observer);\n                seen.set(getEventUID(event), event);\n            }\n            observer.next([...timeline]);\n            // subscribe to future events\n            const inserted = this.database.inserted.subscribe((event) => {\n                if (matchFilters(filters, event)) {\n                    const uid = getEventUID(event);\n                    let current = seen.get(uid);\n                    if (current) {\n                        if (event.created_at > current.created_at) {\n                            // replace event\n                            timeline.splice(timeline.indexOf(current), 1, event);\n                            observer.next([...timeline]);\n                            // update the claim\n                            seen.set(uid, event);\n                            this.database.removeClaim(current, observer);\n                            this.database.claimEvent(event, observer);\n                        }\n                    }\n                    else {\n                        insertEventIntoDescendingList(timeline, event);\n                        observer.next([...timeline]);\n                        // claim new event\n                        this.database.claimEvent(event, observer);\n                        seen.set(getEventUID(event), event);\n                    }\n                }\n            });\n            // subscribe to updates\n            const updated = this.database.updated.subscribe((event) => {\n                if (seen.has(getEventUID(event))) {\n                    observer.next([...timeline]);\n                }\n            });\n            // subscribe to removed events\n            const deleted = this.database.deleted.subscribe((event) => {\n                const uid = getEventUID(event);\n                let current = seen.get(uid);\n                if (current) {\n                    // remove the event\n                    timeline.splice(timeline.indexOf(current), 1);\n                    observer.next([...timeline]);\n                    // remove the claim\n                    seen.delete(uid);\n                    this.database.removeClaim(current, observer);\n                }\n            });\n            this.timelines.set(observer, filters);\n            return () => {\n                this.timelines.delete(observer);\n                inserted.unsubscribe();\n                deleted.unsubscribe();\n                updated.unsubscribe();\n                // remove all claims\n                for (const [_, event] of seen) {\n                    this.database.removeClaim(event, observer);\n                }\n                seen.clear();\n            };\n        });\n    }\n}\n", "import { binarySearch, insertEventIntoDescendingList } from \"nostr-tools/utils\";\nimport PushStream from \"zen-push\";\nimport { getEventUID, getIndexableTags, getReplaceableUID } from \"../helpers/event.js\";\nimport { INDEXABLE_TAGS } from \"./common.js\";\nimport { logger } from \"../logger.js\";\nimport { LRU } from \"../helpers/lru.js\";\n/**\n * An in-memory database for nostr events\n */\nexport class Database {\n    log = logger.extend(\"Database\");\n    /** Indexes */\n    kinds = new Map();\n    authors = new Map();\n    tags = new LRU();\n    created_at = [];\n    /** LRU cache of last events touched */\n    events = new LRU();\n    insertedSignal = new PushStream();\n    updatedSignal = new PushStream();\n    deletedSignal = new PushStream();\n    /** A stream of events inserted into the database */\n    inserted = this.insertedSignal.observable;\n    /** A stream of events that have been updated */\n    updated = this.updatedSignal.observable;\n    /** A stream of events removed of the database */\n    deleted = this.deletedSignal.observable;\n    get size() {\n        return this.events.size;\n    }\n    claims = new WeakMap();\n    /** Index helper methods */\n    getKindIndex(kind) {\n        if (!this.kinds.has(kind))\n            this.kinds.set(kind, new Set());\n        return this.kinds.get(kind);\n    }\n    getAuthorsIndex(author) {\n        if (!this.authors.has(author))\n            this.authors.set(author, new Set());\n        return this.authors.get(author);\n    }\n    getTagIndex(tagAndValue) {\n        if (!this.tags.has(tagAndValue)) {\n            // build new tag index from existing events\n            const events = new Set();\n            const ts = Date.now();\n            for (const event of this.events.values()) {\n                if (getIndexableTags(event).has(tagAndValue)) {\n                    events.add(event);\n                }\n            }\n            const took = Date.now() - ts;\n            if (took > 100)\n                this.log(`Built index ${tagAndValue} took ${took}ms`);\n            this.tags.set(tagAndValue, events);\n        }\n        return this.tags.get(tagAndValue);\n    }\n    /** Moves an event to the top of the LRU cache */\n    touch(event) {\n        this.events.set(getEventUID(event), event);\n    }\n    hasEvent(uid) {\n        return this.events.get(uid);\n    }\n    getEvent(uid) {\n        return this.events.get(uid);\n    }\n    /** Checks if the database contains a replaceable event without touching it */\n    hasReplaceable(kind, pubkey, d) {\n        return this.events.has(getReplaceableUID(kind, pubkey, d));\n    }\n    /** Gets a replaceable event and touches it */\n    getReplaceable(kind, pubkey, d) {\n        return this.events.get(getReplaceableUID(kind, pubkey, d));\n    }\n    /** Inserts an event into the database and notifies all subscriptions */\n    addEvent(event) {\n        const uid = getEventUID(event);\n        const current = this.events.get(uid);\n        if (current && event.created_at <= current.created_at)\n            return current;\n        this.events.set(uid, event);\n        this.getKindIndex(event.kind).add(event);\n        this.getAuthorsIndex(event.pubkey).add(event);\n        for (const tag of getIndexableTags(event)) {\n            if (this.tags.has(tag)) {\n                this.getTagIndex(tag).add(event);\n            }\n        }\n        insertEventIntoDescendingList(this.created_at, event);\n        this.insertedSignal.next(event);\n        return event;\n    }\n    /** Inserts and event into the database and notifies all subscriptions that the event has updated */\n    updateEvent(event) {\n        const inserted = this.addEvent(event);\n        this.updatedSignal.next(inserted);\n        return inserted;\n    }\n    /** Deletes an event from the database and notifies all subscriptions */\n    deleteEvent(eventOrUID) {\n        let event = typeof eventOrUID === \"string\" ? this.events.get(eventOrUID) : eventOrUID;\n        if (!event)\n            throw new Error(\"Missing event\");\n        const uid = getEventUID(event);\n        // only remove events that are known\n        if (!this.events.has(uid))\n            return false;\n        this.getAuthorsIndex(event.pubkey).delete(event);\n        this.getKindIndex(event.kind).delete(event);\n        for (const tag of getIndexableTags(event)) {\n            if (this.tags.has(tag)) {\n                this.getTagIndex(tag).delete(event);\n            }\n        }\n        // remove from created_at index\n        const i = this.created_at.indexOf(event);\n        this.created_at.splice(i, 1);\n        this.events.delete(uid);\n        this.deletedSignal.next(event);\n        return true;\n    }\n    /** Sets the claim on the event and touches it */\n    claimEvent(event, claim) {\n        if (!this.claims.has(event)) {\n            this.claims.set(event, claim);\n        }\n        // always touch event\n        this.touch(event);\n    }\n    /** Checks if an event is claimed by anything */\n    isClaimed(event) {\n        return this.claims.has(event);\n    }\n    /** Removes a claim from an event */\n    removeClaim(event, claim) {\n        const current = this.claims.get(event);\n        if (current === claim)\n            this.claims.delete(event);\n    }\n    /** Removes all claims on an event */\n    clearClaim(event) {\n        this.claims.delete(event);\n    }\n    *iterateAuthors(authors) {\n        for (const author of authors) {\n            const events = this.authors.get(author);\n            if (events) {\n                for (const event of events)\n                    yield event;\n            }\n        }\n    }\n    *iterateTag(tag, values) {\n        for (const value of values) {\n            const events = this.getTagIndex(tag + \":\" + value);\n            if (events) {\n                for (const event of events)\n                    yield event;\n            }\n        }\n    }\n    *iterateKinds(kinds) {\n        for (const kind of kinds) {\n            const events = this.kinds.get(kind);\n            if (events) {\n                for (const event of events)\n                    yield event;\n            }\n        }\n    }\n    *iterateTime(since, until) {\n        let untilIndex = 0;\n        let sinceIndex = this.created_at.length - 1;\n        let start = until\n            ? binarySearch(this.created_at, (mid) => {\n                if (mid.created_at === until)\n                    return -1;\n                return mid.created_at - until;\n            })\n            : undefined;\n        if (start && start[1])\n            untilIndex = start[0];\n        const end = since\n            ? binarySearch(this.created_at, (mid) => {\n                if (mid.created_at === since)\n                    return 1;\n                return since - mid.created_at;\n            })\n            : undefined;\n        if (end && end[1])\n            sinceIndex = end[0];\n        const events = new Set();\n        for (let i = untilIndex; i <= sinceIndex; i++) {\n            events.add(this.created_at[i]);\n        }\n        return events;\n    }\n    *iterateIds(ids) {\n        for (const id of ids) {\n            if (this.events.has(id))\n                yield this.events.get(id);\n        }\n    }\n    /** Returns all events that match the filter */\n    getEventsForFilter(filter) {\n        // search is not supported, return an empty set\n        if (filter.search)\n            return new Set();\n        let first = true;\n        let events = new Set();\n        const and = (iterable) => {\n            const set = iterable instanceof Set ? iterable : new Set(iterable);\n            if (first) {\n                events = set;\n                first = false;\n            }\n            else {\n                for (const event of events) {\n                    if (!set.has(event))\n                        events.delete(event);\n                }\n            }\n            return events;\n        };\n        if (filter.ids)\n            and(this.iterateIds(filter.ids));\n        let time = null;\n        // query for time first if since is set\n        if (filter.since !== undefined) {\n            time = Array.from(this.iterateTime(filter.since, filter.until));\n            and(time);\n        }\n        for (const t of INDEXABLE_TAGS) {\n            const key = `#${t}`;\n            const values = filter[key];\n            if (values?.length)\n                and(this.iterateTag(t, values));\n        }\n        if (filter.authors)\n            and(this.iterateAuthors(filter.authors));\n        if (filter.kinds)\n            and(this.iterateKinds(filter.kinds));\n        // query for time last if only until is set\n        if (filter.since === undefined && filter.until !== undefined) {\n            time = Array.from(this.iterateTime(filter.since, filter.until));\n            and(time);\n        }\n        // if the filter queried on time and has a limit. truncate the events now\n        if (filter.limit && time) {\n            const limited = new Set();\n            for (const event of time) {\n                if (limited.size >= filter.limit)\n                    break;\n                if (events.has(event))\n                    limited.add(event);\n            }\n            return limited;\n        }\n        return events;\n    }\n    getForFilters(filters) {\n        if (filters.length === 0)\n            throw new Error(\"No Filters\");\n        let events = new Set();\n        for (const filter of filters) {\n            const filtered = this.getEventsForFilter(filter);\n            for (const event of filtered)\n                events.add(event);\n        }\n        return events;\n    }\n    /** Remove the oldest events that are not claimed */\n    prune(limit = 1000) {\n        let removed = 0;\n        let cursor = this.events.first;\n        while (cursor) {\n            const event = cursor.value;\n            if (!this.isClaimed(event)) {\n                this.deleteEvent(event);\n                removed++;\n                if (removed >= limit)\n                    break;\n            }\n            cursor = cursor.next;\n        }\n        return removed;\n    }\n}\n", "import debug from \"debug\";\nexport const logger = debug(\"applesauce\");\n", "import { stateful } from \"../observable/stateful.js\";\nimport { LRU } from \"../helpers/lru.js\";\nimport * as Queries from \"../queries/index.js\";\nexport class QueryStore {\n    static Queries = Queries;\n    store;\n    constructor(store) {\n        this.store = store;\n    }\n    queries = new LRU();\n    /** Creates a cached query */\n    runQuery(queryConstructor) {\n        return (...args) => {\n            const query = queryConstructor(...args);\n            const key = `${queryConstructor.name}|${query.key}`;\n            if (!this.queries.has(key)) {\n                const observable = stateful(query.run(this.store, this));\n                this.queries.set(key, observable);\n                return observable;\n            }\n            return this.queries.get(key);\n        };\n    }\n    /** Returns a single event */\n    event(id) {\n        return this.runQuery(Queries.SingleEventQuery)(id);\n    }\n    /** Returns a single event */\n    events(ids) {\n        return this.runQuery(Queries.MultipleEventsQuery)(ids);\n    }\n    /** Returns the latest version of a replaceable event */\n    replaceable(kind, pubkey, d) {\n        return this.runQuery(Queries.ReplaceableQuery)(kind, pubkey, d);\n    }\n    /** Returns a directory of events by their UID */\n    replaceableSet(pointers) {\n        return this.runQuery(Queries.ReplaceableSetQuery)(pointers);\n    }\n    /** Returns an array of events that match the filter */\n    timeline(filters) {\n        return this.runQuery(Queries.TimelineQuery)(filters);\n    }\n    /** Returns the parsed profile (0) for a pubkey */\n    profile(pubkey) {\n        return this.runQuery(Queries.ProfileQuery)(pubkey);\n    }\n    /** Returns all reactions for an event (supports replaceable events) */\n    reactions(event) {\n        return this.runQuery(Queries.ReactionsQuery)(event);\n    }\n    /** Returns the parsed relay list (10002) for the pubkey */\n    mailboxes(pubkey) {\n        return this.runQuery(Queries.MailboxesQuery)(pubkey);\n    }\n    thread(root) {\n        return this.runQuery(Queries.ThreadQuery)(root);\n    }\n}\nexport { Queries };\n"],
  "mappings": "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",
  "names": ["Observable", "value", "require_zen_observable", "Observable", "PushStream", "debug", "PushStream", "Observable"]
}
