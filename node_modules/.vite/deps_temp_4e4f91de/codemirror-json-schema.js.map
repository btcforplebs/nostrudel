{
  "version": 3,
  "sources": ["../../.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js", "../../.pnpm/@sagold+json-pointer@5.1.2/node_modules/@sagold/json-pointer/dist/jsonPointer.js", "../../.pnpm/ebnf@1.9.1/node_modules/ebnf/dist/TokenError.js", "../../.pnpm/ebnf@1.9.1/node_modules/ebnf/dist/Parser.js", "../../.pnpm/ebnf@1.9.1/node_modules/ebnf/dist/Grammars/W3CEBNF.js", "../../.pnpm/valid-url@1.0.9/node_modules/valid-url/index.js", "../../.pnpm/nearley@2.20.1/node_modules/nearley/lib/nearley.js", "../../.pnpm/smtp-address-parser@1.0.10/node_modules/smtp-address-parser/lib/grammar.ts", "../../.pnpm/smtp-address-parser@1.0.10/node_modules/smtp-address-parser/lib/index.ts", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/debug.js", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/constants.js", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/node.js", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/state.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/config/strings.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/getTypeOf.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/render.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/__.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/createCustomError.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/flattenArray.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/config/settings.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/schema/createOneOfSchemaResult.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/types.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/filter.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/features/oneOf.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/merge.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/mergeSchema.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/omit.js", "../../.pnpm/fast-copy@3.0.2/src/utils.ts", "../../.pnpm/fast-copy@3.0.2/src/copier.ts", "../../.pnpm/fast-copy@3.0.2/src/index.ts", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/copy.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/features/if.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/features/allOf.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/resolveRef.strict.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/resolveRef.merge.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/uniqueItems.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/isObject.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/features/dependencies.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/features/anyOf.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/resolveDynamicSchema.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/reduceSchema.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft/index.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/addRemoteSchema.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/eachSchema.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/schema/getTypeDefs.js", "../../.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/parser/index.js", "../../.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/parser/jsonQueryGrammar.js", "../../.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/interpreter/keys.js", "../../.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/interpreter/nodes.js", "../../.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/interpreter/index.js", "../../.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/get.js", "../../.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/split.js", "../../.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/set.js", "../../.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/remove.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/schema/types.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/schema/getTypeId.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/compile/joinScope.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/compile/getRef.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/compile/splitRef.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/compile/index.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/compileSchema.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/each.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/validation/errors.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/validation/format.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/getSchema.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/isEmpty.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/getTemplate.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/isValid.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/punycode.ucs2decode.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/getPrecision.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/validation/keyword.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/createSchemaOf.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/step.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/getChildSchemaSelection.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/validation/type.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/validate.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft04/index.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft06/compile/index.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft06/validation/keyword.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft06/validation/type.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft06/index.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft07/index.js", "../../.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/jsoneditor/index.js", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/jsonPointers.js", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/json-completion.js", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/formatting.js", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/parseJSONDocument.js", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/dom.js", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/json-validation.js", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/json-hover.js", "../../.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/bundled.js"],
  "sourcesContent": ["'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n", "!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"jsonPointer\",[],t):\"object\"==typeof exports?exports.jsonPointer=t():e.jsonPointer=t()}(\"undefined\"!=typeof self?self:this,(()=>(()=>{\"use strict\";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},t={};function n(e){return\"#\"===e||\"\"===e||Array.isArray(e)&&0===e.length||!1}e.r(t),e.d(t,{default:()=>S,get:()=>c,isRoot:()=>n,join:()=>_,remove:()=>j,removeUndefinedItems:()=>v,set:()=>y,split:()=>s,splitLast:()=>x});const r=/~1/g,o=/~0/g,i=/\\/+/g,l=/(^[#/]*|\\/+$)/g;function u(e){return e.replace(r,\"/\").replace(o,\"~\")}function f(e){return u(decodeURIComponent(e))}function s(e){if(null==e||\"string\"!=typeof e||n(e))return Array.isArray(e)?e:[];const t=e.indexOf(\"#\")>=0?f:u,r=(e=(e=e.replace(i,\"/\")).replace(l,\"\")).split(\"/\");for(let e=0,n=r.length;e<n;e+=1)r[e]=t(r[e]);return r}function c(e,t,r=void 0){if(null==t||null==e)return r;if(n(t))return e;const o=p(e,s(t));return void 0===o?r:o}function p(e,t){const n=t.shift();if(void 0!==e)return void 0!==n?p(e[n],t):e}const a=/^\\[.*\\]$/,d=/^\\[(.+)\\]$/;function g(e,t){return\"__proto__\"===e||\"constructor\"==e&&t.length>0&&\"prototype\"==t[0]}function y(e,t,n){if(null==t)return e;const r=s(t);if(0===r.length)return e;null==e&&(e=a.test(r[0])?[]:{});let o,i,l=e;for(;r.length>1;)o=r.shift(),i=a.test(r[0]),g(o,r)||(l=m(l,o,i));return o=r.pop(),h(l,o,n),e}function h(e,t,n){let r;const o=t.match(d);\"[]\"===t&&Array.isArray(e)?e.push(n):o?(r=o.pop(),e[r]=n):e[t]=n}function m(e,t,n){if(null!=e[t])return e[t];const r=n?[]:{};return h(e,t,r),r}function v(e){let t=0,n=0;for(;t+n<e.length;)void 0===e[t+n]&&(n+=1),e[t]=e[t+n],t+=1;return e.length=e.length-n,e}function j(e,t,n){const r=s(t),o=r.pop(),i=c(e,r);return i&&delete i[o],Array.isArray(i)&&!0!==n&&v(i),e}const b=/\\/+/g,A=/~/g,P=/\\//g;function O(e,t){if(0===e.length)return t?\"#\":\"\";for(let n=0,r=e.length;n<r;n+=1)e[n]=e[n].replace(A,\"~0\").replace(P,\"~1\"),t&&(e[n]=encodeURIComponent(e[n]));return((t?\"#/\":\"/\")+e.join(\"/\")).replace(b,\"/\")}function _(e,...t){const n=[];if(Array.isArray(e))return O(e,!0===arguments[1]);const r=arguments[arguments.length-1],o=\"boolean\"==typeof r?r:e&&\"#\"===e[0];for(let e=0,t=arguments.length;e<t;e+=1)n.push.apply(n,s(arguments[e]));const i=[];for(let e=0,t=n.length;e<t;e+=1)if(\"..\"===n[e]){if(0===i.length)return o?\"#\":\"\";i.pop()}else i.push(n[e]);return O(i,o)}function x(e){const t=s(e);if(0===t.length)return\"string\"==typeof e&&\"#\"===e[0]?[\"#\",t[0]]:[\"\",void 0];if(1===t.length)return\"#\"===e[0]?[\"#\",t[0]]:[\"\",t[0]];const n=t.pop();return[_(t,\"#\"===e[0]),n]}const S={get:c,set:y,remove:j,join:_,split:s,splitLast:x,isRoot:n,removeUndefinedItems:v};return t})()));", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TokenError = void 0;\nclass TokenError extends Error {\n    constructor(message, token) {\n        super(message);\n        this.message = message;\n        this.token = token;\n        if (token && token.errors)\n            token.errors.push(this);\n        else\n            throw this;\n    }\n    inspect() {\n        return 'SyntaxError: ' + this.message;\n    }\n}\nexports.TokenError = TokenError;\n//# sourceMappingURL=TokenError.js.map", "\"use strict\";\n// https://www.ics.uci.edu/~pattis/ICS-33/lectures/ebnf.pdf\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = exports.findRuleByName = exports.parseRuleName = exports.escapeRegExp = exports.readToken = void 0;\nconst UPPER_SNAKE_RE = /^[A-Z0-9_]+$/;\nconst decorationRE = /(\\?|\\+|\\*)$/;\nconst preDecorationRE = /^(@|&|!)/;\nconst WS_RULE = 'WS';\nconst TokenError_1 = require(\"./TokenError\");\nfunction readToken(txt, expr) {\n    let result = expr.exec(txt);\n    if (result && result.index == 0) {\n        if (result[0].length == 0 && expr.source.length > 0)\n            return null;\n        return {\n            type: null,\n            text: result[0],\n            rest: txt.substr(result[0].length),\n            start: 0,\n            end: result[0].length - 1,\n            fullText: result[0],\n            errors: [],\n            children: [],\n            parent: null\n        };\n    }\n    return null;\n}\nexports.readToken = readToken;\nfunction escapeRegExp(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\nexports.escapeRegExp = escapeRegExp;\nfunction fixRest(token) {\n    token.rest = '';\n    token.children && token.children.forEach(c => fixRest(c));\n}\nfunction fixPositions(token, start) {\n    token.start += start;\n    token.end += start;\n    token.children && token.children.forEach(c => fixPositions(c, token.start));\n}\nfunction agregateErrors(errors, token) {\n    if (token.errors && token.errors.length)\n        token.errors.forEach(err => errors.push(err));\n    token.children && token.children.forEach(tok => agregateErrors(errors, tok));\n}\nfunction parseRuleName(name) {\n    let postDecoration = decorationRE.exec(name);\n    let preDecoration = preDecorationRE.exec(name);\n    let postDecorationText = (postDecoration && postDecoration[0]) || '';\n    let preDecorationText = (preDecoration && preDecoration[0]) || '';\n    let out = {\n        raw: name,\n        name: name.replace(decorationRE, '').replace(preDecorationRE, ''),\n        isOptional: postDecorationText == '?' || postDecorationText == '*',\n        allowRepetition: postDecorationText == '+' || postDecorationText == '*',\n        atLeastOne: postDecorationText == '+',\n        lookupPositive: preDecorationText == '&',\n        lookupNegative: preDecorationText == '!',\n        pinned: preDecorationText == '@',\n        lookup: false,\n        isLiteral: false\n    };\n    out.isLiteral = out.name[0] == \"'\" || out.name[0] == '\"';\n    out.lookup = out.lookupNegative || out.lookupPositive;\n    return out;\n}\nexports.parseRuleName = parseRuleName;\nfunction findRuleByName(name, parser) {\n    let parsed = parseRuleName(name);\n    return parser.cachedRules[parsed.name] || null;\n}\nexports.findRuleByName = findRuleByName;\n/// Removes all the nodes starting with 'RULE_'\nfunction stripRules(token, re) {\n    if (token.children) {\n        let localRules = token.children.filter(x => x.type && re.test(x.type));\n        for (let i = 0; i < localRules.length; i++) {\n            let indexOnChildren = token.children.indexOf(localRules[i]);\n            if (indexOnChildren != -1) {\n                token.children.splice(indexOnChildren, 1);\n            }\n        }\n        token.children.forEach(c => stripRules(c, re));\n    }\n}\nconst ignoreMissingRules = ['EOF'];\nclass Parser {\n    constructor(grammarRules, options) {\n        this.grammarRules = grammarRules;\n        this.options = options;\n        this.cachedRules = {};\n        this.debug = options ? options.debug === true : false;\n        let errors = [];\n        let neededRules = [];\n        grammarRules.forEach(rule => {\n            let parsedName = parseRuleName(rule.name);\n            if (parsedName.name in this.cachedRules) {\n                errors.push('Duplicated rule ' + parsedName.name);\n                return;\n            }\n            else {\n                this.cachedRules[parsedName.name] = rule;\n            }\n            if (!rule.bnf || !rule.bnf.length) {\n                let error = 'Missing rule content, rule: ' + rule.name;\n                if (errors.indexOf(error) == -1)\n                    errors.push(error);\n            }\n            else {\n                rule.bnf.forEach(options => {\n                    if (typeof options[0] === 'string') {\n                        let parsed = parseRuleName(options[0]);\n                        if (parsed.name == rule.name) {\n                            let error = 'Left recursion is not allowed, rule: ' + rule.name;\n                            if (errors.indexOf(error) == -1)\n                                errors.push(error);\n                        }\n                    }\n                    options.forEach(option => {\n                        if (typeof option == 'string') {\n                            let name = parseRuleName(option);\n                            if (!name.isLiteral &&\n                                neededRules.indexOf(name.name) == -1 &&\n                                ignoreMissingRules.indexOf(name.name) == -1)\n                                neededRules.push(name.name);\n                        }\n                    });\n                });\n            }\n            if (WS_RULE == rule.name)\n                rule.implicitWs = false;\n            if (rule.implicitWs) {\n                if (neededRules.indexOf(WS_RULE) == -1)\n                    neededRules.push(WS_RULE);\n            }\n            if (rule.recover) {\n                if (neededRules.indexOf(rule.recover) == -1)\n                    neededRules.push(rule.recover);\n            }\n        });\n        neededRules.forEach(ruleName => {\n            if (!(ruleName in this.cachedRules)) {\n                errors.push('Missing rule ' + ruleName);\n            }\n        });\n        if (errors.length)\n            throw new Error(errors.join('\\n'));\n    }\n    getAST(txt, target) {\n        if (!target) {\n            target = this.grammarRules.filter(x => !x.fragment && x.name.indexOf('%') != 0)[0].name;\n        }\n        let result = this.parse(txt, target);\n        if (result) {\n            agregateErrors(result.errors, result);\n            fixPositions(result, 0);\n            // REMOVE ALL THE TAGS MATCHING /^%/\n            stripRules(result, /^%/);\n            if (!this.options || !this.options.keepUpperRules)\n                stripRules(result, UPPER_SNAKE_RE);\n            let rest = result.rest;\n            if (rest) {\n                new TokenError_1.TokenError('Unexpected end of input: \\n' + rest, result);\n            }\n            fixRest(result);\n            result.rest = rest;\n        }\n        return result;\n    }\n    emitSource() {\n        return 'CANNOT EMIT SOURCE FROM BASE Parser';\n    }\n    parse(txt, target, recursion = 0) {\n        let out = null;\n        let type = parseRuleName(target);\n        let expr;\n        let printable = this.debug && /*!isLiteral &*/ !UPPER_SNAKE_RE.test(type.name);\n        printable &&\n            console.log(new Array(recursion).join('│  ') + 'Trying to get ' + target + ' from ' + JSON.stringify(txt.split('\\n')[0]));\n        let realType = type.name;\n        let targetLex = findRuleByName(type.name, this);\n        if (type.name == 'EOF') {\n            if (txt.length) {\n                return null;\n            }\n            else if (txt.length == 0) {\n                return {\n                    type: 'EOF',\n                    text: '',\n                    rest: '',\n                    start: 0,\n                    end: 0,\n                    fullText: '',\n                    errors: [],\n                    children: [],\n                    parent: null\n                };\n            }\n        }\n        try {\n            if (!targetLex && type.isLiteral) {\n                let src = type.name.trim();\n                if (src.startsWith('\"')) {\n                    src = JSON.parse(src);\n                }\n                else if (src.startsWith(\"'\")) {\n                    src = src.replace(/^'(.+)'$/, '$1').replace(/\\\\'/g, \"'\");\n                }\n                if (src === '') {\n                    return {\n                        type: '%%EMPTY%%',\n                        text: '',\n                        rest: txt,\n                        start: 0,\n                        end: 0,\n                        fullText: '',\n                        errors: [],\n                        children: [],\n                        parent: null\n                    };\n                }\n                expr = new RegExp(escapeRegExp(src));\n                realType = null;\n            }\n        }\n        catch (e) {\n            if (e instanceof ReferenceError) {\n                console.error(e);\n            }\n            return null;\n        }\n        if (expr) {\n            let result = readToken(txt, expr);\n            if (result) {\n                result.type = realType;\n                return result;\n            }\n        }\n        else {\n            let options = targetLex.bnf;\n            if (options instanceof Array) {\n                options.forEach(phases => {\n                    if (out)\n                        return;\n                    let pinned = null;\n                    let tmp = {\n                        type: type.name,\n                        text: '',\n                        children: [],\n                        end: 0,\n                        errors: [],\n                        fullText: '',\n                        parent: null,\n                        start: 0,\n                        rest: txt\n                    };\n                    if (targetLex.fragment)\n                        tmp.fragment = true;\n                    let tmpTxt = txt;\n                    let position = 0;\n                    let allOptional = phases.length > 0;\n                    let foundSomething = false;\n                    for (let i = 0; i < phases.length; i++) {\n                        if (typeof phases[i] == 'string') {\n                            let localTarget = parseRuleName(phases[i]);\n                            allOptional = allOptional && localTarget.isOptional;\n                            let got;\n                            let foundAtLeastOne = false;\n                            do {\n                                got = null;\n                                if (targetLex.implicitWs) {\n                                    got = this.parse(tmpTxt, localTarget.name, recursion + 1);\n                                    if (!got) {\n                                        let WS;\n                                        do {\n                                            WS = this.parse(tmpTxt, WS_RULE, recursion + 1);\n                                            if (WS) {\n                                                tmp.text = tmp.text + WS.text;\n                                                tmp.end = tmp.text.length;\n                                                WS.parent = tmp;\n                                                tmp.children.push(WS);\n                                                tmpTxt = tmpTxt.substr(WS.text.length);\n                                                position += WS.text.length;\n                                            }\n                                            else {\n                                                break;\n                                            }\n                                        } while (WS && WS.text.length);\n                                    }\n                                }\n                                got = got || this.parse(tmpTxt, localTarget.name, recursion + 1);\n                                // rule ::= \"true\" ![a-zA-Z]\n                                // negative lookup, if it does not match, we should continue\n                                if (localTarget.lookupNegative) {\n                                    if (got)\n                                        return /* cancel this path */;\n                                    break;\n                                }\n                                if (localTarget.lookupPositive) {\n                                    if (!got)\n                                        return;\n                                }\n                                if (!got) {\n                                    if (localTarget.isOptional)\n                                        break;\n                                    if (localTarget.atLeastOne && foundAtLeastOne)\n                                        break;\n                                }\n                                if (got && targetLex.pinned == i + 1) {\n                                    pinned = got;\n                                    printable && console.log(new Array(recursion + 1).join('│  ') + '└─ ' + got.type + ' PINNED');\n                                }\n                                if (!got)\n                                    got = this.parseRecovery(targetLex, tmpTxt, recursion + 1);\n                                if (!got) {\n                                    if (pinned) {\n                                        out = tmp;\n                                        got = {\n                                            type: 'SyntaxError',\n                                            text: tmpTxt,\n                                            children: [],\n                                            end: tmpTxt.length,\n                                            errors: [],\n                                            fullText: '',\n                                            parent: null,\n                                            start: 0,\n                                            rest: ''\n                                        };\n                                        if (tmpTxt.length) {\n                                            new TokenError_1.TokenError(`Unexpected end of input. Expecting ${localTarget.name} Got: ${tmpTxt}`, got);\n                                        }\n                                        else {\n                                            new TokenError_1.TokenError(`Unexpected end of input. Missing ${localTarget.name}`, got);\n                                        }\n                                        printable &&\n                                            console.log(new Array(recursion + 1).join('│  ') + '└─ ' + got.type + ' ' + JSON.stringify(got.text));\n                                    }\n                                    else {\n                                        return;\n                                    }\n                                }\n                                foundAtLeastOne = true;\n                                foundSomething = true;\n                                if (got.type == '%%EMPTY%%') {\n                                    break;\n                                }\n                                got.start += position;\n                                got.end += position;\n                                if (!localTarget.lookupPositive && got.type) {\n                                    if (got.fragment) {\n                                        got.children &&\n                                            got.children.forEach(x => {\n                                                x.start += position;\n                                                x.end += position;\n                                                x.parent = tmp;\n                                                tmp.children.push(x);\n                                            });\n                                    }\n                                    else {\n                                        got.parent = tmp;\n                                        tmp.children.push(got);\n                                    }\n                                }\n                                if (localTarget.lookup)\n                                    got.lookup = true;\n                                printable &&\n                                    console.log(new Array(recursion + 1).join('│  ') + '└─ ' + got.type + ' ' + JSON.stringify(got.text));\n                                // Eat it from the input stream, only if it is not a lookup\n                                if (!localTarget.lookup && !got.lookup) {\n                                    tmp.text = tmp.text + got.text;\n                                    tmp.end = tmp.text.length;\n                                    tmpTxt = tmpTxt.substr(got.text.length);\n                                    position += got.text.length;\n                                }\n                                tmp.rest = tmpTxt;\n                            } while (got && localTarget.allowRepetition && tmpTxt.length && !got.lookup);\n                        } /* IS A REGEXP */\n                        else {\n                            let got = readToken(tmpTxt, phases[i]);\n                            if (!got) {\n                                return;\n                            }\n                            printable &&\n                                console.log(new Array(recursion + 1).join('│  ') + '└> ' + JSON.stringify(got.text) + phases[i].source);\n                            foundSomething = true;\n                            got.start += position;\n                            got.end += position;\n                            tmp.text = tmp.text + got.text;\n                            tmp.end = tmp.text.length;\n                            tmpTxt = tmpTxt.substr(got.text.length);\n                            position += got.text.length;\n                            tmp.rest = tmpTxt;\n                        }\n                    }\n                    if (foundSomething) {\n                        out = tmp;\n                        printable &&\n                            console.log(new Array(recursion).join('│  ') + '├<─┴< PUSHING ' + out.type + ' ' + JSON.stringify(out.text));\n                    }\n                });\n            }\n            if (out && targetLex.simplifyWhenOneChildren && out.children.length == 1) {\n                out = out.children[0];\n            }\n        }\n        if (!out) {\n            printable && console.log(target + ' NOT RESOLVED FROM ' + txt);\n        }\n        return out;\n    }\n    parseRecovery(recoverableToken, tmpTxt, recursion) {\n        if (recoverableToken.recover && tmpTxt.length) {\n            let printable = this.debug;\n            printable &&\n                console.log(new Array(recursion + 1).join('│  ') +\n                    'Trying to recover until token ' +\n                    recoverableToken.recover +\n                    ' from ' +\n                    JSON.stringify(tmpTxt.split('\\n')[0] + tmpTxt.split('\\n')[1]));\n            let tmp = {\n                type: 'SyntaxError',\n                text: '',\n                children: [],\n                end: 0,\n                errors: [],\n                fullText: '',\n                parent: null,\n                start: 0,\n                rest: ''\n            };\n            let got;\n            do {\n                got = this.parse(tmpTxt, recoverableToken.recover, recursion + 1);\n                if (got) {\n                    new TokenError_1.TokenError('Unexpected input: \"' + tmp.text + `\" Expecting: ${recoverableToken.name}`, tmp);\n                    break;\n                }\n                else {\n                    tmp.text = tmp.text + tmpTxt[0];\n                    tmp.end = tmp.text.length;\n                    tmpTxt = tmpTxt.substr(1);\n                }\n            } while (!got && tmpTxt.length > 0);\n            if (tmp.text.length > 0 && got) {\n                printable && console.log(new Array(recursion + 1).join('│  ') + 'Recovered text: ' + JSON.stringify(tmp.text));\n                return tmp;\n            }\n        }\n        return null;\n    }\n}\nexports.Parser = Parser;\nexports.default = Parser;\n//# sourceMappingURL=Parser.js.map", "\"use strict\";\n// https://www.w3.org/TR/REC-xml/#NT-Name\n// http://www.bottlecaps.de/rr/ui\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Grammar\t::=\tProduction*\n// Production\t::=\tNCName '::=' Choice\n// NCName\t::=\t[http://www.w3.org/TR/xml-names/#NT-NCName]\n// Choice\t::=\tSequenceOrDifference ( '|' SequenceOrDifference )*\n// SequenceOrDifference\t::=\t(Item ( '-' Item | Item* ))?\n// Item\t::=\tPrimary ( '?' | '*' | '+' )?\n// Primary\t::=\tNCName | StringLiteral | CharCode | CharClass | '(' Choice ')'\n// StringLiteral\t::=\t'\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n// CharCode\t::=\t'#x' [0-9a-fA-F]+\n// CharClass\t::=\t'[' '^'? ( RULE_Char | CharCode | CharRange | CharCodeRange )+ ']'\n// RULE_Char\t::=\t[http://www.w3.org/TR/xml#NT-RULE_Char]\n// CharRange\t::=\tRULE_Char '-' ( RULE_Char - ']' )\n// CharCodeRange\t::=\tCharCode '-' CharCode\n// RULE_WHITESPACE\t::=\tRULE_S | Comment\n// RULE_S\t::=\t#x9 | #xA | #xD | #x20\n// Comment\t::=\t'/*' ( [^*] | '*'+ [^*/] )* '*'* '*/'\nconst Parser_1 = require(\"../Parser\");\nvar BNF;\n(function (BNF) {\n    BNF.RULES = [\n        {\n            name: 'Grammar',\n            bnf: [['RULE_S*', '%Atomic*', 'EOF']]\n        },\n        {\n            name: '%Atomic',\n            bnf: [['Production', 'RULE_S*']],\n            fragment: true\n        },\n        {\n            name: 'Production',\n            bnf: [['NCName', 'RULE_S*', '\"::=\"', 'RULE_WHITESPACE*', 'Choice', 'RULE_WHITESPACE*', 'RULE_EOL+', 'RULE_S*']]\n        },\n        {\n            name: 'NCName',\n            bnf: [[/[a-zA-Z][a-zA-Z_0-9]*/]]\n        },\n        {\n            name: 'Choice',\n            bnf: [['SequenceOrDifference', '%_Choice_1*']],\n            fragment: true\n        },\n        {\n            name: '%_Choice_1',\n            bnf: [['RULE_WHITESPACE*', '\"|\"', 'RULE_WHITESPACE*', 'SequenceOrDifference']],\n            fragment: true\n        },\n        {\n            name: 'SequenceOrDifference',\n            bnf: [['Item', 'RULE_WHITESPACE*', '%_Item_1?']]\n        },\n        {\n            name: '%_Item_1',\n            bnf: [['Minus', 'Item'], ['Item*']],\n            fragment: true\n        },\n        {\n            name: 'Minus',\n            bnf: [['\"-\"']]\n        },\n        {\n            name: 'Item',\n            bnf: [['RULE_WHITESPACE*', '%Primary', 'PrimaryDecoration?']],\n            fragment: true\n        },\n        {\n            name: 'PrimaryDecoration',\n            bnf: [['\"?\"'], ['\"*\"'], ['\"+\"']]\n        },\n        {\n            name: 'DecorationName',\n            bnf: [['\"ebnf://\"', /[^\\x5D#]+/]]\n        },\n        {\n            name: '%Primary',\n            bnf: [['NCName'], ['StringLiteral'], ['CharCode'], ['CharClass'], ['SubItem']],\n            fragment: true\n        },\n        {\n            name: 'SubItem',\n            bnf: [['\"(\"', 'RULE_WHITESPACE*', 'Choice', 'RULE_WHITESPACE*', '\")\"']]\n        },\n        {\n            name: 'StringLiteral',\n            bnf: [[`'\"'`, /[^\"]*/, `'\"'`], [`\"'\"`, /[^']*/, `\"'\"`]],\n            pinned: 1\n        },\n        {\n            name: 'CharCode',\n            bnf: [['\"#x\"', /[0-9a-zA-Z]+/]]\n        },\n        {\n            name: 'CharClass',\n            bnf: [[\"'['\", \"'^'?\", '%RULE_CharClass_1+', '\"]\"']]\n        },\n        {\n            name: '%RULE_CharClass_1',\n            bnf: [['CharCodeRange'], ['CharRange'], ['CharCode'], ['RULE_Char']],\n            fragment: true\n        },\n        {\n            name: 'RULE_Char',\n            bnf: [[/\\x09/], [/\\x0A/], [/\\x0D/], [/[\\x20-\\x5c]/], [/[\\x5e-\\uD7FF]/], [/[\\uE000-\\uFFFD]/]]\n        },\n        {\n            name: 'CharRange',\n            bnf: [['RULE_Char', '\"-\"', 'RULE_Char']]\n        },\n        {\n            name: 'CharCodeRange',\n            bnf: [['CharCode', '\"-\"', 'CharCode']]\n        },\n        {\n            name: 'RULE_WHITESPACE',\n            bnf: [['%RULE_WHITESPACE_CHAR*'], ['Comment', 'RULE_WHITESPACE*']]\n        },\n        {\n            name: 'RULE_S',\n            bnf: [['RULE_WHITESPACE', 'RULE_S*'], ['RULE_EOL', 'RULE_S*']]\n        },\n        {\n            name: '%RULE_WHITESPACE_CHAR',\n            bnf: [[/\\x09/], [/\\x20/]],\n            fragment: true\n        },\n        {\n            name: 'Comment',\n            bnf: [['\"/*\"', '%RULE_Comment_Body*', '\"*/\"']]\n        },\n        {\n            name: '%RULE_Comment_Body',\n            bnf: [['!\"*/\"', /[^*]/]],\n            fragment: true\n        },\n        {\n            name: 'RULE_EOL',\n            bnf: [[/\\x0D/, /\\x0A/], [/\\x0A/], [/\\x0D/]]\n        },\n        {\n            name: 'Link',\n            bnf: [[\"'['\", 'Url', \"']'\"]]\n        },\n        {\n            name: 'Url',\n            bnf: [[/[^\\x5D:/?#]/, '\"://\"', /[^\\x5D#]+/, '%Url1?']]\n        },\n        {\n            name: '%Url1',\n            bnf: [['\"#\"', 'NCName']],\n            fragment: true\n        }\n    ];\n    BNF.defaultParser = new Parser_1.Parser(BNF.RULES, { debug: false });\n    const preDecorationRE = /^(!|&)/;\n    const decorationRE = /(\\?|\\+|\\*)$/;\n    const subExpressionRE = /^%/;\n    function getBNFRule(name, parser) {\n        if (typeof name == 'string') {\n            if (preDecorationRE.test(name))\n                return '';\n            let subexpression = subExpressionRE.test(name);\n            if (subexpression) {\n                let decoration = decorationRE.exec(name);\n                let decorationText = decoration ? decoration[0] + ' ' : '';\n                let lonely = isLonelyRule(name, parser);\n                if (lonely)\n                    return getBNFBody(name, parser) + decorationText;\n                return '(' + getBNFBody(name, parser) + ')' + decorationText;\n            }\n            return name;\n        }\n        else {\n            return name.source\n                .replace(/\\\\(?:x|u)([a-zA-Z0-9]+)/g, '#x$1')\n                .replace(/\\[\\\\(?:x|u)([a-zA-Z0-9]+)-\\\\(?:x|u)([a-zA-Z0-9]+)\\]/g, '[#x$1-#x$2]');\n        }\n    }\n    /// Returns true if the rule is a string literal or regular expression without a descendant tree\n    function isLonelyRule(name, parser) {\n        let rule = Parser_1.findRuleByName(name, parser);\n        return (rule &&\n            rule.bnf.length == 1 &&\n            rule.bnf[0].length == 1 &&\n            (rule.bnf[0][0] instanceof RegExp || rule.bnf[0][0][0] == '\"' || rule.bnf[0][0][0] == \"'\"));\n    }\n    function getBNFChoice(rules, parser) {\n        return rules.map(x => getBNFRule(x, parser)).join(' ');\n    }\n    function getBNFBody(name, parser) {\n        let rule = Parser_1.findRuleByName(name, parser);\n        if (rule)\n            return rule.bnf.map(x => getBNFChoice(x, parser)).join(' | ');\n        return 'RULE_NOT_FOUND {' + name + '}';\n    }\n    function emit(parser) {\n        let acumulator = [];\n        parser.grammarRules.forEach(l => {\n            if (!/^%/.test(l.name)) {\n                let recover = l.recover ? ' /* { recoverUntil=' + l.recover + ' } */' : '';\n                acumulator.push(l.name + ' ::= ' + getBNFBody(l.name, parser) + recover);\n            }\n        });\n        return acumulator.join('\\n');\n    }\n    BNF.emit = emit;\n    let subitems = 0;\n    function restar(total, resta) {\n        console.log('reberia restar ' + resta + ' a ' + total);\n        throw new Error('Difference not supported yet');\n    }\n    function convertRegex(txt) {\n        return new RegExp(txt\n            .replace(/#x([a-zA-Z0-9]{4})/g, '\\\\u$1')\n            .replace(/#x([a-zA-Z0-9]{3})/g, '\\\\u0$1')\n            .replace(/#x([a-zA-Z0-9]{2})/g, '\\\\x$1')\n            .replace(/#x([a-zA-Z0-9]{1})/g, '\\\\x0$1'));\n    }\n    function getSubItems(tmpRules, seq, parentName) {\n        let anterior = null;\n        let bnfSeq = [];\n        seq.children.forEach((x, i) => {\n            if (x.type == 'Minus') {\n                restar(anterior, x);\n            }\n            else {\n            }\n            let decoration = seq.children[i + 1];\n            decoration = (decoration && decoration.type == 'PrimaryDecoration' && decoration.text) || '';\n            let preDecoration = '';\n            switch (x.type) {\n                case 'SubItem':\n                    let name = '%' + (parentName + subitems++);\n                    createRule(tmpRules, x, name);\n                    bnfSeq.push(preDecoration + name + decoration);\n                    break;\n                case 'NCName':\n                case 'StringLiteral':\n                    bnfSeq.push(preDecoration + x.text + decoration);\n                    break;\n                case 'CharCode':\n                case 'CharClass':\n                    if (decoration || preDecoration) {\n                        let newRule = {\n                            name: '%' + (parentName + subitems++),\n                            bnf: [[convertRegex(x.text)]]\n                        };\n                        tmpRules.push(newRule);\n                        bnfSeq.push(preDecoration + newRule.name + decoration);\n                    }\n                    else {\n                        bnfSeq.push(convertRegex(x.text));\n                    }\n                    break;\n                case 'PrimaryDecoration':\n                    break;\n                default:\n                    throw new Error(' HOW SHOULD I PARSE THIS? ' + x.type + ' -> ' + JSON.stringify(x.text));\n            }\n            anterior = x;\n        });\n        return bnfSeq;\n    }\n    function createRule(tmpRules, token, name) {\n        let bnf = token.children.filter(x => x.type == 'SequenceOrDifference').map(s => getSubItems(tmpRules, s, name));\n        let rule = {\n            name,\n            bnf\n        };\n        let recover = null;\n        bnf.forEach(x => {\n            recover = recover || x['recover'];\n            delete x['recover'];\n        });\n        if (name.indexOf('%') == 0)\n            rule.fragment = true;\n        if (recover)\n            rule.recover = recover;\n        tmpRules.push(rule);\n    }\n    function getRules(source, parser = BNF.defaultParser) {\n        let ast = parser.getAST(source);\n        if (!ast)\n            throw new Error('Could not parse ' + source);\n        if (ast.errors && ast.errors.length) {\n            throw ast.errors[0];\n        }\n        let tmpRules = [];\n        ast.children.filter(x => x.type == 'Production').map((x) => {\n            let name = x.children.filter(x => x.type == 'NCName')[0].text;\n            createRule(tmpRules, x, name);\n        });\n        return tmpRules;\n    }\n    BNF.getRules = getRules;\n    function Transform(source, subParser = BNF.defaultParser) {\n        return getRules(source.join(''), subParser);\n    }\n    BNF.Transform = Transform;\n    class Parser extends Parser_1.Parser {\n        constructor(source, options) {\n            const subParser = options && options.debugRulesParser === true ? new Parser_1.Parser(BNF.RULES, { debug: true }) : BNF.defaultParser;\n            super(getRules(source, subParser), options);\n        }\n        emitSource() {\n            return emit(this);\n        }\n    }\n    BNF.Parser = Parser;\n})(BNF || (BNF = {}));\nexports.default = BNF;\n//# sourceMappingURL=W3CEBNF.js.map", "(function(module) {\n    'use strict';\n\n    module.exports.is_uri = is_iri;\n    module.exports.is_http_uri = is_http_iri;\n    module.exports.is_https_uri = is_https_iri;\n    module.exports.is_web_uri = is_web_iri;\n    // Create aliases\n    module.exports.isUri = is_iri;\n    module.exports.isHttpUri = is_http_iri;\n    module.exports.isHttpsUri = is_https_iri;\n    module.exports.isWebUri = is_web_iri;\n\n\n    // private function\n    // internal URI spitter method - direct from RFC 3986\n    var splitUri = function(uri) {\n        var splitted = uri.match(/(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/);\n        return splitted;\n    };\n\n    function is_iri(value) {\n        if (!value) {\n            return;\n        }\n\n        // check for illegal characters\n        if (/[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i.test(value)) return;\n\n        // check for hex escapes that aren't complete\n        if (/%[^0-9a-f]/i.test(value)) return;\n        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        // scheme and path are required, though the path can be empty\n        if (!(scheme && scheme.length && path.length >= 0)) return;\n\n        // if authority is present, the path must be empty or begin with a /\n        if (authority && authority.length) {\n            if (!(path.length === 0 || /^\\//.test(path))) return;\n        } else {\n            // if authority is not present, the path must not start with //\n            if (/^\\/\\//.test(path)) return;\n        }\n\n        // scheme must begin with a letter, then consist of letters, digits, +, ., or -\n        if (!/^[a-z][a-z0-9\\+\\-\\.]*$/.test(scheme.toLowerCase()))  return;\n\n        // re-assemble the URL per section 5.3 in RFC 3986\n        out += scheme + ':';\n        if (authority && authority.length) {\n            out += '//' + authority;\n        }\n\n        out += path;\n\n        if (query && query.length) {\n            out += '?' + query;\n        }\n\n        if (fragment && fragment.length) {\n            out += '#' + fragment;\n        }\n\n        return out;\n    }\n\n    function is_http_iri(value, allowHttps) {\n        if (!is_iri(value)) {\n            return;\n        }\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var port = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        if (!scheme)  return;\n\n        if(allowHttps) {\n            if (scheme.toLowerCase() != 'https') return;\n        } else {\n            if (scheme.toLowerCase() != 'http') return;\n        }\n\n        // fully-qualified URIs must have an authority section that is\n        // a valid host\n        if (!authority) {\n            return;\n        }\n\n        // enable port component\n        if (/:(\\d+)$/.test(authority)) {\n            port = authority.match(/:(\\d+)$/)[0];\n            authority = authority.replace(/:\\d+$/, '');\n        }\n\n        out += scheme + ':';\n        out += '//' + authority;\n        \n        if (port) {\n            out += port;\n        }\n        \n        out += path;\n        \n        if(query && query.length){\n            out += '?' + query;\n        }\n\n        if(fragment && fragment.length){\n            out += '#' + fragment;\n        }\n        \n        return out;\n    }\n\n    function is_https_iri(value) {\n        return is_http_iri(value, true);\n    }\n\n    function is_web_iri(value) {\n        return (is_http_iri(value) || is_https_iri(value));\n    }\n\n})(module);\n", "(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(getSymbolShortDisplay).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(' ')\n                                 + \" ● \"\n                                 + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(' ')     );\n        return this.name + \" → \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n            // Having right set here will prevent the right state and its children\n            // form being garbage collected\n            state.right = undefined;\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var lines = buffer\n                .split(\"\\n\")\n                .slice(\n                    Math.max(0, this.line - 5), \n                    this.line\n                );\n\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var col = this.index - this.lastLineBreak;\n            var lastLineDigits = String(this.line).length;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += lines\n                .map(function(line, i) {\n                    return pad(this.line - lines.length + i + 1, lastLineDigits) + \" \" + line;\n                }, this)\n                .join(\"\\n\");\n            message += \"\\n\" + pad(\"\", lastLineDigits + col) + \"^\\n\";\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n\n        function pad(n, length) {\n            var s = String(n);\n            return Array(length - s.length + 1).join(\" \") + s;\n        }\n    }\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (true) {\n            try {\n                token = lexer.next();\n                if (!token) {\n                    break;\n                }\n            } catch (e) {\n                // Create the next column so that the error reporter\n                // can display the correctly predicted states.\n                var nextColumn = new Column(this.grammar, this.current + 1);\n                this.table.push(nextColumn);\n                var err = new Error(this.reportLexerError(e));\n                err.offset = this.current;\n                err.token = e.token;\n                throw err;\n            }\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.reportLexerError = function(lexerError) {\n        var tokenDisplay, lexerMessage;\n        // Planning to add a token property to moo's thrown error\n        // even on erroring tokens to be used in error display below\n        var token = lexerError.token;\n        if (token) {\n            tokenDisplay = \"input \" + JSON.stringify(token.text[0]) + \" (lexer error)\";\n            lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        } else {\n            tokenDisplay = \"input (lexer error)\";\n            lexerMessage = lexerError.message;\n        }\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var tokenDisplay = (token.type ? token.type + \" token: \" : \"\") + JSON.stringify(token.value !== undefined ? token.value : token);\n        var lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {\n        var lines = [];\n        lines.push(lexerMessage);\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== \"string\";\n            });\n\n        if (expectantStates.length === 0) {\n            lines.push('Unexpected ' + tokenDisplay + '. I did not expect any more input. Here is the state of my parse table:\\n');\n            this.displayStateStack(lastColumn.states, lines);\n        } else {\n            lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\\n');\n            // Display a \"state stack\" for each expectant state\n            // - which shows you how this state came to be, step by step.\n            // If there is more than one derivation, we only display the first one.\n            var stateStacks = expectantStates\n                .map(function(state) {\n                    return this.buildFirstStateStack(state, []) || [state];\n                }, this);\n            // Display each state that is expecting a terminal symbol next.\n            stateStacks.forEach(function(stateStack) {\n                var state = stateStack[0];\n                var nextSymbol = state.rule.symbols[state.dot];\n                var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n                lines.push('A ' + symbolDisplay + ' based on:');\n                this.displayStateStack(stateStack, lines);\n            }, this);\n        }\n        lines.push(\"\");\n        return lines.join(\"\\n\");\n    }\n    \n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push('    ^ ' + sameDisplayCount + ' more lines identical to this');\n                }\n                sameDisplayCount = 0;\n                lines.push('    ' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        return getSymbolLongDisplay(symbol);\n    };\n\n    /*\n    Builds a the first state stack. You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a\n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n\n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an single state stack.\n\n    */\n    Parser.prototype.buildFirstStateStack = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return null\n            // to eliminate this path from the results, because\n            // we don't know how to display it meaningfully\n            return null;\n        }\n        if (state.wantedBy.length === 0) {\n            return [state];\n        }\n        var prevState = state.wantedBy[0];\n        var childVisited = [state].concat(visited);\n        var childResult = this.buildFirstStateStack(prevState, childVisited);\n        if (childResult === null) {\n            return null;\n        }\n        return [state].concat(childResult);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    function getSymbolLongDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return 'character matching ' + symbol;\n            } else if (symbol.type) {\n                return symbol.type + ' token';\n            } else if (symbol.test) {\n                return 'token matching ' + String(symbol.test);\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    function getSymbolShortDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return symbol.toString();\n            } else if (symbol.type) {\n                return '%' + symbol.type;\n            } else if (symbol.test) {\n                return '<' + String(symbol.test) + '>';\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n", null, "\"use strict\";\n\n// const punycode = require('punycode');\nconst nearley = require(\"nearley\");\n\nimport { default as myGrammar } from \"./grammar\";\nmyGrammar.ParserStart = \"Mailbox\";\nconst grammar = nearley.Grammar.fromCompiled(myGrammar);\n\n// <https://tools.ietf.org/html/rfc5321#section-4.1.2>\n\nexport function parse(address: string) {\n    const parser = new nearley.Parser(grammar);\n    parser.feed(address);\n\n    if (parser.results.length !== 1) {\n        throw new Error(\"address parsing failed: ambiguous grammar\");\n    }\n\n    return parser.results[0];\n}\n\n/** Strip +something, strip '.'s, and map to lower case.\n */\nexport function normalize_dot_string(dot_string: string) {\n    const tagless = (function () {\n        const plus_loc = dot_string.indexOf(\"+\");\n        if (plus_loc === -1) {\n            return dot_string;\n        }\n        return dot_string.substr(0, plus_loc);\n    })();\n    const dotless = tagless.replace(/\\./g, \"\");\n    return dotless.toLowerCase();\n}\n\n/** The G style address normalization.\n */\nexport function normalize(address: string) {\n    const a = parse(address);\n    const domain = a.domainPart.AddressLiteral ?? a.domainPart.DomainName.toLowerCase();\n    const local = a.localPart.QuotedString ?? normalize_dot_string(a.localPart.DotString);\n    return `${local}@${domain}`;\n}\n\nexport function canonicalize_quoted_string(quoted_string: string) {\n    const unquoted = quoted_string.substr(1).substr(0, quoted_string.length - 2);\n    const unescaped = unquoted.replace(/(?:\\\\(.))/g, \"$1\");\n    const reescaped = unescaped.replace(/(?:([\"\\\\]))/g, \"\\\\$1\");\n    return `\"${reescaped}\"`; // re-quote\n}\n\n/**\n * Apply a canonicalization consistent with standards to support\n * comparison as a string.\n */\nexport function canonicalize(address: string) {\n    const a = parse(address);\n    const domain = a.domainPart.AddressLiteral ?? a.domainPart.DomainName.toLowerCase();\n    const local = a.localPart.QuotedString\n        ? canonicalize_quoted_string(a.localPart.QuotedString)\n        : a.localPart.DotString;\n    return `${local}@${domain}`;\n}\n", "export const debug = {\n    log: (...args) => {\n        if (\"production\" !== \"development\") {\n            return;\n        }\n        console.log(...args);\n    },\n};\n", "export const TOKENS = {\n    STRING: \"String\",\n    NUMBER: \"Number\",\n    TRUE: \"True\",\n    FALSE: \"False\",\n    NULL: \"Null\",\n    OBJECT: \"Object\",\n    ARRAY: \"Array\",\n    PROPERTY: \"Property\",\n    PROPERTY_NAME: \"PropertyName\",\n    PROPERTY_COLON: \"PropertyColon\",\n    JSON_TEXT: \"JsonText\",\n    INVALID: \"⚠\",\n};\nexport const PRIMITIVE_TYPES = [\n    TOKENS.STRING,\n    TOKENS.NUMBER,\n    TOKENS.TRUE,\n    TOKENS.FALSE,\n    TOKENS.NULL,\n];\nexport const COMPLEX_TYPES = [TOKENS.OBJECT, TOKENS.ARRAY];\n", "import { COMPLEX_TYPES, TOKENS, PRIMITIVE_TYPES } from \"../constants.js\";\nimport { syntaxTree } from \"@codemirror/language\";\nexport const getNodeAtPosition = (state, pos, side = -1) => {\n    return syntaxTree(state).resolveInner(pos, side);\n};\nexport const stripSurroundingQuotes = (str) => {\n    return str.replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n};\nexport const getWord = (doc, node, stripQuotes = true) => {\n    const word = node ? doc.sliceString(node.from, node.to) : \"\";\n    return stripQuotes ? stripSurroundingQuotes(word) : word;\n};\nexport const isInvalidValueNode = (node) => {\n    var _a, _b;\n    return (node.name === TOKENS.INVALID &&\n        (((_a = node.prevSibling) === null || _a === void 0 ? void 0 : _a.name) === TOKENS.PROPERTY_NAME ||\n            ((_b = node.prevSibling) === null || _b === void 0 ? void 0 : _b.name) === TOKENS.PROPERTY_COLON));\n};\nexport const isPrimitiveValueNode = (node) => {\n    return PRIMITIVE_TYPES.includes(node.name) || isInvalidValueNode(node);\n};\nexport const isValueNode = (node) => {\n    return ([...PRIMITIVE_TYPES, ...COMPLEX_TYPES].includes(node.name) ||\n        isInvalidValueNode(node));\n};\nexport const isPropertyNameNode = (node) => {\n    var _a, _b;\n    return (node.name === TOKENS.PROPERTY_NAME ||\n        (node.name === TOKENS.INVALID &&\n            (((_a = node.prevSibling) === null || _a === void 0 ? void 0 : _a.name) === TOKENS.PROPERTY ||\n                ((_b = node.prevSibling) === null || _b === void 0 ? void 0 : _b.name) === \"{\")));\n};\nconst getChildrenNodes = (node) => {\n    const children = [];\n    let child = node.firstChild;\n    while (child) {\n        if (child) {\n            children.push(child);\n        }\n        child = child === null || child === void 0 ? void 0 : child.nextSibling;\n    }\n    return children;\n};\nexport const getChildValueNode = (node) => {\n    return getChildrenNodes(node).find((n) => isPrimitiveValueNode(n));\n};\nconst getArrayNodeChildren = (node) => {\n    return getChildrenNodes(node).filter((n) => PRIMITIVE_TYPES.includes(n.name) || COMPLEX_TYPES.includes(n.name));\n};\nexport const findNodeIndexInArrayNode = (arrayNode, valueNode) => {\n    return getArrayNodeChildren(arrayNode).findIndex((nd) => nd.from === valueNode.from && nd.to === valueNode.to);\n};\n", "import { StateEffect, StateField } from \"@codemirror/state\";\nconst schemaEffect = StateEffect.define();\nexport const schemaStateField = StateField.define({\n    create() { },\n    update(schema, tr) {\n        for (const e of tr.effects) {\n            if (e.is(schemaEffect)) {\n                return e.value;\n            }\n        }\n        return schema;\n    },\n});\nexport const updateSchema = (view, schema) => {\n    view.dispatch({\n        effects: schemaEffect.of(schema),\n    });\n};\nexport const getJSONSchema = (state) => {\n    return state.field(schemaStateField);\n};\nexport const stateExtensions = (schema) => [\n    schemaStateField.init(() => schema),\n];\n", "/* eslint max-len: 0 */\nexport default {\n    // validation errors\n    AdditionalItemsError: \"Array at `{{pointer}}` may not have an additional item `{{key}}`\",\n    AdditionalPropertiesError: \"Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`\",\n    AllOfError: \"Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`\",\n    AnyOfError: \"Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`\",\n    ConstError: \"Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`\",\n    containsAnyError: \"The array at `{{pointer}}` must contain at least one item\",\n    ContainsArrayError: \"The property at `{{pointer}}` must not be an array\",\n    ContainsError: \"The array at `{{pointer}}` must contain an element that matches `{{schema}}`\",\n    EnumError: \"Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`\",\n    ForbiddenPropertyError: \"Property name `{{property}}` at `{{pointer}}` is not allowed\",\n    FormatDateError: \"Value `{{value}}` at `{{pointer}}` is not a valid date\",\n    FormatDateTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid date-time\",\n    FormatEmailError: \"Value `{{value}}` at `{{pointer}}` is not a valid email\",\n    FormatHostnameError: \"Value `{{value}}` at `{{pointer}}` is not a valid hostname\",\n    FormatIPV4Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address\",\n    FormatIPV4LeadingZeroError: \"IPv4 addresses starting with zero are invalid, since they are interpreted as octals\",\n    FormatIPV6Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address\",\n    FormatIPV6LeadingZeroError: \"IPv6 addresses starting with zero are invalid, since they are interpreted as octals\",\n    FormatJsonPointerError: \"Value `{{value}}` at `{{pointer}}` is not a valid json-pointer\",\n    FormatRegExError: \"Value `{{value}}` at `{{pointer}}` is not a valid regular expression\",\n    FormatTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid time\",\n    FormatURIError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri\",\n    FormatURIReferenceError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-reference\",\n    FormatURITemplateError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-template\",\n    FormatURLError: \"Value `{{value}}` at `{{pointer}}` is not a valid url\",\n    InvalidDataError: \"No value may be specified in `{{pointer}}`\",\n    InvalidPropertyNameError: \"Invalid property name `{{property}}` at `{{pointer}}`\",\n    MaximumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum\",\n    MaxItemsError: \"Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\n    MaxLengthError: \"Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.\",\n    MaxPropertiesError: \"Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\n    MinimumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum\",\n    MinItemsError: \"Too few items in `{{pointer}}`, should be at least `{{minItems}}`, but got `{{length}}`\",\n    MinItemsOneError: \"At least one item is required in `{{pointer}}`\",\n    MinLengthError: \"Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.\",\n    MinLengthOneError: \"A value is required in `{{pointer}}`\",\n    MinPropertiesError: \"Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`\",\n    MissingDependencyError: \"The required propery '{{missingProperty}}' in `{{pointer}}` is missing\",\n    MissingOneOfPropertyError: \"Value at `{{pointer}}` property: `{{property}}`\",\n    MultipleOfError: \"Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`\",\n    MultipleOneOfError: \"Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`\",\n    NoAdditionalPropertiesError: \"Additional property `{{property}}` in `{{pointer}}` is not allowed\",\n    NotError: \"Value `{{value}}` at pointer should not match schema `{{not}}`\",\n    OneOfError: \"Value `{{value}}` in `{{pointer}}` does not match any given oneof schema\",\n    OneOfPropertyError: \"Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`\",\n    PatternError: \"Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`\",\n    PatternPropertiesError: \"Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}\",\n    RequiredPropertyError: \"The required property `{{key}}` is missing at `{{pointer}}`\",\n    SchemaWarning: \"Failed retrieving a schema from '{{pointer}}' to key '{{key}}'\",\n    TypeError: \"Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`\",\n    UndefinedValueError: \"Value must not be undefined in `{{pointer}}`\",\n    UniqueItemsError: \"Items in array must be unique. Value `{{value}}` in `{{pointer}}` is a duplicate of {{duplicatePointer}}.\",\n    UnknownPropertyError: \"Could not find a valid schema for property `{{pointer}}` within object\",\n    ValueNotEmptyError: \"A value for `{{property}}` is required at `{{pointer}}`\"\n};\n", "const toString = Object.prototype.toString;\nexport default function getTypeOf(value) {\n    const type = toString\n        .call(value)\n        .match(/\\s([^\\]]+)\\]/)\n        .pop()\n        .toLowerCase();\n    if (type === \"file\") {\n        return \"object\";\n    }\n    return type;\n}\n", "import getTypeOf from \"../getTypeOf\";\nconst OBJECT_TYPE = \"object\";\nconst ARRAY_TYPE = \"array\";\n/**\n * Renders data into a string by {{variables}}.\n * Given a template string, removes all {{property}} substrings and replaces them with the property in the given data\n *\n * @param template - template string containing variables in handelbars/mustache style\n * @param data - flat object containing properties matching variables\n * @return rendered string\n */\nexport default function render(template, data = {}) {\n    return template.replace(/\\{\\{\\w+\\}\\}/g, (match) => {\n        const key = match.replace(/[{}]/g, \"\");\n        const variable = data[key];\n        const variableType = getTypeOf(variable);\n        if (variableType === OBJECT_TYPE || variableType === ARRAY_TYPE) {\n            return JSON.stringify(variable);\n        }\n        return variable;\n    });\n}\n", "import strings from \"../config/strings\";\nimport render from \"./render\";\n/**\n * Renders the given string as defined in __@see config/strings.js__\n * @param keyword\n * @param data - template data\n * @param fallback - fallback template\n * @return resulting string\n */\nexport default function __(keyword, data, fallback = keyword) {\n    var _a;\n    const template = (_a = strings[keyword]) !== null && _a !== void 0 ? _a : fallback;\n    return render(template, data);\n}\n", "import __ from \"./__\";\nfunction dashCase(text) {\n    return text.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nexport function createError(name, data) {\n    return {\n        type: \"error\",\n        name,\n        code: dashCase(name),\n        message: __(name, data),\n        data\n    };\n}\n/**\n * Creates a custom Error Creator. Its messages are defined by strings-object @see config/strings.ts\n *\n * @param name - id of error (camelcased)\n * @return error constructor function\n */\nexport function createCustomError(name) {\n    return createError.bind(null, name);\n}\n", "export default function flattenArray(list, result = []) {\n    for (let i = 0; i < list.length; i += 1) {\n        const item = list[i];\n        if (Array.isArray(item)) {\n            flattenArray(item, result);\n        }\n        else {\n            result.push(item);\n        }\n    }\n    return result;\n}\n", "export default {\n    DECLARATOR_ONEOF: \"oneOfProperty\",\n    GET_TEMPLATE_RECURSION_LIMIT: 1,\n    propertyBlacklist: [\"_id\"],\n    templateDefaultOptions: {\n        addOptionalProps: false,\n        removeInvalidData: false,\n        extendDefaults: true\n    }\n};\n", "export function createOneOfSchemaResult(schema, oneOfSchema, oneOfIndex) {\n    const childSchema = { ...oneOfSchema };\n    Object.defineProperty(childSchema, \"getOneOfOrigin\", {\n        enumerable: false,\n        value: () => ({\n            index: oneOfIndex,\n            schema\n        })\n    });\n    return childSchema;\n}\n", "/**\n * ts type guard for json error\n * @returns true if passed type is a JsonError\n */\nexport function isJsonError(error) {\n    return (error === null || error === void 0 ? void 0 : error.type) === \"error\";\n}\n", "import { isJsonError } from \"../types\";\nexport function isPromise(obj) {\n    return obj instanceof Promise;\n}\nexport function errorOrPromise(error) {\n    return isJsonError(error) || isPromise(error);\n}\nexport function errorsOnly(error) {\n    return isJsonError(error);\n}\n", "/**\n * @draft-04\n */\nimport flattenArray from \"../utils/flattenArray\";\nimport getTypeOf from \"../getTypeOf\";\nimport settings from \"../config/settings\";\nimport { createOneOfSchemaResult } from \"../schema/createOneOfSchemaResult\";\nimport { errorOrPromise } from \"../utils/filter\";\nimport { isJsonError } from \"../types\";\nconst { DECLARATOR_ONEOF } = settings;\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param draft - validator\n * @param data\n * @param schema - current json schema containing property oneOf\n * @param pointer - json pointer to data\n * @return oneOf schema or an error\n */\nexport function resolveOneOf(draft, data, schema = draft.rootSchema, pointer = \"#\") {\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return draft.errors.missingOneOfPropertyError({\n                property: oneOfProperty,\n                pointer,\n                schema,\n                value: data\n            });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = draft.resolveRef(schema.oneOf[i]);\n            const oneOfPropertySchema = draft.step(oneOfProperty, one, data, pointer);\n            if (isJsonError(oneOfPropertySchema)) {\n                return oneOfPropertySchema;\n            }\n            let result = flattenArray(draft.validate(oneOfValue, oneOfPropertySchema, pointer));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                return createOneOfSchemaResult(schema, one, i); // return resolved schema\n            }\n        }\n        return draft.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            schema,\n            errors\n        });\n    }\n    const matches = [];\n    const errors = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const one = draft.resolveRef(schema.oneOf[i]);\n        let result = flattenArray(draft.validate(data, one, pointer));\n        result = result.filter(errorOrPromise);\n        if (result.length > 0) {\n            errors.push(...result);\n        }\n        else {\n            matches.push({ index: i, schema: one });\n        }\n    }\n    if (matches.length === 1) {\n        return createOneOfSchemaResult(schema, matches[0].schema, matches[0].index); // return resolved schema\n    }\n    if (matches.length > 1) {\n        return draft.errors.multipleOneOfError({\n            value: data,\n            pointer,\n            schema,\n            matches\n        });\n    }\n    return draft.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        schema,\n        oneOf: schema.oneOf,\n        errors\n    });\n}\n/**\n * Returns a ranking for the data and given schema\n *\n * @param draft\n * @param - json schema type: object\n * @param data\n * @param [pointer]\n * @return ranking value (higher is better)\n */\nfunction fuzzyObjectValue(draft, one, data, pointer) {\n    if (data == null || one.properties == null) {\n        return -1;\n    }\n    let value = 0;\n    const keys = Object.keys(one.properties);\n    for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        if (data[key] != null && draft.isValid(data[key], one.properties[key], pointer)) {\n            value += 1;\n        }\n    }\n    return value;\n}\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param draft\n * @param data\n * @param [schema] - current json schema containing property oneOf\n * @param [pointer] - json pointer to data\n * @return oneOf schema or an error\n */\nexport function resolveOneOfFuzzy(draft, data, schema = draft.rootSchema, pointer = \"#\") {\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return draft.errors.missingOneOfPropertyError({\n                property: oneOfProperty,\n                pointer,\n                schema,\n                value: data\n            });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = draft.resolveRef(schema.oneOf[i]);\n            const oneOfPropertySchema = draft.step(oneOfProperty, one, data, pointer);\n            if (isJsonError(oneOfPropertySchema)) {\n                return oneOfPropertySchema;\n            }\n            let result = flattenArray(draft.validate(oneOfValue, oneOfPropertySchema, pointer));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                return createOneOfSchemaResult(schema, one, i);\n            }\n        }\n        return draft.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            schema,\n            errors\n        });\n    }\n    // keyword: oneOf\n    const matches = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const one = draft.resolveRef(schema.oneOf[i]);\n        if (draft.isValid(data, one, pointer)) {\n            matches.push({ schema: one, index: i });\n        }\n    }\n    if (matches.length === 1) {\n        return createOneOfSchemaResult(schema, matches[0].schema, matches[0].index);\n    }\n    // fuzzy match oneOf\n    if (getTypeOf(data) === \"object\") {\n        let schemaOfItem;\n        let schemaOfIndex = -1;\n        let fuzzyGreatest = 0;\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = draft.resolveRef(schema.oneOf[i]);\n            const fuzzyValue = fuzzyObjectValue(draft, one, data);\n            if (fuzzyGreatest < fuzzyValue) {\n                fuzzyGreatest = fuzzyValue;\n                schemaOfItem = schema.oneOf[i];\n                schemaOfIndex = i;\n            }\n        }\n        if (schemaOfItem === undefined) {\n            return draft.errors.oneOfError({\n                value: JSON.stringify(data),\n                pointer,\n                schema,\n                oneOf: schema.oneOf\n            });\n        }\n        return createOneOfSchemaResult(schema, schemaOfItem, schemaOfIndex);\n    }\n    if (matches.length > 1) {\n        return draft.errors.multipleOneOfError({ matches, pointer, schema, value: data });\n    }\n    return draft.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        schema,\n        oneOf: schema.oneOf\n    });\n}\n/**\n * validates oneOf definition for given input data\n */\nconst validateOneOf = (draft, schema, value, pointer) => {\n    if (Array.isArray(schema.oneOf)) {\n        const schemaOrError = draft.resolveOneOf(value, schema, pointer);\n        if (isJsonError(schemaOrError)) {\n            return schemaOrError;\n        }\n    }\n};\nexport { validateOneOf };\n", "import deepmerge from \"deepmerge\";\nconst overwriteMerge = (destinationArray, sourceArray) => sourceArray;\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nexport default (a, b) => deepmerge(a, b, { arrayMerge: overwriteMerge });\n// var d = c.filter((item, pos) => c.indexOf(item) === pos)\nconst mergeUniqueItems = (destinationArray, sourceArray) => {\n    const all = destinationArray.concat(sourceArray);\n    return all.filter((item, pos) => all.indexOf(item) === pos);\n};\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nexport const mergeArraysUnique = (a, b) => deepmerge(a, b, { arrayMerge: mergeUniqueItems });\n", "import { mergeArraysUnique } from \"./utils/merge\";\nimport getTypeOf from \"./getTypeOf\";\n/**\n * merges to two json schema. In case of conflicts, will use overwrite first\n * schema or directly return first json schema.\n */\nexport function mergeSchema(a, b) {\n    const aType = getTypeOf(a);\n    const bType = getTypeOf(b);\n    if (aType !== bType) {\n        return a;\n    }\n    const result = mergeArraysUnique(a, b);\n    if (a.getOneOfOrigin) {\n        Object.defineProperty(result, \"getOneOfOrigin\", {\n            enumerable: false,\n            value: a.getOneOfOrigin\n        });\n    }\n    else if (b.getOneOfOrigin) {\n        Object.defineProperty(result, \"getOneOfOrigin\", {\n            enumerable: false,\n            value: b.getOneOfOrigin\n        });\n    }\n    return result;\n}\n", "/**\n * Omit properties from input object. Accepts any number of properties to\n * remove. Example:\n *\n * ```ts\n * omit(myObject, \"if\", \"dependencies\");\n * ```\n *\n * @returns shallow copy of input object without specified properties\n */\nexport function omit(object, ...keysToOmit) {\n    const result = {};\n    Object.keys(object).forEach((key) => {\n        if (!keysToOmit.includes(key)) {\n            result[key] = object[key];\n        }\n    });\n    if (object.getOneOfOrigin) {\n        Object.defineProperty(result, \"getOneOfOrigin\", {\n            enumerable: false,\n            value: object.getOneOfOrigin\n        });\n    }\n    return result;\n}\n", "export interface Cache {\n  has: (value: any) => boolean;\n  set: (key: any, value: any) => void;\n  get: (key: any) => any;\n}\n\nconst { toString: toStringFunction } = Function.prototype;\nconst { create } = Object;\nconst { toString: toStringObject } = Object.prototype;\n\n/**\n * @classdesc Fallback cache for when WeakMap is not natively supported\n */\nclass LegacyCache {\n  private _keys: any[] = [];\n  private _values: any[] = [];\n\n  has(key: any) {\n    return !!~this._keys.indexOf(key);\n  }\n\n  get(key: any) {\n    return this._values[this._keys.indexOf(key)];\n  }\n\n  set(key: any, value: any) {\n    this._keys.push(key);\n    this._values.push(value);\n  }\n}\n\nfunction createCacheLegacy(): Cache {\n  return new LegacyCache();\n}\n\nfunction createCacheModern(): Cache {\n  return new WeakMap();\n}\n\n/**\n * Get a new cache object to prevent circular references.\n */\nexport const createCache =\n  typeof WeakMap !== 'undefined' ? createCacheModern : createCacheLegacy;\n\n/**\n * Get an empty version of the object with the same prototype it has.\n */\nexport function getCleanClone(prototype: any): any {\n  if (!prototype) {\n    return create(null);\n  }\n\n  const Constructor = prototype.constructor;\n\n  if (Constructor === Object) {\n    return prototype === Object.prototype ? {} : create(prototype);\n  }\n\n  if (\n    Constructor &&\n    ~toStringFunction.call(Constructor).indexOf('[native code]')\n  ) {\n    try {\n      return new Constructor();\n    } catch {}\n  }\n\n  return create(prototype);\n}\n\nfunction getRegExpFlagsLegacy(regExp: RegExp): string {\n  let flags = '';\n\n  if (regExp.global) {\n    flags += 'g';\n  }\n\n  if (regExp.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (regExp.multiline) {\n    flags += 'm';\n  }\n\n  if (regExp.unicode) {\n    flags += 'u';\n  }\n\n  if (regExp.sticky) {\n    flags += 'y';\n  }\n\n  return flags;\n}\n\nfunction getRegExpFlagsModern(regExp: RegExp): string {\n  return regExp.flags;\n}\n\n/**\n * Get the flags to apply to the copied regexp.\n */\nexport const getRegExpFlags =\n  /test/g.flags === 'g' ? getRegExpFlagsModern : getRegExpFlagsLegacy;\n\nfunction getTagLegacy(value: any): string {\n  const type = toStringObject.call(value);\n\n  return type.substring(8, type.length - 1);\n}\n\nfunction getTagModern(value: any): string {\n  return value[Symbol.toStringTag] || getTagLegacy(value);\n}\n\n/**\n * Get the tag of the value passed, so that the correct copier can be used.\n */\nexport const getTag =\n  typeof Symbol !== 'undefined' ? getTagModern : getTagLegacy;\n", "import { getCleanClone, getRegExpFlags } from './utils';\n\nimport type { Cache } from './utils';\n\nexport type InternalCopier<Value> = (value: Value, state: State) => Value;\n\nexport interface State {\n  Constructor: any;\n  cache: Cache;\n  copier: InternalCopier<any>;\n  prototype: any;\n}\n\nconst {\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n} = Object;\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n\nconst SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === 'function';\n\nfunction getStrictPropertiesModern(object: any): Array<string | symbol> {\n  return (getOwnPropertyNames(object) as Array<string | symbol>).concat(\n    getOwnPropertySymbols(object)\n  );\n}\n\n/**\n * Get the properites used when copying objects strictly. This includes both keys and symbols.\n */\nconst getStrictProperties = SUPPORTS_SYMBOL\n  ? getStrictPropertiesModern\n  : getOwnPropertyNames;\n\n/**\n * Striclty copy all properties contained on the object.\n */\nfunction copyOwnPropertiesStrict<Value>(\n  value: Value,\n  clone: Value,\n  state: State\n): Value {\n  const properties = getStrictProperties(value);\n\n  for (\n    let index = 0, length = properties.length, property, descriptor;\n    index < length;\n    ++index\n  ) {\n    property = properties[index];\n\n    if (property === 'callee' || property === 'caller') {\n      continue;\n    }\n\n    descriptor = getOwnPropertyDescriptor(value, property);\n\n    if (!descriptor) {\n      // In extra edge cases where the property descriptor cannot be retrived, fall back to\n      // the loose assignment.\n      (clone as any)[property] = state.copier((value as any)[property], state);\n      continue;\n    }\n\n    // Only clone the value if actually a value, not a getter / setter.\n    if (!descriptor.get && !descriptor.set) {\n      descriptor.value = state.copier(descriptor.value, state);\n    }\n\n    try {\n      defineProperty(clone, property, descriptor);\n    } catch (error) {\n      // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n      (clone as any)[property] = descriptor.value;\n    }\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the indexed values in the array.\n */\nexport function copyArrayLoose(array: any[], state: State) {\n  const clone = new state.Constructor();\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(array, clone);\n\n  for (let index = 0, length = array.length; index < length; ++index) {\n    clone[index] = state.copier(array[index], state);\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the indexed values in the array, as well as any custom properties.\n */\nexport function copyArrayStrict<Value extends any[]>(\n  array: Value,\n  state: State\n) {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(array, clone);\n\n  return copyOwnPropertiesStrict(array, clone, state);\n}\n\n/**\n * Copy the contents of the ArrayBuffer.\n */\nexport function copyArrayBuffer<Value extends ArrayBuffer>(\n  arrayBuffer: Value,\n  _state: State\n): Value {\n  return arrayBuffer.slice(0) as Value;\n}\n\n/**\n * Create a new Blob with the contents of the original.\n */\nexport function copyBlob<Value extends Blob>(\n  blob: Value,\n  _state: State\n): Value {\n  return blob.slice(0, blob.size, blob.type) as Value;\n}\n\n/**\n * Create a new DataView with the contents of the original.\n */\nexport function copyDataView<Value extends DataView>(\n  dataView: Value,\n  state: State\n): Value {\n  return new state.Constructor(copyArrayBuffer(dataView.buffer, state));\n}\n\n/**\n * Create a new Date based on the time of the original.\n */\nexport function copyDate<Value extends Date>(date: Value, state: State): Value {\n  return new state.Constructor(date.getTime());\n}\n\n/**\n * Deeply copy the keys and values of the original.\n */\nexport function copyMapLoose<Value extends Map<any, any>>(\n  map: Value,\n  state: State\n): Value {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(map, clone);\n\n  map.forEach((value, key) => {\n    clone.set(key, state.copier(value, state));\n  });\n\n  return clone;\n}\n\n/**\n * Deeply copy the keys and values of the original, as well as any custom properties.\n */\nexport function copyMapStrict<Value extends Map<any, any>>(\n  map: Value,\n  state: State\n) {\n  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);\n}\n\nfunction copyObjectLooseLegacy<Value extends Record<string, any>>(\n  object: Value,\n  state: State\n): Value {\n  const clone: any = getCleanClone(state.prototype);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = state.copier(object[key], state);\n    }\n  }\n\n  return clone;\n}\n\nfunction copyObjectLooseModern<Value extends Record<string, any>>(\n  object: Value,\n  state: State\n): Value {\n  const clone = getCleanClone(state.prototype);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = state.copier(object[key], state);\n    }\n  }\n\n  const symbols = getOwnPropertySymbols(object);\n\n  for (\n    let index = 0, length = symbols.length, symbol;\n    index < length;\n    ++index\n  ) {\n    symbol = symbols[index];\n\n    if (propertyIsEnumerable.call(object, symbol)) {\n      clone[symbol] = state.copier((object as any)[symbol], state);\n    }\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the properties (keys and symbols) and values of the original.\n */\nexport const copyObjectLoose = SUPPORTS_SYMBOL\n  ? copyObjectLooseModern\n  : copyObjectLooseLegacy;\n\n/**\n * Deeply copy the properties (keys and symbols) and values of the original, as well\n * as any hidden or non-enumerable properties.\n */\nexport function copyObjectStrict<Value extends Record<string, any>>(\n  object: Value,\n  state: State\n): Value {\n  const clone = getCleanClone(state.prototype);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n\n  return copyOwnPropertiesStrict(object, clone, state);\n}\n\n/**\n * Create a new primitive wrapper from the value of the original.\n */\nexport function copyPrimitiveWrapper<\n  // Specifically use the object constructor types\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  Value extends Boolean | Number | String\n>(primitiveObject: Value, state: State): Value {\n  return new state.Constructor(primitiveObject.valueOf());\n}\n\n/**\n * Create a new RegExp based on the value and flags of the original.\n */\nexport function copyRegExp<Value extends RegExp>(\n  regExp: Value,\n  state: State\n): Value {\n  const clone = new state.Constructor(\n    regExp.source,\n    getRegExpFlags(regExp)\n  ) as Value;\n\n  clone.lastIndex = regExp.lastIndex;\n\n  return clone;\n}\n\n/**\n * Return the original value (an identity function).\n *\n * @note\n * THis is used for objects that cannot be copied, such as WeakMap.\n */\nexport function copySelf<Value>(value: Value, _state: State): Value {\n  return value;\n}\n\n/**\n * Deeply copy the values of the original.\n */\nexport function copySetLoose<Value extends Set<any>>(\n  set: Value,\n  state: State\n): Value {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(set, clone);\n\n  set.forEach((value) => {\n    clone.add(state.copier(value, state));\n  });\n\n  return clone;\n}\n\n/**\n * Deeply copy the values of the original, as well as any custom properties.\n */\nexport function copySetStrict<Value extends Set<any>>(\n  set: Value,\n  state: State\n): Value {\n  return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);\n}\n", "import {\n  copyArrayBuffer,\n  copyArrayLoose,\n  copyArrayStrict,\n  copyBlob,\n  copyDataView,\n  copyDate,\n  copyMapLoose,\n  copyMapStrict,\n  copyObjectLoose,\n  copyObjectStrict,\n  copyPrimitiveWrapper,\n  copyRegExp,\n  copySelf,\n  copySetLoose,\n  copySetStrict,\n} from './copier';\nimport { createCache, getTag } from './utils';\n\nimport type { InternalCopier, State } from './copier';\n\nexport type { State } from './copier';\n\nconst { isArray } = Array;\nconst { assign } = Object;\nconst getPrototypeOf = Object.getPrototypeOf || ((obj) => obj.__proto__)\n\nexport interface CreateCopierOptions {\n  array?: InternalCopier<any[]>;\n  arrayBuffer?: InternalCopier<ArrayBuffer>;\n  blob?: InternalCopier<Blob>;\n  dataView?: InternalCopier<DataView>;\n  date?: InternalCopier<Date>;\n  error?: InternalCopier<any>;\n  map?: InternalCopier<Map<any, any>>;\n  object?: InternalCopier<Record<string, any>>;\n  regExp?: InternalCopier<RegExp>;\n  set?: InternalCopier<Set<any>>;\n}\n\nconst DEFAULT_LOOSE_OPTIONS: Required<CreateCopierOptions> = {\n  array: copyArrayLoose,\n  arrayBuffer: copyArrayBuffer,\n  blob: copyBlob,\n  dataView: copyDataView,\n  date: copyDate,\n  error: copySelf,\n  map: copyMapLoose,\n  object: copyObjectLoose,\n  regExp: copyRegExp,\n  set: copySetLoose,\n};\nconst DEFAULT_STRICT_OPTIONS: Required<CreateCopierOptions> = assign(\n  {},\n  DEFAULT_LOOSE_OPTIONS,\n  {\n    array: copyArrayStrict,\n    map: copyMapStrict,\n    object: copyObjectStrict,\n    set: copySetStrict,\n  }\n);\n\n/**\n * Get the copiers used for each specific object tag.\n */\nfunction getTagSpecificCopiers(\n  options: Required<CreateCopierOptions>\n): Record<string, InternalCopier<any>> {\n  return {\n    Arguments: options.object,\n    Array: options.array,\n    ArrayBuffer: options.arrayBuffer,\n    Blob: options.blob,\n    Boolean: copyPrimitiveWrapper,\n    DataView: options.dataView,\n    Date: options.date,\n    Error: options.error,\n    Float32Array: options.arrayBuffer,\n    Float64Array: options.arrayBuffer,\n    Int8Array: options.arrayBuffer,\n    Int16Array: options.arrayBuffer,\n    Int32Array: options.arrayBuffer,\n    Map: options.map,\n    Number: copyPrimitiveWrapper,\n    Object: options.object,\n    Promise: copySelf,\n    RegExp: options.regExp,\n    Set: options.set,\n    String: copyPrimitiveWrapper,\n    WeakMap: copySelf,\n    WeakSet: copySelf,\n    Uint8Array: options.arrayBuffer,\n    Uint8ClampedArray: options.arrayBuffer,\n    Uint16Array: options.arrayBuffer,\n    Uint32Array: options.arrayBuffer,\n    Uint64Array: options.arrayBuffer,\n  };\n}\n\n/**\n * Create a custom copier based on the object-specific copy methods passed.\n */\nexport function createCopier(options: CreateCopierOptions) {\n  const normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);\n  const tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);\n  const { Array: array, Object: object } = tagSpecificCopiers;\n\n  function copier(value: any, state: State): any {\n    state.prototype = state.Constructor = undefined;\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n\n    if (state.cache.has(value)) {\n      return state.cache.get(value);\n    }\n\n    state.prototype = getPrototypeOf(value);\n    state.Constructor = state.prototype && state.prototype.constructor;\n\n    // plain objects\n    if (!state.Constructor || state.Constructor === Object) {\n      return object(value, state);\n    }\n\n    // arrays\n    if (isArray(value)) {\n      return array(value, state);\n    }\n\n    const tagSpecificCopier = tagSpecificCopiers[getTag(value)];\n\n    if (tagSpecificCopier) {\n      return tagSpecificCopier(value, state);\n    }\n\n    return typeof value.then === 'function' ? value : object(value, state);\n  }\n\n  return function copy<Value>(value: Value): Value {\n    return copier(value, {\n      Constructor: undefined,\n      cache: createCache(),\n      copier,\n      prototype: undefined,\n    });\n  };\n}\n\n/**\n * Create a custom copier based on the object-specific copy methods passed, defaulting to the\n * same internals as `copyStrict`.\n */\nexport function createStrictCopier(options: CreateCopierOptions) {\n  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));\n}\n\n/**\n * Copy an value deeply as much as possible, where strict recreation of object properties\n * are maintained. All properties (including non-enumerable ones) are copied with their\n * original property descriptors on both objects and arrays.\n */\nexport const copyStrict = createStrictCopier({});\n\n/**\n * Copy an value deeply as much as possible.\n */\nexport default createCopier({});\n", "import copy from \"fast-copy\";\nexport default copy;\n", "/**\n * returns if-then-else as a json schema. does not merge with input\n * json schema. you probably will need to do so to correctly resolve\n * references.\n *\n * @returns json schema defined by if-then-else or undefined\n */\nexport function resolveIfSchema(draft, schema, data) {\n    if (schema.if == null) {\n        return undefined;\n    }\n    if (schema.if === false) {\n        return schema.else;\n    }\n    if (schema.if && (schema.then || schema.else)) {\n        const ifErrors = draft.validate(data, draft.resolveRef(schema.if));\n        if (ifErrors.length === 0 && schema.then) {\n            return draft.resolveRef(schema.then);\n        }\n        if (ifErrors.length !== 0 && schema.else) {\n            return draft.resolveRef(schema.else);\n        }\n    }\n}\n/**\n * @returns validation result of it-then-else schema\n */\nconst validateIf = (draft, schema, value, pointer) => {\n    const resolvedSchema = resolveIfSchema(draft, schema, value);\n    if (resolvedSchema) {\n        return draft.validate(value, resolvedSchema, pointer);\n    }\n};\nexport { validateIf };\n", "import { mergeSchema } from \"../mergeSchema\";\nimport { omit } from \"../utils/omit\";\nimport copy from \"../utils/copy\";\nimport { resolveIfSchema } from \"./if\";\n/**\n * resolves schema\n * when complete this will have much duplication to step.object etc\n */\nexport function resolveSchema(draft, schemaToResolve, data) {\n    var _a;\n    const schema = { ...((_a = draft.resolveRef(schemaToResolve)) !== null && _a !== void 0 ? _a : {}) };\n    const ifSchema = resolveIfSchema(draft, schema, data);\n    if (ifSchema) {\n        return ifSchema;\n    }\n    return omit(schema, \"if\", \"then\", \"else\");\n}\nexport function resolveAllOf(draft, data, schema = draft.rootSchema) {\n    let mergedSchema = copy(schema);\n    for (let i = 0; i < schema.allOf.length; i += 1) {\n        // @todo introduce draft.resolveSchema to iteratively resolve\n        const allOfSchema = resolveSchema(draft, schema.allOf[i], data);\n        mergedSchema = mergeSchema(mergedSchema, allOfSchema);\n    }\n    delete mergedSchema.allOf;\n    return mergedSchema;\n}\n/**\n * @attention: subschemas have to be resolved upfront (e.g. if-else that do not apply)\n * Merge all allOf sub schema into a single schema. Returns undefined for\n * missing allOf definition.\n *\n * @returns json schema defined by allOf or undefined\n */\nexport function mergeAllOfSchema(draft, schema) {\n    const { allOf } = schema;\n    if (!Array.isArray(allOf) || allOf.length === 0) {\n        return;\n    }\n    let resolvedSchema = {};\n    allOf.forEach((subschema) => {\n        resolvedSchema = mergeSchema(resolvedSchema, draft.resolveRef(subschema));\n    });\n    return resolvedSchema;\n}\n/**\n * validate allOf definition for given input data\n */\nconst validateAllOf = (draft, schema, value, pointer) => {\n    const { allOf } = schema;\n    if (!Array.isArray(allOf) || allOf.length === 0) {\n        return;\n    }\n    const errors = [];\n    schema.allOf.forEach((subSchema) => {\n        errors.push(...draft.validate(value, subSchema, pointer));\n    });\n    return errors;\n};\nexport { validateAllOf };\n", "export default function resolveRef(schema, rootSchema) {\n    if (schema == null || schema.$ref == null) {\n        return schema;\n    }\n    if (schema.getRoot) {\n        // we actually always need to resolve the schema like this, since returned subschemas\n        // must resolve relative from their schema\n        const resolvedSchema = schema.getRoot().getRef(schema);\n        // console.log(schema.$ref, \"=>\", resolvedSchema);\n        return resolvedSchema;\n    }\n    // tryout - this should never be called, except we missed something\n    const resolvedSchema = rootSchema.getRef(schema);\n    return resolvedSchema;\n}\n", "export default function resolveRefMerge(schema, rootSchema) {\n    if (schema == null || schema.$ref == null) {\n        return schema;\n    }\n    const resolvedSchema = rootSchema.getRef(schema);\n    const mergedSchema = Object.assign({}, resolvedSchema, schema);\n    delete mergedSchema.$ref;\n    // @todo the following might not be safe nor incomplete\n    Object.defineProperty(mergedSchema, \"__ref\", { enumerable: false, value: schema.__ref });\n    Object.defineProperty(mergedSchema, \"getRoot\", { enumerable: false, value: schema.getRoot });\n    return mergedSchema;\n}\n", "/**\n * @returns list with unique values only\n */\nexport function uniqueItems(list) {\n    return list.filter((item, index) => list.indexOf(item) === index);\n}\n", "import getTypeOf from \"../getTypeOf\";\nexport function isObject(v) {\n    return getTypeOf(v) === \"object\";\n}\n", "import getTypeOf from \"../getTypeOf\";\nimport { mergeSchema } from \"../mergeSchema\";\nimport { uniqueItems } from \"../utils/uniqueItems\";\nimport { isObject } from \"../utils/isObject\";\n/**\n * returns dependencies as an object json schema. does not merge with input\n * json schema. you probably will need to do so to correctly resolve\n * references.\n *\n * @returns merged json schema defined by dependencies or undefined\n */\nexport function resolveDependencies(draft, schema, data) {\n    const { dependencies } = schema;\n    if (!isObject(dependencies) || !isObject(data)) {\n        return;\n    }\n    let updated = false;\n    let resolvedSchema = { required: [] };\n    Object.keys(dependencies).forEach((prop) => {\n        var _a, _b;\n        if (data[prop] == null &&\n            !(((_a = schema.required) === null || _a === void 0 ? void 0 : _a.includes(prop)) || ((_b = resolvedSchema.required) === null || _b === void 0 ? void 0 : _b.includes(prop)))) {\n            return;\n        }\n        const dependency = dependencies[prop];\n        // dependency array\n        if (Array.isArray(dependency)) {\n            updated = true;\n            resolvedSchema.required.push(...dependency);\n            return;\n        }\n        // dependency schema\n        if (isObject(dependency)) {\n            updated = true;\n            resolvedSchema = mergeSchema(resolvedSchema, draft.resolveRef(dependency));\n            return;\n        }\n    });\n    if (updated) {\n        resolvedSchema.required = uniqueItems(resolvedSchema.required);\n        return resolvedSchema;\n    }\n}\n/**\n * validate dependencies definition for given input data\n */\nconst validateDependencies = (draft, schema, value, pointer) => {\n    if (getTypeOf(schema.dependencies) !== \"object\") {\n        return undefined;\n    }\n    const errors = [];\n    Object.keys(value).forEach((property) => {\n        if (schema.dependencies[property] === undefined) {\n            return;\n        }\n        // @draft >= 6 boolean schema\n        if (schema.dependencies[property] === true) {\n            return;\n        }\n        if (schema.dependencies[property] === false) {\n            errors.push(draft.errors.missingDependencyError({ pointer, schema, value }));\n            return;\n        }\n        let dependencyErrors;\n        const type = getTypeOf(schema.dependencies[property]);\n        if (type === \"array\") {\n            dependencyErrors = schema.dependencies[property]\n                .filter((dependency) => value[dependency] === undefined)\n                .map((missingProperty) => draft.errors.missingDependencyError({ missingProperty, pointer, schema, value }));\n        }\n        else if (type === \"object\") {\n            dependencyErrors = draft.validate(value, schema.dependencies[property], pointer);\n        }\n        else {\n            throw new Error(`Invalid dependency definition for ${pointer}/${property}. Must be string[] or schema`);\n        }\n        errors.push(...dependencyErrors);\n    });\n    return errors.length > 0 ? errors : undefined;\n};\nexport { validateDependencies };\n", "/**\n * @draft-04\n */\nimport { mergeSchema } from \"../mergeSchema\";\nimport { omit } from \"../utils/omit\";\n/**\n * returns merged schema of all valid anyOf subschemas for the given input data.\n * Does not merge with rest input schema.\n *\n * @returns merged anyOf subschemas which are valid to the given input data.\n */\nexport function mergeValidAnyOfSchema(draft, schema, data) {\n    if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {\n        return;\n    }\n    let resolvedSchema;\n    schema.anyOf.forEach((anySchema) => {\n        anySchema = draft.resolveRef(anySchema);\n        if (draft.isValid(data, anySchema)) {\n            resolvedSchema = resolvedSchema ? mergeSchema(resolvedSchema, anySchema) : anySchema;\n        }\n    });\n    return resolvedSchema;\n}\n/**\n * @returns extended input schema with valid anyOf subschemas or JsonError if\n * no anyOf schema matches input data\n */\nexport function resolveAnyOf(draft, data, schema = draft.rootSchema, pointer = \"#\") {\n    const { anyOf } = schema;\n    if (!Array.isArray(anyOf) || anyOf.length === 0) {\n        return schema;\n    }\n    const resolvedSchema = mergeValidAnyOfSchema(draft, schema, data);\n    if (resolvedSchema == null) {\n        return draft.errors.anyOfError({ pointer, schema, value: data, anyOf: JSON.stringify(anyOf) });\n    }\n    const mergedSchema = mergeSchema(schema, resolvedSchema);\n    return omit(mergedSchema, \"anyOf\");\n}\n/**\n * validate anyOf definition for given input data\n */\nconst validateAnyOf = (draft, schema, value, pointer) => {\n    if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {\n        return undefined;\n    }\n    for (let i = 0; i < schema.anyOf.length; i += 1) {\n        if (draft.isValid(value, schema.anyOf[i])) {\n            return undefined;\n        }\n    }\n    return draft.errors.anyOfError({ pointer, schema, value, anyOf: schema.anyOf });\n};\nexport { validateAnyOf };\n", "import { isJsonError } from \"./types\";\nimport { mergeSchema } from \"./mergeSchema\";\nimport { resolveIfSchema } from \"./features/if\";\nimport { resolveDependencies } from \"./features/dependencies\";\nimport { mergeAllOfSchema } from \"./features/allOf\";\nimport { mergeValidAnyOfSchema } from \"./features/anyOf\";\nimport { resolveOneOfFuzzy as resolveOneOf } from \"./features/oneOf\";\nimport { omit } from \"./utils/omit\";\nconst toOmit = [\"allOf\", \"anyOf\", \"oneOf\", \"dependencies\", \"if\", \"then\", \"else\"];\nconst dynamicProperties = [\"allOf\", \"anyOf\", \"oneOf\", \"dependencies\", \"if\"];\nexport function isDynamicSchema(schema) {\n    const givenProps = Object.keys(schema);\n    return dynamicProperties.findIndex((prop) => givenProps.includes(prop)) !== -1;\n}\n/**\n * @note this utility does not reference draft methods for resolution\n * @todo consider using draft methods\n *\n * Resolves all dynamic schema definitions for the given input data and returns\n * the resulting json-schema without any dynamic schema definitions. The result\n * is not merged with the original input schema, thus static definitions of the\n * input schema are untouched and missing. For a full schema definition of this\n * input data you have to merge the result with the original schema\n * (@see reduceSchema)\n *\n * dynamic schema definitions: dependencies, allOf, anyOf, oneOf, if\n *\n * @returns static schema from resolved dynamic schema definitions for this\n *  specific input data\n */\nexport function resolveDynamicSchema(draft, schema, data, pointer) {\n    let resolvedSchema;\n    let error;\n    schema = draft.resolveRef(schema);\n    // @feature oneOf\n    if (schema.oneOf) {\n        const oneOfSchema = resolveOneOf(draft, data, schema, pointer);\n        if (isJsonError(oneOfSchema)) {\n            error = oneOfSchema;\n        }\n        else if (oneOfSchema) {\n            resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, oneOfSchema);\n        }\n    }\n    // @feature allOf\n    if (Array.isArray(schema.allOf)) {\n        const allOf = schema.allOf.map((s) => {\n            // before merging allOf schema we need to resolve all subschemas\n            // if not, we would wrongly merge oneOf, if-then statements, etc\n            if (isDynamicSchema(s)) {\n                // copy of reduceSchema\n                let result = resolveDynamicSchema(draft, s, data, pointer);\n                if (result) {\n                    result = mergeSchema(s, result);\n                    return omit(result, ...toOmit);\n                }\n                return undefined;\n            }\n            return s;\n        });\n        if (allOf.length > 0) {\n            const allOfSchema = mergeAllOfSchema(draft, { allOf });\n            resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, allOfSchema);\n        }\n    }\n    // @feature anyOf\n    const anyOfSchema = mergeValidAnyOfSchema(draft, schema, data);\n    if (anyOfSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, anyOfSchema);\n    }\n    // @feature dependencies\n    const dependenciesSchema = resolveDependencies(draft, schema, data);\n    if (dependenciesSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, dependenciesSchema);\n    }\n    // @feature if-then-else\n    const ifSchema = resolveIfSchema(draft, schema, data);\n    if (ifSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, ifSchema);\n    }\n    if (resolvedSchema == null) {\n        return error;\n    }\n    const nestedSchema = resolveDynamicSchema(draft, resolvedSchema, data, pointer);\n    if (nestedSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema, nestedSchema);\n    }\n    return omit(resolvedSchema, ...toOmit);\n}\n", "import { mergeSchema } from \"./mergeSchema\";\nimport { resolveDynamicSchema } from \"./resolveDynamicSchema\";\nimport { omit } from \"./utils/omit\";\nconst toOmit = [\"allOf\", \"anyOf\", \"oneOf\", \"dependencies\", \"if\", \"then\", \"else\"];\n/**\n * reduces json schema by merging dynamic constructs like if-then-else,\n * dependencies, allOf, anyOf, oneOf, etc into a static json schema\n * omitting those properties.\n *\n * @returns input schema reduced by dynamic schema definitions for the given\n * input data\n */\nexport function reduceSchema(draft, schema, data, pointer) {\n    let resolvedSchema = resolveDynamicSchema(draft, schema, data, pointer);\n    if (resolvedSchema) {\n        resolvedSchema = mergeSchema(schema, resolvedSchema);\n        return omit(resolvedSchema, ...toOmit);\n    }\n    return schema;\n}\n", "import copy from \"../utils/copy\";\nexport class Draft {\n    constructor(config, schema) {\n        /** cache for remote schemas */\n        this.remotes = {};\n        /** error creators by id */\n        this.errors = {};\n        /** map for valid keywords of a type  */\n        this.typeKeywords = {};\n        /** keyword validators  */\n        this.validateKeyword = {};\n        /** type validators  */\n        this.validateType = {};\n        /** format validators  */\n        this.validateFormat = {};\n        this.config = config;\n        this.typeKeywords = copy(config.typeKeywords);\n        this.validateKeyword = Object.assign({}, config.validateKeyword);\n        this.validateType = Object.assign({}, config.validateType);\n        this.validateFormat = Object.assign({}, config.validateFormat);\n        this.errors = Object.assign({}, config.errors);\n        this.setSchema(schema);\n    }\n    get rootSchema() {\n        return this.__rootSchema;\n    }\n    set rootSchema(rootSchema) {\n        if (rootSchema == null) {\n            return;\n        }\n        this.__rootSchema = this.config.compileSchema(this, rootSchema);\n    }\n    /**\n     * register a json-schema to be referenced from another json-schema\n     * @param url - base-url of json-schema (aka id)\n     * @param schema - json-schema root\n     */\n    addRemoteSchema(url, schema) {\n        this.config.addRemoteSchema(this, url, schema);\n    }\n    compileSchema(schema) {\n        var _a;\n        return this.config.compileSchema(this, schema, (_a = this.rootSchema) !== null && _a !== void 0 ? _a : schema);\n    }\n    createSchemaOf(data) {\n        return this.config.createSchemaOf(data);\n    }\n    /**\n     * Iterates over data, retrieving its schema\n     *\n     * @param data - the data to iterate\n     * @param callback - will be called with (schema, data, pointer) on each item\n     * @param [schema] - the schema matching the data. Defaults to rootSchema\n     * @param [pointer] - pointer to current data. Default to rootPointer\n     */\n    each(data, callback, schema, pointer) {\n        return this.config.each(this, data, callback, schema, pointer);\n    }\n    eachSchema(callback, schema = this.rootSchema) {\n        return this.config.eachSchema(schema, callback);\n    }\n    getChildSchemaSelection(property, schema) {\n        return this.config.getChildSchemaSelection(this, property, schema);\n    }\n    /**\n     * Returns the json-schema of a data-json-pointer.\n     *\n     * To resolve dynamic schema where the type of json-schema is evaluated by\n     * its value, a data object has to be passed in options.\n     *\n     * Per default this function will return `undefined` for valid properties that\n     * do not have a defined schema. Use the option `withSchemaWarning: true` to\n     * receive an error with `code: schema-warning` containing the location of its\n     * last evaluated json-schema.\n     *\n     * Notes\n     *      - uses draft.step to walk through data and schema\n     *\n     * @param draft\n     * @param pointer - json pointer in data to get the json schema for\n     * @param [options.data] - the data object, which includes the json pointers value. This is optional, as\n     *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n     * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema\n     * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition\n     * @return resolved json-schema object of requested json-pointer location\n     */\n    getSchema(options) {\n        return this.config.getSchema(this, options);\n    }\n    /**\n     * Create data object matching the given schema\n     *\n     * @param [data] - optional template data\n     * @param [schema] - json schema, defaults to rootSchema\n     * @return created template data\n     */\n    getTemplate(data, schema, opts = this.config.templateDefaultOptions) {\n        return this.config.getTemplate(this, data, schema, opts);\n    }\n    isValid(data, schema, pointer) {\n        return this.config.isValid(this, data, schema, pointer);\n    }\n    resolveAnyOf(data, schema, pointer) {\n        return this.config.resolveAnyOf(this, data, schema, pointer);\n    }\n    resolveAllOf(data, schema) {\n        return this.config.resolveAllOf(this, data, schema);\n    }\n    resolveRef(schema) {\n        return this.config.resolveRef(schema, this.rootSchema);\n    }\n    resolveOneOf(data, schema, pointer) {\n        return this.config.resolveOneOf(this, data, schema, pointer);\n    }\n    setSchema(schema) {\n        this.rootSchema = schema;\n    }\n    /**\n     * Returns the json-schema of the given object property or array item.\n     * e.g. it steps by one key into the data\n     *\n     *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n     *  returns the correct schema.\n     *\n     * @param  key       - property-name or array-index\n     * @param  schema    - json schema of current data\n     * @param  data      - parent of key\n     * @param  [pointer] - pointer to schema and data (parent of key)\n     * @return Schema or Error if failed resolving key\n     */\n    step(key, schema, data, pointer) {\n        return this.config.step(this, key, schema, data, pointer);\n    }\n    /**\n     * Validate data by a json schema\n     *\n     * @param value - value to validate\n     * @param [schema] - json schema, defaults to rootSchema\n     * @param [pointer] - json pointer pointing to value (used for error-messages only)\n     * @return list of errors or empty\n     */\n    validate(data, schema, pointer) {\n        return this.config.validate(this, data, schema, pointer);\n    }\n}\n", "/**\n * register a json-schema to be referenced from another json-schema\n * @param url    base-url of json-schema (aka id)\n * @param schema\n */\nexport default function addRemoteSchema(draft, url, schema) {\n    schema.id = schema.id || url;\n    draft.remotes[url] = draft.compileSchema(schema);\n}\n", "import gp from \"@sagold/json-pointer\";\nimport getTypeDefs from \"./schema/getTypeDefs\";\nimport { isObject } from \"./utils/isObject\";\nfunction nextTypeDefs(schema, pointer) {\n    if (this.callback(schema, pointer) === true) {\n        // eslint-disable-line no-invalid-this\n        return; // stop iteration\n    }\n    const defs = getTypeDefs(schema);\n    // eslint-disable-next-line no-invalid-this\n    defs.forEach((next) => this.nextTypeDefs(next.def, gp.join(pointer, next.pointer, false)));\n}\nfunction eachDefinition(walk, schema, pointer, key = \"definitions\") {\n    const defs = schema[key];\n    Object.keys(defs).forEach((defId) => {\n        if (defs[defId] === false || isObject(defs[defId])) {\n            walk.nextTypeDefs(defs[defId], gp.join(pointer, key, defId, false));\n            return;\n        }\n        // console.log(`Invalid schema in ${pointer}/${key}/${defId}`);\n    });\n}\nexport function eachSchema(schema, callback, pointer = \"#\") {\n    const walk = { callback, nextTypeDefs };\n    walk.nextTypeDefs(schema, pointer);\n    if (schema.definitions != null) {\n        walk.callback = (defschema, schemaPointer) => {\n            callback(defschema, schemaPointer);\n            if (defschema.definitions != null) {\n                eachDefinition(walk, defschema, schemaPointer);\n            }\n        };\n        eachDefinition(walk, schema, pointer);\n    }\n    if (schema.$defs != null) {\n        walk.callback = (defschema, schemaPointer) => {\n            callback(defschema, schemaPointer);\n            if (defschema.definitions != null) {\n                eachDefinition(walk, defschema, schemaPointer);\n            }\n        };\n        eachDefinition(walk, schema, pointer, \"$defs\");\n    }\n}\n", "import gp from \"@sagold/json-pointer\";\nimport { get } from \"@sagold/json-query\";\nimport getTypeId from \"./getTypeId\";\nimport types from \"./types\";\nimport { isObject } from \"../utils/isObject\";\n/**\n * Returns a list of all (direct) type definitions from the given schema\n * @param schema\n * @return list of type definition, given as { pointer, def }\n */\nexport default function getTypeDefs(schema) {\n    const defs = [];\n    const id = getTypeId(schema);\n    if (id == null) {\n        return defs;\n    }\n    let type;\n    if (Array.isArray(id)) {\n        // since types can also be declared as a set of types, merge the definitions\n        // maybe this will require a more sophisticated approach\n        type = {};\n        for (let i = 0, l = id.length; i < l; i += 1) {\n            Object.assign(type, types[id[i]]);\n        }\n    }\n    else {\n        type = types[id];\n    }\n    if (type.definitions == null) {\n        return defs;\n    }\n    type.definitions.forEach((query) => {\n        get(schema, query, (value, key, parent, pointer) => {\n            if (isObject(value) && getTypeId(value)) {\n                defs.push({ pointer: gp.join(gp.split(pointer), false), def: value });\n            }\n        });\n    });\n    return defs;\n}\n", "import EBNF from \"ebnf/dist/Grammars/W3CEBNF\";\nimport { jsonQueryGrammar } from \"./jsonQueryGrammar\";\nconst valid = /(children|text|type|start|end|rest|errors|fullText|\\d+)/;\nconst subset = /(children|text|type|\\d+)/;\nconst toJSON = (ast) => JSON.stringify(ast, (key, value) => (key === \"\" || valid.test(key) ? value : undefined), 2);\nconst toSmallJSON = (ast) => JSON.stringify(ast, (key, value) => key === \"\" || (key === \"rest\" && value !== \"\") || subset.test(key)\n    ? value\n    : undefined, 2);\nconst parser = new EBNF.Parser(jsonQueryGrammar);\nexport const parse = (query) => parser.getAST(query);\nexport const reduce = (ast) => JSON.parse(toSmallJSON(ast));\nexport { toJSON };\n", "export const propertyRegex = \"[^?/{}*,()#]+\";\n// W3C ENBF grammar\n// https://github.com/lys-lang/node-ebnf/blob/master/test/W3CEBNF.spec.ts\n// https://www.w3.org/TR/xml/#sec-notation\nexport const jsonQueryGrammar = `\nroot ::= (\"#\" recursion | recursion | (query | pattern) recursion* | \"#\" SEP? | SEP)\nrecursion ::= (SEP query | pattern)*\n\nquery ::= (ESC escaped ESC | property | all | any | regex) typecheck? lookahead?\nproperty ::= ${propertyRegex}\nregex ::= \"{\" [^}]+ \"}\"\nSEP ::= \"/\"\nall ::= \"**\"\nany ::= \"*\"\n\ntypecheck ::= \"?:\" (\"value\" | \"boolean\" | \"string\" | \"number\" | \"object\" | \"array\")\nlookahead ::= \"?\" expression ((andExpr | orExpr) expression)*\nandExpr ::= S? \"&&\" S?\norExpr ::= S? \"||\" S?\n\nexpression ::= (exprProperty | ESC escaped ESC) ((isnot | is) (exprProperty | regex | ESC escaped ESC))*\nexprProperty ::= [a-zA-Z0-9-_ $]+\nescaped ::= [^\"]+\nis ::= \":\"\nisnot ::= \":!\"\nESC ::= '\"'\n\npattern ::= S? \"(\" (SEP query | pattern (orPattern? pattern)*)* \")\" quantifier? S? lookahead?\nquantifier ::= \"+\" | \"*\" | [0-9]+\norPattern ::= S? \",\" S?\n\nS ::= [ ]*\n`;\n", "export const VALUE_INDEX = 0;\nexport const KEY_INDEX = 1;\nexport const PARENT_INDEX = 2;\nexport const POINTER_INDEX = 3;\n", "const join = (a, b) => `${a}/${b}`;\nimport { VALUE_INDEX, POINTER_INDEX } from \"./keys\";\nconst toString = Object.prototype.toString;\nconst rContainer = /Object|Array/;\nconst isContainer = (v) => rContainer.test(toString.call(v));\nconst getTypeOf = (v) => toString\n    .call(v)\n    .match(/\\s([^\\]]+)\\]/)\n    .pop()\n    .toLowerCase();\nfunction nodeAsRegex(node) {\n    return new RegExp(node.text.replace(/(^{|}$)/g, \"\"));\n}\n/**\n * Iterates over object or array, passing each key, value and parentObject to the callback\n * @param value - to iterate\n * @param callback - receiving key on given input value\n */\nfunction forEach(parent, callback) {\n    if (Array.isArray(parent)) {\n        parent.forEach(callback);\n    }\n    else if (Object.prototype.toString.call(parent) === \"[object Object]\") {\n        Object.keys(parent).forEach(function (key) {\n            callback(parent[key], key, parent);\n        });\n    }\n}\n/**\n * Returns all keys of the given input data\n * @param  value\n * @return {Array} containing keys of given value\n */\nfunction getKeys(value) {\n    if (Array.isArray(value)) {\n        return value.map(function (value, index) {\n            return `${index}`;\n        });\n    }\n    if (Object.prototype.toString.call(value) === \"[object Object]\") {\n        return Object.keys(value);\n    }\n    return [];\n}\nconst cache = {\n    mem: [],\n    get(entry, prop) {\n        const v = entry[VALUE_INDEX][prop];\n        if (cache.mem.includes(v)) {\n            return undefined;\n        }\n        if (isContainer(v)) {\n            cache.mem.push(v);\n        }\n        return [v, prop, entry[VALUE_INDEX], join(entry[POINTER_INDEX], prop)];\n    },\n    reset() {\n        cache.mem.length = 0;\n    },\n};\nconst expand = {\n    any(node, entry) {\n        const value = entry[VALUE_INDEX];\n        return (getKeys(value)\n            // .map(prop => cache.get(entry, prop));\n            .map((prop) => [\n            value[prop],\n            prop,\n            value,\n            join(entry[POINTER_INDEX], prop),\n        ]));\n    },\n    all(node, entry) {\n        const result = [entry];\n        forEach(entry[VALUE_INDEX], (value, prop) => {\n            const childEntry = cache.get(entry, prop);\n            // const childEntry = [value, prop, entry[VALUE_INDEX], join(entry[POINTER_INDEX], prop)];\n            childEntry && result.push(...expand.all(node, childEntry));\n        });\n        return result;\n    },\n    regex(node, entry) {\n        const regex = nodeAsRegex(node);\n        const value = entry[VALUE_INDEX];\n        return getKeys(value)\n            .filter((prop) => regex.test(prop))\n            .map((prop) => [\n            value[prop],\n            prop,\n            value,\n            join(entry[POINTER_INDEX], prop),\n        ]);\n    },\n};\nconst select = {\n    // alias to property (but escaped)\n    escaped: (node, entry) => select.property(node, entry),\n    property: (node, entry) => {\n        const prop = node.text;\n        if (entry[VALUE_INDEX] && entry[VALUE_INDEX][prop] !== undefined) {\n            return [\n                entry[VALUE_INDEX][prop],\n                prop,\n                entry[VALUE_INDEX],\n                join(entry[POINTER_INDEX], prop),\n            ];\n        }\n    },\n    typecheck: (node, entry) => {\n        const checkedTyped = node.text.replace(/^\\?:/, \"\");\n        if (checkedTyped === \"value\") {\n            return isContainer(entry[VALUE_INDEX]) ? undefined : entry;\n        }\n        const type = getTypeOf(entry[VALUE_INDEX]);\n        if (type === checkedTyped) {\n            return entry;\n        }\n    },\n    lookahead: (node, entry) => {\n        let valid = true;\n        let or = false;\n        node.children.forEach((expr) => {\n            if (expr.type === \"expression\") {\n                const isValid = select.expression(expr, entry) !== undefined;\n                valid = or === true ? valid || isValid : valid && isValid;\n            }\n            else {\n                or = expr.type === \"orExpr\";\n            }\n        });\n        return valid ? entry : undefined;\n    },\n    expression: (node, entry) => {\n        const prop = node.children[0].text;\n        const cmp = node.children[1];\n        const test = node.children[2];\n        const value = entry[VALUE_INDEX];\n        if (isContainer(value) === false) {\n            return undefined;\n        }\n        return expressionMatches(value[prop], cmp, test) ? entry : undefined;\n    },\n};\nfunction expressionMatches(value, cmp, test) {\n    if (cmp === undefined) {\n        return value !== undefined;\n    }\n    let valid;\n    const valueString = `${value}`;\n    if (test.type === \"regex\") {\n        const regex = nodeAsRegex(test);\n        valid = regex.test(valueString);\n    }\n    else {\n        valid = valueString === test.text;\n    }\n    if (cmp.type === \"isnot\") {\n        valid = valid === false && value !== undefined;\n    }\n    return valid;\n}\nexport { expand, select, cache };\n", "import { expand, select, cache } from \"./nodes\";\nimport { VALUE_INDEX, KEY_INDEX, PARENT_INDEX, POINTER_INDEX } from \"./keys\";\nfunction collect(func, input, node, pointer) {\n    const result = [];\n    for (let i = 0, l = input.length; i < l; i += 1) {\n        result.push(...func(node, input[i], node, pointer));\n    }\n    return result;\n}\nfunction reduce(func, input, node, pointer) {\n    const result = [];\n    for (let i = 0, l = input.length; i < l; i += 1) {\n        const output = func(node, input[i], pointer);\n        if (output) {\n            result.push(output);\n        }\n    }\n    return result;\n}\nfunction query(data, ast, pointer) {\n    let result = data;\n    ast.children.forEach((node) => {\n        if (expand[node.type]) {\n            result = collect(expand[node.type], result, node, pointer);\n        }\n        else if (select[node.type]) {\n            result = reduce(select[node.type], result, node, pointer);\n        }\n        else {\n            throw new Error(`Unknown filter ${node.type}`);\n        }\n    });\n    return result;\n}\nfunction runPatternOnce(inputSet, ast, pointer) {\n    const resultingSet = [];\n    let workingSet = inputSet;\n    ast.children.forEach((node) => {\n        if (node.type === \"orPattern\") {\n            resultingSet.push(...workingSet);\n            workingSet = inputSet;\n            return;\n        }\n        workingSet = runNode(workingSet, node, pointer);\n    });\n    resultingSet.push(...workingSet);\n    return resultingSet;\n}\nfunction getIterationCount(quantifier) {\n    if (quantifier == null) {\n        return 1; // default, simple group\n    }\n    if (quantifier === \"*\" || quantifier === \"+\") {\n        return Infinity;\n    }\n    const count = parseInt(quantifier);\n    return isNaN(count) ? 1 : count;\n}\nfunction pattern(data, ast, pointer) {\n    const result = [];\n    const quantifier = ast.children.find((node) => node.type === \"quantifier\");\n    const iterationCount = getIterationCount(quantifier && quantifier.text);\n    let workingSet = data;\n    if (quantifier && quantifier.text === \"*\") {\n        result.push(...workingSet);\n    }\n    let count = 0;\n    while (workingSet.length > 0 && count < iterationCount) {\n        workingSet = runPatternOnce(workingSet, ast, pointer);\n        result.push(...workingSet);\n        count += 1;\n    }\n    return result;\n}\nfunction skip(data, ast, pointer) {\n    let result = data;\n    ast.children.forEach((n) => (result = runNode(result, n, pointer)));\n    return result;\n}\nfunction runNode(data, ast, pointer) {\n    let result;\n    if (ast.type === \"query\") {\n        result = query(data, ast, pointer);\n    }\n    else if (ast.type === \"pattern\") {\n        result = pattern(data, ast, pointer);\n    }\n    else {\n        result = skip(data, ast, pointer);\n    }\n    // after each query or pattern, reset the cache, to (re)enable nested queries\n    cache.reset();\n    cache.mem.push(data);\n    return result;\n}\nexport function run(data, ast) {\n    cache.reset();\n    cache.mem.push(data);\n    return runNode([[data, null, null, \"#\"]], ast);\n}\nexport { VALUE_INDEX, KEY_INDEX, PARENT_INDEX, POINTER_INDEX };\n", "import { parse } from \"./parser\";\nimport { run, VALUE_INDEX, POINTER_INDEX } from \"./interpreter\";\nconst returnTypes = {\n    value: (r) => r.map((e) => e[VALUE_INDEX]),\n    pointer: (r) => r.map((e) => e[POINTER_INDEX]),\n    all: (r) => r,\n    map: (r) => {\n        const map = {};\n        r.forEach((e) => (map[e[POINTER_INDEX]] = e[VALUE_INDEX]));\n        return map;\n    },\n};\nexport var ReturnType;\n(function (ReturnType) {\n    ReturnType[\"POINTER\"] = \"pointer\";\n    ReturnType[\"VALUE\"] = \"value\";\n    ReturnType[\"ALL\"] = \"all\";\n    ReturnType[\"MAP\"] = \"map\";\n})(ReturnType || (ReturnType = {}));\n// export return types on function\nget.POINTER = ReturnType.POINTER;\nget.VALUE = ReturnType.VALUE;\nget.ALL = ReturnType.ALL;\nget.MAP = ReturnType.MAP;\n/**\n * Runs query on input data and returns the results\n * @param data - input data\n * @param queryString - json-query string\n * @param returnType - result format or a custom callback\n */\nexport function get(data, queryString, returnType = ReturnType.VALUE) {\n    if (queryString == null) {\n        return [];\n    }\n    queryString = queryString.replace(/(\\/$)/g, \"\");\n    if (queryString === \"\") {\n        queryString = \"#\";\n    }\n    const ast = parse(queryString);\n    if (ast == null) {\n        throw new Error(`empty ast for '${queryString}'`);\n    }\n    if (ast.rest !== \"\") {\n        throw new Error(`Failed parsing queryString from: '${ast.rest}'`);\n    }\n    const result = run(data, ast);\n    if (typeof returnType === \"function\") {\n        return result.map((r) => returnType(...r));\n    }\n    else if (returnTypes[returnType]) {\n        return returnTypes[returnType](result);\n    }\n    return result;\n}\n", "import { parse } from \"./parser\";\nconst skip = [\"root\", \"recursion\"];\nfunction buildPath(node, path = []) {\n    if (skip.includes(node.type)) {\n        node.children.forEach((n) => buildPath(n, path));\n        return path;\n    }\n    // remove escaped property quotes?\n    path.push(node.text);\n    return path;\n}\n/**\n * Returns queryString as a list of property-queries\n */\nexport function split(queryString) {\n    if (queryString == null || queryString === \"\") {\n        return [];\n    }\n    const ast = parse(queryString);\n    // console.log(toJSON(ast, null, 2));\n    return buildPath(ast);\n}\n", "import { get, ReturnType } from \"./get\";\nimport { propertyRegex } from \"./parser/jsonQueryGrammar\";\nimport { split } from \"./split\";\nconst cp = (v) => JSON.parse(JSON.stringify(v));\nconst toString = Object.prototype.toString;\nconst getType = (v) => toString\n    .call(v)\n    .match(/\\s([^\\]]+)\\]/)\n    .pop()\n    .toLowerCase();\nconst isProperty = new RegExp(`^(\"[^\"]+\"|${propertyRegex})$`);\nconst ignoreTypes = [\"string\", \"number\", \"boolean\", \"null\"];\nconst isArray = /^\\[\\d*\\]$/;\nconst arrayHasIndex = /^\\[(\\d+)\\]$/;\nconst isEscaped = /^\".+\"$/;\nconst isArrayProp = /(^\\[\\d*\\]$|^\\d+$)/;\nfunction convertToIndex(index) {\n    return parseInt(index.replace(/^(\\[|\\]$)/, \"\"));\n}\nfunction removeEscape(property) {\n    return isEscaped.test(property)\n        ? property.replace(/(^\"|\"$)/g, \"\")\n        : property;\n}\nfunction insert(array, index, value) {\n    if (array.length <= index) {\n        array[index] = value;\n    }\n    else {\n        array.splice(index, 0, value);\n    }\n}\nfunction select(workingSet, query) {\n    const nextSet = [];\n    workingSet.forEach((d) => nextSet.push(...get(d[0], query, ReturnType.ALL)));\n    return nextSet;\n}\nfunction addToArray(result, index, value, force) {\n    const target = result[0];\n    // append item?\n    if (/^\\[\\]$/.test(index)) {\n        target.push(value);\n        const i = target.length - 1;\n        return [target[i], i, target, `${result[3]}/${i}}`];\n    }\n    // merge array item?\n    if (force == null &&\n        getType(target[index]) === \"object\" &&\n        getType(value) === \"object\") {\n        Object.assign(target[index], value);\n        return [target[index], index, target, `${result[3]}/${index}}`];\n    }\n    if (force === set.INSERT_ITEMS ||\n        (force == null && arrayHasIndex.test(index))) {\n        const arrayIndex = convertToIndex(index);\n        insert(target, arrayIndex, value);\n        return [\n            target[arrayIndex],\n            arrayIndex,\n            target,\n            `${result[3]}/${arrayIndex}}`,\n        ];\n    }\n    if (force === set.REPLACE_ITEMS || force == null) {\n        const arrayIndex = convertToIndex(index);\n        target[arrayIndex] = value;\n        return [\n            target[arrayIndex],\n            arrayIndex,\n            target,\n            `${result[3]}/${arrayIndex}}`,\n        ];\n    }\n    throw new Error(`Unknown array index '${index}' with force-option '${force}'`);\n}\nfunction create(workingSet, query, keyIsArray, force) {\n    query = removeEscape(query);\n    return workingSet\n        .filter((o) => {\n        // replacing or inserting array\n        if (Array.isArray(o[0]) && isArrayProp.test(query)) {\n            return true;\n        }\n        return ignoreTypes.includes(getType(o[0][query])) === false;\n    })\n        .map((r) => {\n        const container = keyIsArray ? [] : {};\n        const o = r[0];\n        const containerType = getType(container);\n        const itemType = getType(o[query]);\n        if (Array.isArray(o) && itemType !== containerType) {\n            return addToArray(r, query, container, force);\n        }\n        o[query] = o[query] || container;\n        return [o[query], query, o, `${r[3]}/${query}`];\n    });\n}\nexport var InsertMode;\n(function (InsertMode) {\n    InsertMode[\"REPLACE_ITEMS\"] = \"replace\";\n    InsertMode[\"INSERT_ITEMS\"] = \"insert\";\n})(InsertMode || (InsertMode = {}));\n// for all array-indices within path, replace the values, ignoring insertion syntax /[1]/\nset.REPLACE_ITEMS = InsertMode.REPLACE_ITEMS;\n// for all array-indices within path, insert the values, ignoring replace syntax /1/\nset.INSERT_ITEMS = InsertMode.INSERT_ITEMS;\n// set.MERGE_ITEMS = \"merge\";\n/**\n * Runs query on input data and assigns a value to query-results.\n * @param data - input data\n * @param queryString - json-query string\n * @param value - value to assign\n * @param [force] - whether to replace or insert into arrays\n */\nexport function set(data, queryString, value, force) {\n    if (queryString == null) {\n        return cp(data);\n    }\n    queryString = queryString.replace(/(\\/$)/g, \"\");\n    if (queryString === \"\") {\n        return cp(value);\n    }\n    const result = cp(data);\n    let workingSet = [[result, null, null, \"#\"]];\n    const path = split(queryString);\n    const property = path.pop();\n    const arrayWithoutIndex = isArray.test(property) && arrayHasIndex.test(property) === false;\n    if (isProperty.test(property) === false || arrayWithoutIndex) {\n        throw new Error(`Unsupported query '${queryString}' ending with non-property`);\n    }\n    path.forEach((query, index) => {\n        if (\"__proto__\" === query ||\n            \"prototyped\" === query ||\n            \"constructor\" === query) {\n            return;\n        }\n        if (isProperty.test(query) === false) {\n            workingSet = select(workingSet, query);\n            return;\n        }\n        // process property & missing data-structure\n        const nextKey = index >= path.length - 1 ? property : path[index + 1];\n        const insertArray = isArrayProp.test(nextKey);\n        workingSet = create(workingSet, query, insertArray, force);\n    });\n    workingSet.forEach((r) => {\n        let targetValue = value;\n        if (getType(value) === \"function\") {\n            targetValue = value(r[3], property, r[0], `${r[3]}/${property}`);\n        }\n        const d = r[0];\n        if (Array.isArray(d)) {\n            addToArray(r, property, targetValue, force);\n        }\n        else {\n            const unescapedProp = removeEscape(property);\n            if (\"__proto__\" === unescapedProp ||\n                \"prototyped\" === unescapedProp ||\n                \"constructor\" === unescapedProp) {\n                return;\n            }\n            d[unescapedProp] = targetValue;\n        }\n    });\n    return result;\n}\n", "import { remove as removePointer, removeUndefinedItems, } from \"@sagold/json-pointer\";\nimport { get, ReturnType } from \"./get\";\nimport { PARENT_INDEX, POINTER_INDEX } from \"./interpreter/keys\";\n/**\n * Runs query on input data and removes matching properties from results\n * @param data - input data\n * @param queryString - json-query string\n * @param [returnRemoved] - if true, will returned removed properties, else input-data is removed\n */\nexport function remove(data, queryString, returnRemoved = false) {\n    const removed = [];\n    const matches = get(data, queryString, ReturnType.ALL);\n    matches.forEach(function (match) {\n        removed.push(match[0]);\n        removePointer(data, match[POINTER_INDEX], true);\n    });\n    matches.forEach(function (match) {\n        if (Array.isArray(match[PARENT_INDEX])) {\n            removeUndefinedItems(match[PARENT_INDEX]);\n        }\n    });\n    return returnRemoved ? removed : data;\n}\n", "const Types = {\n    $ref: {\n        type: false\n    },\n    allOf: {\n        type: false,\n        definitions: [\"allOf/*\"]\n    },\n    anyOf: {\n        type: false,\n        definitions: [\"anyOf/*\"]\n    },\n    array: {\n        type: true,\n        // ignore additionalItems:TypeDef, when items:TypeDef\n        definitions: [\n            \"allOf/*\",\n            \"anyOf/*\",\n            \"oneOf/*\",\n            \"not\",\n            \"items\",\n            \"items/*\",\n            \"additionalItems\"\n        ],\n        validationKeywords: [\"minItems\", \"maxItems\", \"uniqueItems\"],\n        keywords: [\"items\", \"additionalItems\", \"minItems\", \"maxItems\", \"uniqueItems\"]\n    },\n    boolean: {\n        type: true\n    },\n    enum: {\n        type: false\n    },\n    integer: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minimum\", \"maximum\", \"multipleOf\"]\n    },\n    not: {\n        type: false,\n        definitions: [\"not\"]\n    },\n    number: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minimum\", \"maximum\", \"multipleOf\"]\n    },\n    null: {\n        type: true\n    },\n    object: {\n        type: true,\n        // patternProperties also validate properties\n        // dependencies:(string, TypeDef) extend current TypeDef\n        // additional Properties validate only remaining properties (after properties & pattern)\n        definitions: [\n            \"allOf/*\",\n            \"anyOf/*\",\n            \"oneOf/*\",\n            \"not\",\n            \"properties/*\",\n            \"additionalProperties\",\n            \"patternProperties/*\",\n            \"dependencies/*\"\n        ],\n        validationKeywords: [\"minProperties\", \"maxProperties\", \"required\"],\n        keywords: [\n            \"properties\",\n            \"additionalProperties\",\n            \"patternProperties\",\n            \"dependencies\",\n            \"minProperties\",\n            \"maxProperties\",\n            \"required\"\n        ]\n    },\n    oneOf: {\n        type: false,\n        definitions: [\"oneOf/*\"]\n    },\n    string: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minLength\", \"maxLength\", \"pattern\"]\n    }\n};\nexport default Types;\n", "import types from \"./types\";\nimport { isObject } from \"../utils/isObject\";\nconst typeKeywords = Object.keys(types).filter((id) => types[id].type === false);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @throws Error    on multiple matches (invalid schema)\n *\n * Returns the type id of a schema object\n * @param schema\n * @return type id, if found\n */\nexport default function getTypeId(schema) {\n    if (isObject(schema) === false) {\n        return undefined;\n    }\n    if (schema.enum) {\n        return \"enum\";\n    }\n    const type = schema.type;\n    if (Array.isArray(type) || types[type]) {\n        return type;\n    }\n    const ids = typeKeywords.filter((type) => schema[type]);\n    if (ids.length === 1) {\n        return ids[0];\n    }\n    if (ids.length === 0) {\n        // @expensive, guess type object\n        for (let i = 0, l = types.object.keywords.length; i < l; i += 1) {\n            const keyword = types.object.keywords[i];\n            if (hasOwnProperty.call(schema, keyword)) {\n                // eslint-disable-line\n                return \"object\";\n            }\n        }\n        // @expensive, guess type array\n        for (let i = 0, l = types.array.keywords.length; i < l; i += 1) {\n            const keyword = types.array.keywords[i];\n            if (hasOwnProperty.call(schema, keyword)) {\n                // eslint-disable-line\n                return \"array\";\n            }\n        }\n        return undefined;\n    }\n    throw new Error(`Mutiple typeIds [${ids.join(\", \")}] matched in ${JSON.stringify(schema)}`);\n}\n", "/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\nconst suffixes = /(#|\\/)+$/;\nconst trailingHash = /#$/;\nconst isDomain = /^[^:]+:\\/\\/[^/]+\\//;\nconst trailingFragments = /\\/[^/]*$/;\nconst idAndPointer = /#.*$/;\nexport default function joinScope(previous, id) {\n    if (previous == null && id == null) {\n        return \"#\";\n    }\n    if (id == null) {\n        return previous.replace(trailingHash, \"\");\n    }\n    if (previous == null) {\n        return id.replace(trailingHash, \"\");\n    }\n    if (id[0] === \"#\") {\n        return `${previous.replace(idAndPointer, \"\")}${id.replace(suffixes, \"\")}`;\n    }\n    if (isDomain.test(id)) {\n        return id.replace(trailingHash, \"\");\n    }\n    return `${previous.replace(trailingFragments, \"\")}/${id.replace(trailingHash, \"\")}`;\n}\n", "import { get } from \"@sagold/json-pointer\";\nimport splitRef from \"./splitRef\";\nimport getTypeOf from \"../getTypeOf\";\nconst suffixes = /(#|\\/)+$/g;\nconst isObject = (val) => getTypeOf(val) === \"object\";\n// 1. combined is known\n// 2. base or pointer is known\n// 3. base + pointer is known\nexport default function getRef(context, rootSchema, $ref) {\n    if (isObject($ref)) {\n        $ref = $ref.__ref || $ref.$ref;\n    }\n    if ($ref == null) {\n        return rootSchema;\n    }\n    let schema;\n    // is it a known $ref?\n    const $remote = $ref.replace(suffixes, \"\");\n    if (context.remotes[$remote]) {\n        schema = context.remotes[$remote];\n        if (schema && schema.$ref) {\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        return schema;\n    }\n    if (context.ids[$ref]) {\n        schema = get(rootSchema, context.ids[$ref]);\n        if (schema && schema.$ref) {\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        return schema;\n    }\n    // is it a ref with host/pointer?\n    const fragments = splitRef($ref);\n    if (fragments.length === 0) {\n        return rootSchema;\n    }\n    if (fragments.length === 1) {\n        $ref = fragments[0];\n        if (context.remotes[$ref]) {\n            schema = context.remotes[$ref];\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        if (context.ids[$ref]) {\n            schema = get(rootSchema, context.ids[$ref]);\n            if (schema && schema.$ref) {\n                return getRef(context, rootSchema, schema.$ref);\n            }\n            return schema;\n        }\n    }\n    if (fragments.length === 2) {\n        const base = fragments[0];\n        $ref = fragments[1];\n        if (context.remotes[base]) {\n            if (context.remotes[base].getRef) {\n                return context.remotes[base].getRef($ref);\n            }\n            // console.log(\"warning: uncompiled remote - context may be wrong\", base);\n            return getRef(context, context.remotes[base], $ref);\n        }\n        if (context.ids[base]) {\n            return getRef(context, get(rootSchema, context.ids[base]), $ref);\n        }\n    }\n    schema = get(rootSchema, context.ids[$ref] || $ref);\n    if (schema && schema.$ref) {\n        return getRef(context, rootSchema, schema.$ref);\n    }\n    return schema;\n}\n", "const suffixes = /(#|\\/)+$/g;\nconst emptyValues = [\"\", null, \"#\"];\nexport default function splitRef($ref) {\n    if (emptyValues.includes($ref)) {\n        return [];\n    }\n    $ref = $ref.replace(suffixes, \"\");\n    if ($ref.indexOf(\"#\") === -1) {\n        return [$ref.replace(suffixes, \"\")];\n    }\n    if ($ref.indexOf(\"#\") === 0) {\n        return [$ref.replace(suffixes, \"\")];\n    }\n    const result = $ref.split(\"#\");\n    result[0] = result[0].replace(suffixes, \"\");\n    result[1] = `#${result[1].replace(suffixes, \"\")}`;\n    return result;\n}\n", "/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\nimport { eachSchema } from \"../eachSchema\";\nimport joinScope from \"./joinScope\";\nimport getRef from \"./getRef\";\nimport { get } from \"@sagold/json-pointer\";\nconst COMPILED = \"__compiled\";\nconst COMPILED_REF = \"__ref\";\nconst GET_REF = \"getRef\";\nconst GET_ROOT = \"getRoot\";\nconst suffixes = /(#|\\/)+$/g;\n/**\n * compiles the input root schema for `$ref` resolution and returns it again\n * @attention this modifies input schema but maintains data-structure and thus returns\n * the same object with JSON.stringify\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param draft\n * @param schemaToCompile - json-schema to compile\n * @param [rootSchema] - compiled root json-schema to use for definitions resolution\n * @param [force] = false - force compile json-schema\n * @return compiled input json-schema\n */\nexport default function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    if (!schemaToCompile || schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    }\n    const context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    // flag this schema as compiled\n    Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });\n    // add getRef-helper to this object\n    Object.defineProperty(compiledSchema, GET_REF, {\n        enumerable: false,\n        value: getRef.bind(null, context, compiledSchema)\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (schemaToCompile !== rootSchema) {\n        Object.defineProperty(compiledSchema, \"definitions\", {\n            enumerable: false,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, schemaToCompile.definitions, schemaToCompile.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.id.startsWith(\"http\") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, \"\");\n                const parentSchema = get(compiledSchema, parentPointer);\n                schema.id = (_a = parentSchema.id) !== null && _a !== void 0 ? _a : schema.id;\n            }\n            context.ids[schema.id.replace(suffixes, \"\")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log(\"compiled ref\", scope, schema.$ref, \"=>\", joinScope(scope, schema.$ref));\n        }\n    });\n    // console.log(JSON.stringify(context.ids, null, 2));\n    return compiledSchema;\n}\n", "import compile from \"./compile\";\nexport default compile;\n", "import getTypeOf from \"./getTypeOf\";\n/**\n * Iterates over data, retrieving its schema\n *\n * @param draft - validator\n * @param data - the data to iterate\n * @param callback - will be called with (schema, data, pointer) on each item\n * @param [schema] - the schema matching the data. Defaults to rootSchema\n * @param [pointer] - pointer to current data. Default to rootPointer\n */\nexport function each(draft, data, callback, schema = draft.rootSchema, pointer = \"#\") {\n    schema = draft.resolveRef(schema);\n    callback(schema, data, pointer);\n    const dataType = getTypeOf(data);\n    if (dataType === \"object\") {\n        Object.keys(data).forEach((key) => {\n            const nextSchema = draft.step(key, schema, data, pointer); // not save\n            const next = data[key]; // save\n            draft.each(next, callback, nextSchema, `${pointer}/${key}`);\n        });\n    }\n    else if (dataType === \"array\") {\n        data.forEach((next, key) => {\n            const nextSchema = draft.step(key, schema, data, pointer);\n            draft.each(next, callback, nextSchema, `${pointer}/${key}`);\n        });\n    }\n}\n", "/* eslint no-invalid-this: 0 */\nimport { createCustomError } from \"../utils/createCustomError\";\nconst errors = {\n    additionalItemsError: createCustomError(\"AdditionalItemsError\"),\n    additionalPropertiesError: createCustomError(\"AdditionalPropertiesError\"),\n    anyOfError: createCustomError(\"AnyOfError\"),\n    allOfError: createCustomError(\"AllOfError\"),\n    constError: createCustomError(\"ConstError\"),\n    containsError: createCustomError(\"ContainsError\"),\n    containsArrayError: createCustomError(\"ContainsArrayError\"),\n    containsAnyError: createCustomError(\"ContainsAnyError\"),\n    enumError: createCustomError(\"EnumError\"),\n    forbiddenPropertyError: createCustomError(\"ForbiddenPropertyError\"),\n    formatURLError: createCustomError(\"FormatURLError\"),\n    formatURIError: createCustomError(\"FormatURIError\"),\n    formatURIReferenceError: createCustomError(\"FormatURIReferenceError\"),\n    formatURITemplateError: createCustomError(\"FormatURITemplateError\"),\n    formatDateError: createCustomError(\"FormatDateError\"),\n    formatDateTimeError: createCustomError(\"FormatDateTimeError\"),\n    formatEmailError: createCustomError(\"FormatEmailError\"),\n    formatHostnameError: createCustomError(\"FormatHostnameError\"),\n    formatIPV4Error: createCustomError(\"FormatIPV4Error\"),\n    formatIPV4LeadingZeroError: createCustomError(\"FormatIPV4LeadingZeroError\"),\n    formatIPV6Error: createCustomError(\"FormatIPV6Error\"),\n    formatIPV6LeadingZeroError: createCustomError(\"FormatIPV6LeadingZeroError\"),\n    formatJsonPointerError: createCustomError(\"FormatJsonPointerError\"),\n    formatRegExError: createCustomError(\"FormatRegExError\"),\n    formatTimeError: createCustomError(\"FormatTimeError\"),\n    invalidSchemaError: createCustomError(\"InvalidSchemaError\"),\n    invalidDataError: createCustomError(\"InvalidDataError\"),\n    invalidTypeError: createCustomError(\"InvalidTypeError\"),\n    invalidPropertyNameError: createCustomError(\"InvalidPropertyNameError\"),\n    maximumError: createCustomError(\"MaximumError\"),\n    maxItemsError: createCustomError(\"MaxItemsError\"),\n    maxLengthError: createCustomError(\"MaxLengthError\"),\n    maxPropertiesError: createCustomError(\"MaxPropertiesError\"),\n    minimumError: createCustomError(\"MinimumError\"),\n    minItemsError: createCustomError(\"MinItemsError\"),\n    minItemsOneError: createCustomError(\"MinItemsOneError\"),\n    minLengthError: createCustomError(\"MinLengthError\"),\n    minLengthOneError: createCustomError(\"MinLengthOneError\"),\n    minPropertiesError: createCustomError(\"MinPropertiesError\"),\n    missingDependencyError: createCustomError(\"MissingDependencyError\"),\n    missingOneOfPropertyError: createCustomError(\"MissingOneOfPropertyError\"),\n    multipleOfError: createCustomError(\"MultipleOfError\"),\n    multipleOneOfError: createCustomError(\"MultipleOneOfError\"),\n    noAdditionalPropertiesError: createCustomError(\"NoAdditionalPropertiesError\"),\n    notError: createCustomError(\"NotError\"),\n    oneOfError: createCustomError(\"OneOfError\"),\n    oneOfPropertyError: createCustomError(\"OneOfPropertyError\"),\n    patternError: createCustomError(\"PatternError\"),\n    patternPropertiesError: createCustomError(\"PatternPropertiesError\"),\n    requiredPropertyError: createCustomError(\"RequiredPropertyError\"),\n    schemaWarning: createCustomError(\"SchemaWarning\"),\n    typeError: createCustomError(\"TypeError\"),\n    undefinedValueError: createCustomError(\"UndefinedValueError\"),\n    uniqueItemsError: createCustomError(\"UniqueItemsError\"),\n    unknownPropertyError: createCustomError(\"UnknownPropertyError\"),\n    valueNotEmptyError: createCustomError(\"ValueNotEmptyError\")\n};\nexport default errors;\n", "import validUrl from \"valid-url\";\nimport { parse as parseIdnEmail } from \"smtp-address-parser\";\n// referenced\n// https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n// https://gist.github.com/marcelotmelo/b67f58a08bee6c2468f8\nconst isValidDateTime = new RegExp(\"^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\\\.[0-9]+)?(([Zz])|([\\\\+|\\\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$\");\nconst isValidIPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nconst isValidIPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\nconst isValidHostname = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/;\nconst matchDate = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\n// const matchTime = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst matchTime = /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst isValidJsonPointer = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst isValidRelativeJsonPointer = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\nconst isValidURIRef = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nconst isValidURITemplate = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n// Default Json-Schema formats: date-time, email, hostname, ipv4, ipv6, uri, uriref\nconst formatValidators = {\n    date: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n        const matches = value.match(matchDate);\n        if (!matches) {\n            return draft.errors.formatDateTimeError({ value, pointer, schema });\n        }\n        const year = +matches[1];\n        const month = +matches[2];\n        const day = +matches[3];\n        // https://tools.ietf.org/html/rfc3339#appendix-C\n        const isLeapYear = year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        if (month >= 1 &&\n            month <= 12 &&\n            day >= 1 &&\n            day <= (month == 2 && isLeapYear ? 29 : DAYS[month])) {\n            return undefined;\n        }\n        return draft.errors.formatDateError({ value, pointer, schema });\n    },\n    \"date-time\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value === \"\" || isValidDateTime.test(value)) {\n            if (new Date(value).toString() === \"Invalid Date\") {\n                return draft.errors.formatDateTimeError({ value, pointer, schema });\n            }\n            return undefined;\n        }\n        return draft.errors.formatDateTimeError({ value, pointer, schema });\n    },\n    email: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        // taken from https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\n        if (value[0] === '\"') {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        const [name, host, ...rest] = value.split(\"@\");\n        if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (name[0] === \".\" || name.endsWith(\".\") || name.includes(\"..\")) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name)) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (!host.split(\".\").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part))) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        return undefined;\n    },\n    /**\n     * @draft 7\n     * [RFC6531] https://json-schema.org/draft-07/json-schema-validation.html#RFC6531\n     */\n    \"idn-email\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        try {\n            parseIdnEmail(value);\n            return undefined;\n        }\n        catch (e) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n    },\n    hostname: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        if (value === \"\" || isValidHostname.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatHostnameError({ value, pointer, schema });\n    },\n    ipv4: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value && value[0] === \"0\") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return draft.errors.formatIPV4LeadingZeroError({ value, pointer, schema });\n        }\n        if (value.length <= 15 && isValidIPV4.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatIPV4Error({ value, pointer, schema });\n    },\n    ipv6: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value && value[0] === \"0\") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return draft.errors.formatIPV6LeadingZeroError({ value, pointer, schema });\n        }\n        if (value.length <= 45 && isValidIPV6.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatIPV6Error({ value, pointer, schema });\n    },\n    \"json-pointer\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidJsonPointer.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatJsonPointerError({ value, pointer, schema });\n    },\n    \"relative-json-pointer\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidRelativeJsonPointer.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatJsonPointerError({ value, pointer, schema });\n    },\n    regex: (draft, schema, value, pointer) => {\n        if (typeof value === \"string\" && /\\\\Z$/.test(value) === false) {\n            try {\n                new RegExp(value);\n                return undefined;\n            }\n            catch (e) { } // eslint-disable-line no-empty\n            return draft.errors.formatRegExError({ value, pointer, schema });\n        }\n        // v7 tests, ignore non-regex values\n        if (typeof value === \"object\" || typeof value === \"number\" || Array.isArray(value)) {\n            return undefined;\n        }\n        return draft.errors.formatRegExError({ value, pointer, schema });\n    },\n    // hh:mm:ss.sTZD\n    // https://opis.io/json-schema/2.x/formats.html\n    // regex https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch04s07.html\n    time: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        const matches = value.match(matchTime);\n        return matches ? undefined : draft.errors.formatDateTimeError({ value, pointer, schema });\n        // if (!matches) {\n        //     return errors.formatDateTimeError({ value, pointer, schema });\n        // }\n        // const hour = +matches[1];\n        // const minute = +matches[2];\n        // const second = +matches[3];\n        // const timeZone = !!matches[5];\n        // if (\n        //     ((hour <= 23 && minute <= 59 && second <= 59) ||\n        //         (hour == 23 && minute == 59 && second == 60)) &&\n        //     timeZone\n        // ) {\n        //     return undefined;\n        // }\n        // return errors.formatTimeError({ value, pointer, schema });\n    },\n    uri: (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (validUrl.isUri(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURIError({ value, pointer, schema });\n    },\n    \"uri-reference\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidURIRef.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURIReferenceError({ value, pointer, schema });\n    },\n    \"uri-template\": (draft, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidURITemplate.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURITemplateError({ value, pointer, schema });\n    },\n    url: (draft, schema, value, pointer) => {\n        if (value === \"\" || validUrl.isWebUri(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURLError({ value, pointer, schema });\n    }\n};\nexport default formatValidators;\n", "import gp from \"@sagold/json-pointer\";\nimport { isJsonError } from \"./types\";\nconst emptyObject = {};\n/**\n * Returns the json-schema of a data-json-pointer.\n *\n * To resolve dynamic schema where the type of json-schema is evaluated by\n * its value, a data object has to be passed in options.\n *\n * Per default this function will return `undefined` for valid properties that\n * do not have a defined schema. Use the option `withSchemaWarning: true` to\n * receive an error with `code: schema-warning` containing the location of its\n * last evaluated json-schema.\n *\n * Notes\n *      - uses draft.step to walk through data and schema\n *\n * @param draft\n * @param pointer - json pointer in data to get the json schema for\n * @param [options.data] - the data object, which includes the json pointers value. This is optional, as\n *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema\n * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition\n * @return resolved json-schema object of requested json-pointer location or json-error\n */\nexport default function getSchema(draft, options = emptyObject) {\n    const { pointer = \"#\", data, schema = draft.rootSchema, withSchemaWarning = false } = options;\n    const path = gp.split(pointer);\n    const result = _getSchema(draft, draft.resolveRef(schema), path, \"#\", data);\n    if (!withSchemaWarning && (result === null || result === void 0 ? void 0 : result.code) === \"schema-warning\") {\n        return undefined;\n    }\n    return result;\n}\nfunction _getSchema(draft, schema, path, pointer, data = emptyObject) {\n    if (path.length === 0) {\n        return draft.resolveRef(schema);\n    }\n    const key = path.shift(); // step key\n    schema = draft.step(key, schema, data, pointer); // step schema\n    if (isJsonError(schema)) {\n        return schema;\n    }\n    // @ts-expect-error data\n    data = data[key]; // step data\n    return _getSchema(draft, schema, path, `${pointer}/${key}`, data);\n}\n", "import getTypeOf from \"../getTypeOf\";\nexport function isEmpty(v) {\n    const type = getTypeOf(v);\n    switch (type) {\n        case \"string\":\n        case \"array\":\n            // @ts-expect-error tested as array - could use ts type guard\n            return (v === null || v === void 0 ? void 0 : v.length) === 0;\n        case \"null\":\n        case \"undefined\":\n            return true;\n        case \"object\":\n            return Object.keys(v).length === 0;\n        default:\n            return false;\n    }\n}\n", "/* eslint quote-props: 0, max-statements-per-line: [\"error\", { \"max\": 2 }] */\nimport { resolveOneOfFuzzy } from \"./features/oneOf\";\nimport getTypeOf from \"./getTypeOf\";\nimport merge from \"./utils/merge\";\nimport copy from \"./utils/copy\";\nimport settings from \"./config/settings\";\nimport { isJsonError } from \"./types\";\nimport { isEmpty } from \"./utils/isEmpty\";\nimport { resolveIfSchema } from \"./features/if\";\nimport { mergeAllOfSchema, resolveSchema } from \"./features/allOf\";\nimport { resolveDependencies } from \"./features/dependencies\";\nimport { mergeSchema } from \"./mergeSchema\";\nconst defaultOptions = settings.templateDefaultOptions;\nlet cache;\nfunction shouldResolveRef(schema, pointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return true;\n    }\n    const value = cache[pointer] == null || cache[pointer][$ref] == null ? 0 : cache[pointer][$ref];\n    return value < settings.GET_TEMPLATE_RECURSION_LIMIT;\n}\nfunction resolveRef(draft, schema, pointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return schema;\n    }\n    // @todo pointer + ref is redundant?\n    cache[pointer] = cache[pointer] || {};\n    cache[pointer][$ref] = cache[pointer][$ref] || 0;\n    cache[pointer][$ref] += 1;\n    return draft.resolveRef(schema);\n}\nfunction convertValue(type, value) {\n    if (type === \"string\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof value !== \"string\") {\n        return null;\n    }\n    try {\n        value = JSON.parse(value);\n        if (typeof value === type) {\n            return value;\n        }\n    }\n    catch (e) { } // eslint-disable-line no-empty\n    return null;\n}\n/**\n * Resolves $ref, allOf and anyOf schema-options, returning a combined json-schema.\n * Also returns a pointer-property on schema, that must be used as current pointer.\n *\n * @param draft\n * @param schema\n * @param data\n * @param pointer\n * @return resolved json-schema or input-schema\n */\nfunction createTemplateSchema(draft, schema, data, pointer, opts) {\n    // invalid schema\n    if (getTypeOf(schema) !== \"object\") {\n        return Object.assign({ pointer }, schema);\n    }\n    // return if reached recursion limit\n    if (shouldResolveRef(schema, pointer) === false && data == null) {\n        return false;\n    }\n    // resolve $ref and copy schema\n    let templateSchema = copy(resolveRef(draft, schema, pointer));\n    // @feature anyOf\n    if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {\n        // test if we may resolve\n        if (shouldResolveRef(schema.anyOf[0], `${pointer}/anyOf/0`)) {\n            const resolvedAnyOf = resolveRef(draft, schema.anyOf[0], `${pointer}/anyOf/0`);\n            templateSchema = merge(templateSchema, resolvedAnyOf);\n            // add pointer return-value, if any\n            templateSchema.pointer = schema.anyOf[0].$ref || templateSchema.pointer;\n        }\n        delete templateSchema.anyOf;\n    }\n    // @feature allOf\n    if (Array.isArray(schema.allOf)) {\n        const mayResolve = schema.allOf\n            .map((allOf, index) => shouldResolveRef(allOf, `${pointer}/allOf/${index}`))\n            .reduceRight((next, before) => next && before, true);\n        if (mayResolve) {\n            // before merging all-of, we need to resolve all if-then-else statesments\n            // we need to udpate data on the way to trigger if-then-else schemas sequentially.\n            // Note that this will make if-then-else order-dependent\n            const allOf = [];\n            let extendedData = copy(data);\n            for (let i = 0; i < schema.allOf.length; i += 1) {\n                allOf.push(resolveSchema(draft, schema.allOf[i], extendedData));\n                extendedData = getTemplate(draft, extendedData, { type: schema.type, ...allOf[i] }, `${pointer}/allOf/${i}`, opts);\n            }\n            const resolvedSchema = mergeAllOfSchema(draft, { allOf });\n            if (resolvedSchema) {\n                templateSchema = mergeSchema(templateSchema, resolvedSchema);\n            }\n        }\n    }\n    templateSchema.pointer = templateSchema.pointer || schema.$ref || pointer;\n    return templateSchema;\n}\nconst isJsonSchema = (template) => template && typeof template === \"object\";\n/**\n * Create data object matching the given schema\n *\n * @param draft - json schema draft\n * @param [data] - optional template data\n * @param [schema] - json schema, defaults to rootSchema\n * @return created template data\n */\nfunction getTemplate(draft, data, _schema, pointer, opts) {\n    var _a;\n    if (_schema == null) {\n        throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(data)}`);\n    }\n    if (pointer == null) {\n        throw new Error(\"Missing pointer\");\n    }\n    // resolve $ref references, allOf and first anyOf definitions\n    let schema = createTemplateSchema(draft, _schema, data, pointer, opts);\n    if (!isJsonSchema(schema)) {\n        return undefined;\n    }\n    pointer = schema.pointer;\n    if (schema === null || schema === void 0 ? void 0 : schema.const) {\n        return schema.const;\n    }\n    // @feature oneOf\n    if (Array.isArray(schema.oneOf)) {\n        if (isEmpty(data)) {\n            const type = schema.oneOf[0].type ||\n                schema.type ||\n                (schema.const && typeof schema.const) ||\n                getTypeOf(data);\n            schema = { ...schema.oneOf[0], type };\n        }\n        else {\n            // find correct schema for data\n            const resolvedSchema = resolveOneOfFuzzy(draft, data, schema);\n            if (isJsonError(resolvedSchema)) {\n                if (data != null && opts.removeInvalidData !== true) {\n                    return data;\n                }\n                // override\n                schema = schema.oneOf[0];\n                data = undefined;\n            }\n            else {\n                resolvedSchema.type = (_a = resolvedSchema.type) !== null && _a !== void 0 ? _a : schema.type;\n                schema = resolvedSchema;\n            }\n        }\n    }\n    // @todo Array.isArray(schema.type)\n    // -> hasDefault? return\n    // if not -> pick first types\n    if (!isJsonSchema(schema) || schema.type == null) {\n        return undefined;\n    }\n    // @attention - very special case to support file instances\n    if (data instanceof File) {\n        return data;\n    }\n    const type = Array.isArray(schema.type)\n        ? selectType(schema.type, data, schema.default)\n        : schema.type;\n    // reset invalid type\n    const javascriptTypeOfData = getTypeOf(data);\n    if (data != null &&\n        javascriptTypeOfData !== type &&\n        !(javascriptTypeOfData === \"number\" && type === \"integer\")) {\n        data = convertValue(type, data);\n    }\n    if (TYPE[type] == null) {\n        // in case we could not resolve the type\n        // (schema-type could not be resolved and returned an error)\n        if (opts.removeInvalidData) {\n            return undefined;\n        }\n        return data;\n    }\n    const templateData = TYPE[type](draft, schema, data, pointer, opts);\n    return templateData;\n}\nfunction selectType(types, data, defaultValue) {\n    if (data == undefined) {\n        if (defaultValue != null) {\n            const defaultType = getTypeOf(defaultValue);\n            if (types.includes(defaultType)) {\n                return defaultType;\n            }\n        }\n        return types[0];\n    }\n    const dataType = getTypeOf(data);\n    if (types.includes(dataType)) {\n        return dataType;\n    }\n    return types[0];\n}\nconst TYPE = {\n    null: (draft, schema, data) => getDefault(schema, data, null),\n    string: (draft, schema, data) => getDefault(schema, data, \"\"),\n    number: (draft, schema, data) => getDefault(schema, data, 0),\n    integer: (draft, schema, data) => getDefault(schema, data, 0),\n    boolean: (draft, schema, data) => getDefault(schema, data, false),\n    object: (draft, schema, data, pointer, opts) => {\n        var _a;\n        const template = schema.default === undefined ? {} : schema.default;\n        const d = {}; // do not assign data here, to keep ordering from json-schema\n        const required = (opts.extendDefaults === false && schema.default !== undefined) ? [] : ((_a = schema.required) !== null && _a !== void 0 ? _a : []);\n        if (schema.properties) {\n            Object.keys(schema.properties).forEach((key) => {\n                const value = data == null || data[key] == null ? template[key] : data[key];\n                const isRequired = required.includes(key);\n                // Omit adding a property if it is not required or optional props should be added\n                if (value != null || isRequired || opts.addOptionalProps) {\n                    d[key] = getTemplate(draft, value, schema.properties[key], `${pointer}/properties/${key}`, opts);\n                }\n            });\n        }\n        // @feature dependencies\n        // has to be done after resolving properties so dependency may trigger\n        let dependenciesSchema = resolveDependencies(draft, schema, d);\n        if (dependenciesSchema) {\n            dependenciesSchema = mergeSchema(schema, dependenciesSchema);\n            delete dependenciesSchema.dependencies;\n            const dependencyData = getTemplate(draft, data, dependenciesSchema, `${pointer}/dependencies`, opts);\n            Object.assign(d, dependencyData);\n        }\n        if (data) {\n            if (opts.removeInvalidData === true &&\n                (schema.additionalProperties === false ||\n                    getTypeOf(schema.additionalProperties) === \"object\")) {\n                if (getTypeOf(schema.additionalProperties) === \"object\") {\n                    Object.keys(data).forEach((key) => {\n                        if (d[key] == null) {\n                            // merge valid missing data (additionals) to resulting object\n                            if (draft.isValid(data[key], schema.additionalProperties)) {\n                                d[key] = data[key];\n                            }\n                        }\n                    });\n                }\n            }\n            else {\n                // merge any missing data (additionals) to resulting object\n                Object.keys(data).forEach((key) => d[key] == null && (d[key] = data[key]));\n            }\n        }\n        // @feature if-then-else\n        const ifSchema = resolveIfSchema(draft, schema, d);\n        if (ifSchema) {\n            const additionalData = getTemplate(draft, d, { type: \"object\", ...ifSchema }, pointer, opts);\n            Object.assign(d, additionalData);\n        }\n        // returns object, which is ordered by json-schema\n        return d;\n    },\n    // build array type of items, ignores additionalItems\n    array: (draft, schema, data, pointer, opts) => {\n        var _a, _b;\n        if (schema.items == null) {\n            return data || []; // items are undefined\n        }\n        const template = schema.default === undefined ? [] : schema.default;\n        const d = data || template;\n        const minItems = (opts.extendDefaults === false && schema.default !== undefined) ? 0 : (schema.minItems || 0);\n        // build defined set of items\n        if (Array.isArray(schema.items)) {\n            for (let i = 0, l = Math.max(minItems !== null && minItems !== void 0 ? minItems : 0, (_b = (_a = schema.items) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); i < l; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], schema.items[i], `${pointer}/items/${i}`, opts);\n            }\n            return d;\n        }\n        // abort if the schema is invalid\n        if (getTypeOf(schema.items) !== \"object\") {\n            return d;\n        }\n        // resolve allOf and first anyOf definition\n        const templateSchema = createTemplateSchema(draft, schema.items, data, pointer, opts);\n        if (templateSchema === false) {\n            return d;\n        }\n        pointer = templateSchema.pointer || pointer;\n        // build data for first oneOf-schema\n        if (templateSchema.oneOf && d.length === 0) {\n            const oneOfSchema = templateSchema.oneOf[0];\n            for (let i = 0; i < minItems; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], oneOfSchema, `${pointer}/oneOf/0`, opts);\n            }\n            return d;\n        }\n        // complete data selecting correct oneOf-schema\n        if (templateSchema.oneOf && d.length > 0) {\n            const itemCount = Math.max(minItems, d.length);\n            for (let i = 0; i < itemCount; i += 1) {\n                let value = d[i] == null ? template[i] : d[i];\n                let one = resolveOneOfFuzzy(draft, value, templateSchema);\n                if (one == null || isJsonError(one)) {\n                    // schema could not be resolved or data is invalid\n                    if (value != null && opts.removeInvalidData !== true) {\n                        // keep invalid value\n                        d[i] = value;\n                    }\n                    else {\n                        // replace invalid value\n                        value = undefined;\n                        one = templateSchema.oneOf[0];\n                        d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);\n                    }\n                }\n                else {\n                    // schema is valid\n                    d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);\n                }\n            }\n            return d;\n        }\n        // build data from items-definition\n        if (templateSchema.type) {\n            for (let i = 0, l = Math.max(minItems, d.length); i < l; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], templateSchema, `${pointer}/items`, opts);\n            }\n            return d;\n        }\n        return d;\n    }\n};\nfunction getDefault(schema, templateValue, initValue) {\n    if (templateValue != null) {\n        return templateValue;\n    }\n    else if (schema.const) {\n        return schema.const;\n    }\n    else if (schema.default === undefined && Array.isArray(schema.enum)) {\n        return schema.enum[0];\n    }\n    else if (schema.default === undefined) {\n        return initValue;\n    }\n    return schema.default;\n}\nexport default (draft, data, schema = draft.rootSchema, opts) => {\n    cache = {};\n    if (opts) {\n        return getTemplate(draft, data, schema, \"#\", { ...defaultOptions, ...opts });\n    }\n    return getTemplate(draft, data, schema, \"#\", defaultOptions);\n};\n", "/**\n * Test if the data is valid according to the given schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param [schema] - json schema\n * @param [pointer] - json pointer pointing to value\n * @return if schema does match given value\n */\nexport default function isValid(draft, value, schema = draft.rootSchema, pointer = \"#\") {\n    return draft.validate(value, schema, pointer).length === 0;\n}\n", "/* eslint no-bitwise: 0 */\n/**\n * taken from punycode@2.1.0\n *\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param string The Unicode input string (UCS-2).\n * @returns The new array of code points.\n */\nexport default function ucs2decode(string) {\n    const output = [];\n    let counter = 0;\n    const length = string.length;\n    while (counter < length) {\n        const value = string.charCodeAt(counter++);\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n            // It's a high surrogate, and there is a next character.\n            const extra = string.charCodeAt(counter++);\n            // eslint-disable-next-line eqeqeq\n            if ((extra & 0xfc00) == 0xdc00) {\n                // Low surrogate.\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            }\n            else {\n                // It's an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                output.push(value);\n                counter--;\n            }\n        }\n        else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n", "/**\n * returns the floating point precision of a decimal number or 0\n */\nexport function getPrecision(value) {\n    const string = `${value}`;\n    const index = string.indexOf(\".\");\n    return index === -1 ? 0 : string.length - (index + 1);\n}\n", "import getTypeOf from \"../getTypeOf\";\nimport settings from \"../config/settings\";\nimport ucs2decode from \"../utils/punycode.ucs2decode\";\nimport { isObject } from \"../utils/isObject\";\nimport { isJsonError } from \"../types\";\nimport { validateAllOf } from \"../features/allOf\";\nimport { validateAnyOf } from \"../features/anyOf\";\nimport { validateDependencies } from \"../features/dependencies\";\nimport { validateOneOf } from \"../features/oneOf\";\nimport { getPrecision } from \"../utils/getPrecision\";\nimport deepEqual from \"fast-deep-equal\";\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasProperty = (value, property) => !(value[property] === undefined || !hasOwnProperty.call(value, property));\n// list of validation keywords: http://json-schema.org/latest/json-schema-validation.html#rfc.section.5\nconst KeywordValidation = {\n    additionalProperties: (draft, schema, value, pointer) => {\n        if (schema.additionalProperties === true || schema.additionalProperties == null) {\n            return undefined;\n        }\n        if (getTypeOf(schema.patternProperties) === \"object\" &&\n            schema.additionalProperties === false) {\n            // this is an arrangement with patternProperties. patternProperties validate before additionalProperties:\n            // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#index-5\n            return undefined;\n        }\n        const errors = [];\n        let receivedProperties = Object.keys(value).filter((prop) => settings.propertyBlacklist.includes(prop) === false);\n        const expectedProperties = Object.keys(schema.properties || {});\n        if (getTypeOf(schema.patternProperties) === \"object\") {\n            // filter received properties by matching patternProperties\n            const patterns = Object.keys(schema.patternProperties).map((pattern) => new RegExp(pattern));\n            receivedProperties = receivedProperties.filter((prop) => {\n                for (let i = 0; i < patterns.length; i += 1) {\n                    if (patterns[i].test(prop)) {\n                        return false; // remove\n                    }\n                }\n                return true;\n            });\n        }\n        // adds an error for each an unexpected property\n        for (let i = 0, l = receivedProperties.length; i < l; i += 1) {\n            const property = receivedProperties[i];\n            if (expectedProperties.indexOf(property) === -1) {\n                const additionalIsObject = isObject(schema.additionalProperties);\n                // additionalProperties { oneOf: [] }\n                if (additionalIsObject && Array.isArray(schema.additionalProperties.oneOf)) {\n                    const result = draft.resolveOneOf(value[property], schema.additionalProperties, `${pointer}/${property}`);\n                    if (isJsonError(result)) {\n                        errors.push(draft.errors.additionalPropertiesError({\n                            pointer,\n                            schema: schema.additionalProperties,\n                            value,\n                            property: receivedProperties[i],\n                            properties: expectedProperties,\n                            // pass all validation errors\n                            errors: result.data.errors\n                        }));\n                    }\n                    else {\n                        errors.push(...draft.validate(value[property], result, pointer));\n                    }\n                    // additionalProperties {}\n                }\n                else if (additionalIsObject) {\n                    errors.push(...draft.validate(value[property], schema.additionalProperties, `${pointer}/${property}`));\n                }\n                else {\n                    errors.push(draft.errors.noAdditionalPropertiesError({\n                        pointer,\n                        schema,\n                        value,\n                        property: receivedProperties[i],\n                        properties: expectedProperties\n                    }));\n                }\n            }\n        }\n        return errors;\n    },\n    allOf: validateAllOf,\n    anyOf: validateAnyOf,\n    dependencies: validateDependencies,\n    enum: (draft, schema, value, pointer) => {\n        const type = getTypeOf(value);\n        if (type === \"object\" || type === \"array\") {\n            const valueStr = JSON.stringify(value);\n            for (let i = 0; i < schema.enum.length; i += 1) {\n                if (JSON.stringify(schema.enum[i]) === valueStr) {\n                    return undefined;\n                }\n            }\n        }\n        else if (schema.enum.includes(value)) {\n            return undefined;\n        }\n        return draft.errors.enumError({ pointer, schema, value, values: schema.enum });\n    },\n    format: (draft, schema, value, pointer) => {\n        if (draft.validateFormat[schema.format]) {\n            const errors = draft.validateFormat[schema.format](draft, schema, value, pointer);\n            return errors;\n        }\n        // fail silently if given format is not defined\n        return undefined;\n    },\n    items: (draft, schema, value, pointer) => {\n        // @draft >= 7 bool schema\n        if (schema.items === false) {\n            if (Array.isArray(value) && value.length === 0) {\n                return undefined;\n            }\n            return draft.errors.invalidDataError({ pointer, value, schema });\n        }\n        const errors = [];\n        for (let i = 0; i < value.length; i += 1) {\n            const itemData = value[i];\n            // @todo reevaluate: incomplete schema is created here\n            const itemSchema = draft.step(i, schema, value, pointer);\n            if (isJsonError(itemSchema)) {\n                return [itemSchema];\n            }\n            const itemErrors = draft.validate(itemData, itemSchema, `${pointer}/${i}`);\n            errors.push(...itemErrors);\n        }\n        return errors;\n    },\n    maximum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                value,\n                pointer,\n                schema\n            });\n        }\n        if (schema.maximum && schema.exclusiveMaximum === true && schema.maximum === value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    maxItems: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maxItems)) {\n            return undefined;\n        }\n        if (schema.maxItems < value.length) {\n            return draft.errors.maxItemsError({\n                maximum: schema.maxItems,\n                length: value.length,\n                schema,\n                value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    maxLength: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maxLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.maxLength < lengthOfString) {\n            return draft.errors.maxLengthError({\n                maxLength: schema.maxLength,\n                length: lengthOfString,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    maxProperties: (draft, schema, value, pointer) => {\n        const propertyCount = Object.keys(value).length;\n        if (isNaN(schema.maxProperties) === false && schema.maxProperties < propertyCount) {\n            return draft.errors.maxPropertiesError({\n                maxProperties: schema.maxProperties,\n                length: propertyCount,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minLength: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.minLength > lengthOfString) {\n            if (schema.minLength === 1) {\n                return draft.errors.minLengthOneError({\n                    minLength: schema.minLength,\n                    length: lengthOfString,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return draft.errors.minLengthError({\n                minLength: schema.minLength,\n                length: lengthOfString,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minimum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        if (schema.exclusiveMinimum === true && schema.minimum === value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minItems: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minItems)) {\n            return undefined;\n        }\n        if (schema.minItems > value.length) {\n            if (schema.minItems === 1) {\n                return draft.errors.minItemsOneError({\n                    minItems: schema.minItems,\n                    length: value.length,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return draft.errors.minItemsError({\n                minItems: schema.minItems,\n                length: value.length,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minProperties: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minProperties)) {\n            return undefined;\n        }\n        const propertyCount = Object.keys(value).length;\n        if (schema.minProperties > propertyCount) {\n            return draft.errors.minPropertiesError({\n                minProperties: schema.minProperties,\n                length: propertyCount,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    multipleOf: (draft, schema, value, pointer) => {\n        if (isNaN(schema.multipleOf) || typeof value !== \"number\") {\n            return undefined;\n        }\n        const valuePrecision = getPrecision(value);\n        const multiplePrecision = getPrecision(schema.multipleOf);\n        if (valuePrecision > multiplePrecision) {\n            // value with higher precision then multipleOf-precision can never be multiple\n            return draft.errors.multipleOfError({\n                multipleOf: schema.multipleOf,\n                value,\n                pointer,\n                schema\n            });\n        }\n        const precision = Math.pow(10, multiplePrecision);\n        const val = Math.round(value * precision);\n        const multiple = Math.round(schema.multipleOf * precision);\n        if ((val % multiple) / precision !== 0) {\n            return draft.errors.multipleOfError({\n                multipleOf: schema.multipleOf,\n                value,\n                pointer,\n                schema\n            });\n        }\n        // maybe also check overflow\n        // https://stackoverflow.com/questions/1815367/catch-and-compute-overflow-during-multiplication-of-two-large-integers\n        return undefined;\n    },\n    not: (draft, schema, value, pointer) => {\n        const errors = [];\n        if (draft.validate(value, schema.not, pointer).length === 0) {\n            errors.push(draft.errors.notError({ value, not: schema.not, pointer, schema }));\n        }\n        return errors;\n    },\n    oneOf: validateOneOf,\n    pattern: (draft, schema, value, pointer) => {\n        const pattern = new RegExp(schema.pattern, \"u\");\n        if (pattern.test(value) === false) {\n            return draft.errors.patternError({\n                pattern: schema.pattern,\n                description: schema.patternExample || schema.pattern,\n                received: value,\n                schema,\n                value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (draft, schema, value, pointer) => {\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== \"object\") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    const valErrors = draft.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(draft.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    schema,\n                    value,\n                    patterns: Object.keys(pp).join(\",\")\n                }));\n            }\n        });\n        return errors;\n    },\n    properties: (draft, schema, value, pointer) => {\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (hasProperty(value, key)) {\n                const itemSchema = draft.step(key, schema, value, pointer);\n                const keyErrors = draft.validate(value[key], itemSchema, `${pointer}/${key}`);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword\n    propertiesRequired: (draft, schema, value, pointer) => {\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (value[key] === undefined) {\n                errors.push(draft.errors.requiredPropertyError({ key, pointer, schema, value }));\n            }\n            else {\n                const itemSchema = draft.step(key, schema, value, pointer);\n                const keyErrors = draft.validate(value[key], itemSchema, `${pointer}/${key}`);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    required: (draft, schema, value, pointer) => {\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            if (!hasProperty(value, property)) {\n                return draft.errors.requiredPropertyError({\n                    key: property,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return undefined;\n        });\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword\n    requiredNotEmpty: (draft, schema, value, pointer) => {\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            if (value[property] == null || value[property] === \"\") {\n                return draft.errors.valueNotEmptyError({\n                    property,\n                    pointer: `${pointer}/${property}`,\n                    schema,\n                    value\n                });\n            }\n            return undefined;\n        });\n    },\n    uniqueItems: (draft, schema, value, pointer) => {\n        if ((Array.isArray(value) && schema.uniqueItems) === false) {\n            return undefined;\n        }\n        const duplicates = [];\n        const errors = [];\n        value.forEach((item, index) => {\n            for (let i = index + 1; i < value.length; i += 1) {\n                if (deepEqual(item, value[i]) && !duplicates.includes(i)) {\n                    errors.push(draft.errors.uniqueItemsError({\n                        pointer: `${pointer}/${i}`,\n                        duplicatePointer: `${pointer}/${index}`,\n                        arrayPointer: pointer,\n                        value: JSON.stringify(item),\n                        schema\n                    }));\n                    duplicates.push(i);\n                }\n            }\n        });\n        return errors;\n    }\n};\nexport default KeywordValidation;\n", "import getTypeOf from \"./getTypeOf\";\nimport { isObject } from \"./utils/isObject\";\n/**\n * Create a simple json schema for the given input data\n * @param  data - data to get json schema for\n */\nexport default function createSchemaOf(data) {\n    if (data === undefined) {\n        return undefined;\n    }\n    const schema = {\n        type: getTypeOf(data)\n    };\n    if (schema.type === \"object\" && isObject(data)) {\n        schema.properties = {};\n        Object.keys(data).forEach((key) => (schema.properties[key] = createSchemaOf(data[key])));\n    }\n    if (schema.type === \"array\" && Array.isArray(data)) {\n        if (data.length === 1) {\n            schema.items = createSchemaOf(data[0]);\n        }\n        else {\n            schema.items = data.map(createSchemaOf);\n        }\n    }\n    return schema;\n}\n", "import getTypeOf from \"./getTypeOf\";\nimport createSchemaOf from \"./createSchemaOf\";\nimport { isJsonError } from \"./types\";\nimport { reduceSchema } from \"./reduceSchema\";\nconst stepType = {\n    array: (draft, key, schema, data, pointer) => {\n        const itemValue = data === null || data === void 0 ? void 0 : data[key];\n        const itemsType = getTypeOf(schema.items);\n        if (itemsType === \"object\") {\n            // @spec: ignore additionalItems, when items is schema-object\n            return (reduceSchema(draft, schema.items, itemValue, `${pointer}/${key}`) ||\n                draft.resolveRef(schema.items));\n        }\n        if (itemsType === \"array\") {\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === true) {\n                return createSchemaOf(itemValue);\n            }\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === false) {\n                return draft.errors.invalidDataError({\n                    key,\n                    value: itemValue,\n                    pointer,\n                    schema\n                });\n            }\n            if (schema.items[key]) {\n                return draft.resolveRef(schema.items[key]);\n            }\n            if (schema.additionalItems === false) {\n                return draft.errors.additionalItemsError({\n                    key,\n                    value: itemValue,\n                    pointer,\n                    schema\n                });\n            }\n            if (schema.additionalItems === true || schema.additionalItems === undefined) {\n                return createSchemaOf(itemValue);\n            }\n            if (getTypeOf(schema.additionalItems) === \"object\") {\n                return schema.additionalItems;\n            }\n            throw new Error(`Invalid schema ${JSON.stringify(schema, null, 2)} for ${JSON.stringify(data, null, 2)}`);\n        }\n        if (schema.additionalItems !== false && itemValue) {\n            // @todo reevaluate: incomplete schema is created here\n            // @todo support additionalItems: {schema}\n            return createSchemaOf(itemValue);\n        }\n        return new Error(`Invalid array schema for ${key} at ${pointer}`);\n    },\n    object: (draft, key, schema, data, pointer) => {\n        var _a;\n        schema = reduceSchema(draft, schema, data, pointer);\n        // @feature properties\n        const property = (_a = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _a === void 0 ? void 0 : _a[key];\n        if (property !== undefined) {\n            // @todo patternProperties also validate properties\n            // @feature boolean schema\n            if (property === false) {\n                return draft.errors.forbiddenPropertyError({\n                    property: key,\n                    value: data,\n                    pointer,\n                    schema\n                });\n            }\n            else if (property === true) {\n                return createSchemaOf(data === null || data === void 0 ? void 0 : data[key]);\n            }\n            const targetSchema = draft.resolveRef(property);\n            if (isJsonError(targetSchema)) {\n                return targetSchema;\n            }\n            // check if there is a oneOf selection, which must be resolved\n            if (targetSchema && Array.isArray(targetSchema.oneOf)) {\n                // @special case: this is a mix of a schema and optional definitions\n                // we resolve the schema here and add the original schema to `oneOfSchema`\n                const resolvedSchema = draft.resolveOneOf(data[key], targetSchema, `${pointer}/${key}`);\n                for (const p in targetSchema) {\n                    if (p !== \"oneOf\" && resolvedSchema[p] === undefined) {\n                        resolvedSchema[p] = targetSchema[p];\n                    }\n                }\n                return resolvedSchema;\n            }\n            // resolved schema or error\n            if (targetSchema) {\n                return targetSchema;\n            }\n        }\n        // @feature patternProperties\n        const { patternProperties } = schema;\n        if (getTypeOf(patternProperties) === \"object\") {\n            // find matching property key\n            let regex;\n            const patterns = Object.keys(patternProperties);\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                regex = new RegExp(patterns[i]);\n                if (regex.test(key)) {\n                    return patternProperties[patterns[i]];\n                }\n            }\n        }\n        // @feature additionalProperties\n        const { additionalProperties } = schema;\n        if (getTypeOf(additionalProperties) === \"object\") {\n            return schema.additionalProperties;\n        }\n        if (data && (additionalProperties === undefined || additionalProperties === true)) {\n            return createSchemaOf(data[key]);\n        }\n        return draft.errors.unknownPropertyError({\n            property: key,\n            value: data,\n            pointer: `${pointer}`,\n            schema\n        });\n    }\n};\n/**\n * Returns the json-schema of the given object property or array item.\n * e.g. it steps by one key into the data\n *\n *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n *  returns the correct schema.\n *\n * @param  draft      - validator\n * @param  key       - property-name or array-index\n * @param  schema    - json schema of current data\n * @param  data      - parent of key\n * @param  [pointer] - pointer to schema and data (parent of key)\n * @return Schema or Error if failed resolving key\n */\nexport default function step(draft, key, schema, data, pointer = \"#\") {\n    var _a;\n    const typeOfData = getTypeOf(data);\n    let schemaType = (_a = schema.type) !== null && _a !== void 0 ? _a : typeOfData;\n    // @draft >= 4 ?\n    if (Array.isArray(schemaType)) {\n        if (!schemaType.includes(typeOfData)) {\n            return draft.errors.typeError({\n                value: data,\n                pointer,\n                expected: schema.type,\n                received: typeOfData,\n                schema\n            });\n        }\n        schemaType = typeOfData;\n    }\n    const stepFunction = stepType[schemaType];\n    if (stepFunction) {\n        const schemaResult = stepFunction(draft, `${key}`, schema, data, pointer);\n        if (schemaResult === undefined) {\n            return draft.errors.schemaWarning({\n                pointer,\n                value: data,\n                schema,\n                key\n            });\n        }\n        return schemaResult;\n    }\n    return new Error(`Unsupported schema type ${schema.type} for key ${key}`);\n}\n", "import { isJsonError } from \"./types\";\n/**\n * Returns a list of possible child-schemas for the given property key. In case of a oneOf selection, multiple schemas\n * could be added at the given property (e.g. item-index), thus an array of options is returned. In all other cases\n * a list with a single item will be returned\n *\n * @param draft        - draft to use\n * @param property    - parent schema of following property\n * @param [schema]    - parent schema of following property\n * @return\n */\nexport default function getChildSchemaSelection(draft, property, schema = draft.rootSchema) {\n    var _a;\n    if (schema.oneOf) {\n        return schema.oneOf.map((item) => draft.resolveRef(item));\n    }\n    if ((_a = schema.items) === null || _a === void 0 ? void 0 : _a.oneOf) {\n        return schema.items.oneOf.map((item) => draft.resolveRef(item));\n    }\n    const result = draft.step(property, schema, {}, \"#\");\n    if (isJsonError(result)) {\n        return result;\n    }\n    return [result];\n}\n", "/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-draft.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst typeValidators = {\n    array: (draft, schema, value, pointer) => draft.typeKeywords.array\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    object: (draft, schema, value, pointer) => draft.typeKeywords.object\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    string: (draft, schema, value, pointer) => draft.typeKeywords.string\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    integer: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    number: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    boolean: (draft, schema, value, pointer) => draft.typeKeywords.boolean\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    null: (draft, schema, value, pointer) => draft.typeKeywords.null\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer))\n};\nexport default typeValidators;\n", "import getTypeOf from \"./getTypeOf\";\nimport { errorOrPromise } from \"./utils/filter\";\nimport flattenArray from \"./utils/flattenArray\";\nimport { isJsonError } from \"./types\";\nimport equal from \"fast-deep-equal\";\nfunction getJsonSchemaType(value, expectedType) {\n    const jsType = getTypeOf(value);\n    if (jsType === \"number\" &&\n        (expectedType === \"integer\" ||\n            (Array.isArray(expectedType) && expectedType.includes(\"integer\")))) {\n        return Number.isInteger(value) || isNaN(value) ? \"integer\" : \"number\";\n    }\n    return jsType;\n}\n/**\n * Validates data with json schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param [schema] - json schema, defaults to rootSchema\n * @param [pointer] - json pointer pointing to value (used for error-messages only)\n * @return list of errors or empty\n */\nexport default function validate(draft, value, schema = draft.rootSchema, pointer = \"#\") {\n    schema = draft.resolveRef(schema);\n    // @draft >= 07\n    if (getTypeOf(schema) === \"boolean\") {\n        if (schema) {\n            return [];\n        }\n        return [draft.errors.invalidDataError({ pointer, schema, value })];\n    }\n    if (isJsonError(schema)) {\n        return [schema];\n    }\n    // @draft >= 6 const\n    if (schema.const !== undefined) {\n        if (equal(schema.const, value)) {\n            return [];\n        }\n        return [draft.errors.constError({ pointer, schema, value, expected: schema.const })];\n    }\n    const receivedType = getJsonSchemaType(value, schema.type);\n    const expectedType = schema.type || receivedType;\n    if (receivedType !== expectedType &&\n        (!Array.isArray(expectedType) || !expectedType.includes(receivedType))) {\n        return [\n            draft.errors.typeError({\n                pointer,\n                schema,\n                value,\n                received: receivedType,\n                expected: expectedType\n            })\n        ];\n    }\n    if (draft.validateType[receivedType] == null) {\n        return [draft.errors.invalidTypeError({ pointer, schema, value, receivedType })];\n    }\n    // get type validation results\n    const errors = flattenArray(draft.validateType[receivedType](draft, schema, value, pointer));\n    return errors.filter(errorOrPromise); // ignore promises here\n}\n", "import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../compileSchema\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../validation/keyword\";\nimport merge from \"../utils/merge\";\nimport { resolveAllOf } from \"../features/allOf\";\nimport { resolveAnyOf } from \"../features/anyOf\";\nimport { resolveOneOf } from \"../features/oneOf\";\nimport resolveRef from \"../resolveRef.strict\";\nimport step from \"../step\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport TYPES from \"../validation/type\";\nimport validate from \"../validate\";\nimport { Draft } from \"../draft\";\nimport settings from \"../config/settings\";\nconst draft04Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"enum\", \"not\", \"allOf\", \"anyOf\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"minProperties\",\n            \"maxProperties\",\n            \"patternProperties\",\n            \"properties\",\n            \"required\",\n            \"not\",\n            \"oneOf\",\n            \"allOf\",\n            \"anyOf\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft04 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft04Config, config), schema);\n    }\n}\nexport { Draft04, draft04Config };\n", "import { eachSchema } from \"../../eachSchema\";\n// import remotes from \"../../../remotes\";\nimport joinScope from \"../../compile/joinScope\";\nimport getRef from \"../../compile/getRef\";\nimport { get } from \"@sagold/json-pointer\";\nconst COMPILED = \"__compiled\";\nconst COMPILED_REF = \"__ref\";\nconst GET_REF = \"getRef\";\nconst GET_ROOT = \"getRoot\";\nconst suffixes = /(#|\\/)+$/g;\n/**\n * @draft starting with _draft 06_ keyword `id` has been renamed to `$id`\n *\n * compiles the input root schema for $ref resolution and returns it again\n * @attention this modifies input schema but maintains object-structure\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param rootSchema root json-schema ($id, defs, ... ) to compile\n * @param [force] = false force compile json-schema\n * @return compiled json-schema\n */\nexport default function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    // @ts-expect-error incomplete JsonSchema type\n    if (schemaToCompile === true || schemaToCompile === false || schemaToCompile === undefined) {\n        return schemaToCompile;\n    }\n    if (schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    } // eslint-disable-line\n    const context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });\n    Object.defineProperty(compiledSchema, GET_REF, {\n        enumerable: false,\n        value: getRef.bind(null, context, compiledSchema)\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (compiledSchema !== rootSchema) {\n        Object.defineProperty(compiledSchema, \"$defs\", {\n            enumerable: true,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, compiledSchema.definitions, compiledSchema.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.$id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.$id.startsWith(\"http\") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, \"\");\n                const parentSchema = get(compiledSchema, parentPointer);\n                schema.$id = (_a = parentSchema.$id) !== null && _a !== void 0 ? _a : schema.$id;\n            }\n            context.ids[schema.$id.replace(suffixes, \"\")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.$id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log(\"compiled ref\", scope, schema.$ref, \"=>\", joinScope(scope, schema.$ref));\n        }\n    });\n    return compiledSchema;\n}\n", "import Keywords from \"../../validation/keyword\";\nimport getTypeOf from \"../../getTypeOf\";\nimport { validateIf } from \"../../features/if\";\nconst KeywordValidation = {\n    ...Keywords,\n    // @draft >= 6\n    contains: (draft, schema, value, pointer) => {\n        if (schema.contains === false) {\n            return draft.errors.containsArrayError({ pointer, value, schema });\n        }\n        if (schema.contains === true) {\n            if (Array.isArray(value) && value.length === 0) {\n                return draft.errors.containsAnyError({ pointer, value, schema });\n            }\n            return undefined;\n        }\n        if (getTypeOf(schema.contains) !== \"object\") {\n            // ignore invalid schema\n            return undefined;\n        }\n        for (let i = 0; i < value.length; i += 1) {\n            if (draft.isValid(value[i], schema.contains)) {\n                return undefined;\n            }\n        }\n        return draft.errors.containsError({ pointer, schema, value });\n    },\n    exclusiveMaximum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.exclusiveMaximum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMaximum <= value) {\n            return draft.errors.maximumError({\n                maximum: schema.exclusiveMaximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    exclusiveMinimum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.exclusiveMinimum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMinimum >= value) {\n            return draft.errors.minimumError({\n                minimum: schema.exclusiveMinimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    // @feature if-then-else\n    if: validateIf,\n    maximum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minimum: (draft, schema, value, pointer) => {\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (draft, schema, value, pointer) => {\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== \"object\") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    // for a boolean schema `false`, always invalidate\n                    if (patterns[i].patternSchema === false) {\n                        errors.push(draft.errors.patternPropertiesError({\n                            key,\n                            pointer,\n                            patterns: Object.keys(pp).join(\",\"),\n                            schema,\n                            value\n                        }));\n                        return;\n                    }\n                    const valErrors = draft.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(draft.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    patterns: Object.keys(pp).join(\",\"),\n                    schema,\n                    value\n                }));\n            }\n        });\n        return errors;\n    },\n    // @draft >= 6\n    propertyNames: (draft, schema, value, pointer) => {\n        // bool schema\n        if (schema.propertyNames === false) {\n            // empty objects are valid\n            if (Object.keys(value).length === 0) {\n                return undefined;\n            }\n            return draft.errors.invalidPropertyNameError({\n                property: Object.keys(value),\n                pointer,\n                value,\n                schema\n            });\n        }\n        if (schema.propertyNames === true) {\n            return undefined;\n        }\n        if (getTypeOf(schema.propertyNames) !== \"object\") {\n            // ignore invalid schema\n            return undefined;\n        }\n        const errors = [];\n        const properties = Object.keys(value);\n        const propertySchema = { ...schema.propertyNames, type: \"string\" };\n        properties.forEach((prop) => {\n            const validationResult = draft.validate(prop, propertySchema, `${pointer}/${prop}`);\n            if (validationResult.length > 0) {\n                errors.push(draft.errors.invalidPropertyNameError({\n                    property: prop,\n                    pointer,\n                    validationError: validationResult[0],\n                    value: value[prop],\n                    schema\n                }));\n            }\n        });\n        return errors;\n    }\n};\nexport default KeywordValidation;\n", "/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-draft.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst validationType = {\n    array: (draft, schema, value, pointer) => draft.typeKeywords.array\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    object: (draft, schema, value, pointer) => draft.typeKeywords.object\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    string: (draft, schema, value, pointer) => draft.typeKeywords.string\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    integer: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    number: (draft, schema, value, pointer) => draft.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    boolean: (draft, schema, value, pointer) => draft.typeKeywords.boolean\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),\n    null: (draft, schema, value, pointer) => draft.typeKeywords.null\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => draft.validateKeyword[key](draft, schema, value, pointer))\n};\nexport default validationType;\n", "import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../draft06/compile\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../draft06/validation/keyword\";\nimport merge from \"../utils/merge\";\nimport { resolveAllOf } from \"../features/allOf\";\nimport { resolveAnyOf } from \"../features/anyOf\";\nimport { resolveOneOf } from \"../features/oneOf\";\nimport resolveRef from \"../resolveRef.strict\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport step from \"../step\";\nimport TYPES from \"../draft06/validation/type\";\nimport validate from \"../validate\";\nimport { Draft } from \"../draft\";\nimport settings from \"../config/settings\";\nconst draft06Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"contains\",\n            \"enum\",\n            \"if\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"allOf\", \"anyOf\", \"enum\", \"not\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"allOf\",\n            \"anyOf\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxProperties\",\n            \"minProperties\",\n            \"not\",\n            \"oneOf\",\n            \"patternProperties\",\n            \"properties\",\n            \"propertyNames\",\n            \"required\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"enum\",\n            \"exclusiveMaximum\",\n            \"exclusiveMinimum\",\n            \"format\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\",\n            \"allOf\",\n            \"anyOf\",\n            \"if\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft06 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft06Config, config), schema);\n    }\n}\nexport { Draft06, draft06Config };\n", "import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../draft06/compile\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../draft06/validation/keyword\";\nimport merge from \"../utils/merge\";\nimport { resolveAllOf } from \"../features/allOf\";\nimport { resolveAnyOf } from \"../features/anyOf\";\nimport { resolveOneOf } from \"../features/oneOf\";\nimport resolveRef from \"../resolveRef.strict\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport step from \"../step\";\nimport TYPES from \"../draft06/validation/type\";\nimport validate from \"../validate\";\nimport { Draft } from \"../draft\";\nimport settings from \"../config/settings\";\nconst draft07Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"contains\",\n            \"enum\",\n            \"if\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"allOf\", \"anyOf\", \"enum\", \"not\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"allOf\",\n            \"anyOf\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxProperties\",\n            \"minProperties\",\n            \"not\",\n            \"oneOf\",\n            \"patternProperties\",\n            \"properties\",\n            \"propertyNames\",\n            \"required\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"exclusiveMaximum\",\n            \"exclusiveMinimum\",\n            \"format\",\n            \"if\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft07 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft07Config, config), schema);\n    }\n}\nexport { Draft07, draft07Config };\n", "import merge from \"../utils/merge\";\nimport { resolveOneOfFuzzy } from \"../features/oneOf\";\nimport resolveRef from \"../resolveRef.merge\";\nimport { Draft } from \"../draft\";\nimport { draft07Config } from \"../draft07\";\nconst draftJsonEditorConfig = {\n    ...draft07Config,\n    resolveOneOf: resolveOneOfFuzzy,\n    resolveRef\n};\nclass JsonEditor extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draftJsonEditorConfig, config), schema);\n    }\n}\nexport { JsonEditor, draftJsonEditorConfig };\n", "import { syntaxTree } from \"@codemirror/language\";\nimport { TOKENS } from \"../constants.js\";\nimport { findNodeIndexInArrayNode, getWord, isValueNode } from \"./node.js\";\n// adapted from https://discuss.codemirror.net/t/json-pointer-at-cursor-seeking-implementation-critique/4793/3\n// this could be useful for other things later!\nexport function getJsonPointerAt(docText, node) {\n    const path = [];\n    for (let n = node; n === null || n === void 0 ? void 0 : n.parent; n = n.parent) {\n        switch (n.parent.name) {\n            case TOKENS.PROPERTY: {\n                const name = n.parent.getChild(TOKENS.PROPERTY_NAME);\n                if (name) {\n                    path.unshift(getWord(docText, name).replace(/[/~]/g, (v) => v === \"~\" ? \"~0\" : \"~1\"));\n                }\n                break;\n            }\n            case TOKENS.ARRAY: {\n                if (isValueNode(n)) {\n                    const index = findNodeIndexInArrayNode(n.parent, n);\n                    path.unshift(`${index}`);\n                }\n                break;\n            }\n        }\n    }\n    path.unshift(\"\");\n    return path.join(\"/\");\n}\n/**\n * retrieve a JSON pointer for a given position in the editor\n * @group Utilities\n */\nexport const jsonPointerForPosition = (state, pos, side = -1) => {\n    return getJsonPointerAt(state.doc, syntaxTree(state).resolve(pos, side));\n};\n/**\n * retrieve a Map of all the json pointers in a document\n * @group Utilities\n */\nexport const getJsonPointers = (state, mode = \"json4\") => {\n    const json = syntaxTree(state);\n    const pointers = new Map();\n    json.iterate({\n        enter: (type) => {\n            var _a, _b, _c, _d, _e, _f, _g, _h;\n            if (type.name === \"PropertyName\" || type.name === \"Object\") {\n                const pointer = getJsonPointerAt(state.doc, type.node);\n                const { from: keyFrom, to: keyTo } = type.node;\n                // if there's no value, we can't get the valueFrom/to\n                if (!((_b = (_a = type.node) === null || _a === void 0 ? void 0 : _a.nextSibling) === null || _b === void 0 ? void 0 : _b.node)) {\n                    pointers.set(pointer, { keyFrom, keyTo });\n                    return true;\n                }\n                const nextNode = mode === \"json4\"\n                    ? (_d = (_c = type.node) === null || _c === void 0 ? void 0 : _c.nextSibling) === null || _d === void 0 ? void 0 : _d.node\n                    : (_h = (_g = (_f = (_e = type.node) === null || _e === void 0 ? void 0 : _e.nextSibling) === null || _f === void 0 ? void 0 : _f.node) === null || _g === void 0 ? void 0 : _g.nextSibling) === null || _h === void 0 ? void 0 : _h.node;\n                if (!nextNode) {\n                    pointers.set(pointer, { keyFrom, keyTo });\n                    return true;\n                }\n                const { from: valueFrom, to: valueTo } = nextNode;\n                pointers.set(pointer, { keyFrom, keyTo, valueFrom, valueTo });\n                return true;\n            }\n        },\n    });\n    return pointers;\n};\n", "import { snippetCompletion, } from \"@codemirror/autocomplete\";\nimport { syntaxTree } from \"@codemirror/language\";\nimport { debug } from \"./utils/debug.js\";\nimport { findNodeIndexInArrayNode, getChildValueNode, getWord, isPropertyNameNode, isPrimitiveValueNode, stripSurroundingQuotes, getNodeAtPosition, } from \"./utils/node.js\";\nimport { getJSONSchema } from \"./state.js\";\nimport { Draft07, isJsonError } from \"json-schema-library\";\nimport { jsonPointerForPosition } from \"./utils/jsonPointers.js\";\nimport { TOKENS } from \"./constants.js\";\nfunction json5PropertyInsertSnippet(rawWord, value) {\n    if (rawWord.startsWith('\"')) {\n        return `\"${value}\"`;\n    }\n    if (rawWord.startsWith(\"'\")) {\n        return `'${value}'`;\n    }\n    return value;\n}\nclass CompletionCollector {\n    constructor() {\n        this.completions = new Map();\n        this.reservedKeys = new Set();\n    }\n    reserve(key) {\n        this.reservedKeys.add(key);\n    }\n    add(completion) {\n        if (this.reservedKeys.has(completion.label)) {\n            return;\n        }\n        this.completions.set(completion.label, completion);\n    }\n}\nexport class JSONCompletion {\n    constructor(opts) {\n        this.opts = opts;\n        this.schema = null;\n    }\n    doComplete(ctx) {\n        var _a, _b;\n        this.schema = getJSONSchema(ctx.state);\n        if (!this.schema) {\n            // todo: should we even do anything without schema\n            // without taking over the existing mode responsibilties?\n            return [];\n        }\n        const result = {\n            from: ctx.pos,\n            to: ctx.pos,\n            options: [],\n            filter: false, // will be handled manually\n        };\n        const text = ctx.state.doc.sliceString(0);\n        let node = getNodeAtPosition(ctx.state, ctx.pos);\n        // position node word prefix (without quotes) for matching\n        const prefix = ctx.state.sliceDoc(node.from, ctx.pos).replace(/^(\"|')/, \"\");\n        debug.log(\"xxx\", \"node\", node, \"prefix\", prefix, \"ctx\", ctx);\n        // Only show completions if we are filling out a word or right after the starting quote, or if explicitly requested\n        if (!(isPrimitiveValueNode(node) || isPropertyNameNode(node)) &&\n            !ctx.explicit) {\n            return result;\n        }\n        const currentWord = getWord(ctx.state.doc, node);\n        const rawWord = getWord(ctx.state.doc, node, false);\n        // Calculate overwrite range\n        if (node && (isPrimitiveValueNode(node) || isPropertyNameNode(node))) {\n            result.from = node.from;\n            result.to = node.to;\n        }\n        else {\n            const word = ctx.matchBefore(/[A-Za-z0-9._]*/);\n            const overwriteStart = ctx.pos - currentWord.length;\n            debug.log(\"xxx\", \"overwriteStart after\", overwriteStart, \"ctx.pos\", ctx.pos, \"word\", word, \"currentWord\", currentWord, \"=>\", text[overwriteStart - 1], \"..\", text[overwriteStart], \"..\", text);\n            result.from =\n                node.name === TOKENS.INVALID ? (_a = word === null || word === void 0 ? void 0 : word.from) !== null && _a !== void 0 ? _a : ctx.pos : overwriteStart;\n            result.to = ctx.pos;\n        }\n        const collector = new CompletionCollector();\n        let addValue = true;\n        if (isPropertyNameNode(node)) {\n            const parent = node.parent;\n            if (parent) {\n                // get value node from parent\n                const valueNode = getChildValueNode(parent);\n                addValue =\n                    !valueNode ||\n                        (valueNode.name === TOKENS.INVALID &&\n                            valueNode.from - valueNode.to === 0);\n                debug.log(\"xxx\", \"addValue\", addValue, getChildValueNode(parent), node);\n                // find object node\n                node =\n                    (_b = [parent, parent.parent].find((p) => {\n                        if ((p === null || p === void 0 ? void 0 : p.name) === TOKENS.OBJECT) {\n                            return true;\n                        }\n                        return false;\n                    })) !== null && _b !== void 0 ? _b : null;\n            }\n        }\n        debug.log(\"xxx\", node, currentWord, ctx);\n        // proposals for properties\n        if (node &&\n            (node.name === TOKENS.OBJECT || node.name === TOKENS.JSON_TEXT) &&\n            isPropertyNameNode(getNodeAtPosition(ctx.state, ctx.pos))) {\n            // don't suggest keys when the cursor is just before the opening curly brace\n            if (node.from === ctx.pos) {\n                return result;\n            }\n            // property proposals with schema\n            this.getPropertyCompletions(this.schema, ctx, node, collector, addValue, rawWord);\n        }\n        else {\n            // proposals for values\n            const types = {};\n            // value proposals with schema\n            this.getValueCompletions(this.schema, ctx, types, collector);\n        }\n        // handle filtering\n        result.options = Array.from(collector.completions.values()).filter((v) => stripSurroundingQuotes(v.label).startsWith(prefix));\n        debug.log(\"xxx\", \"result\", result, \"prefix\", prefix, \"collector.completions\", collector.completions, \"reservedKeys\", collector.reservedKeys);\n        return result;\n    }\n    applySnippetCompletion(completion) {\n        return snippetCompletion(typeof completion.apply !== \"string\"\n            ? completion.label\n            : completion.apply, completion);\n    }\n    getPropertyCompletions(schema, ctx, node, collector, addValue, rawWord) {\n        // don't suggest properties that are already present\n        const properties = node.getChildren(TOKENS.PROPERTY);\n        debug.log(\"xxx\", \"getPropertyCompletions\", node, ctx, properties);\n        properties.forEach((p) => {\n            const key = getWord(ctx.state.doc, p.getChild(TOKENS.PROPERTY_NAME));\n            collector.reserve(stripSurroundingQuotes(key));\n        });\n        // TODO: Handle separatorAfter\n        // Get matching schemas\n        const schemas = this.getSchemas(schema, ctx);\n        schemas.forEach((s) => {\n            if (typeof s !== \"object\") {\n                return;\n            }\n            const properties = s.properties;\n            if (properties) {\n                Object.entries(properties).forEach(([key, value]) => {\n                    var _a, _b;\n                    if (typeof value === \"object\") {\n                        const description = (_a = value.description) !== null && _a !== void 0 ? _a : \"\";\n                        const type = (_b = value.type) !== null && _b !== void 0 ? _b : \"\";\n                        const typeStr = Array.isArray(type) ? type.toString() : type;\n                        const completion = {\n                            // label is the unquoted key which will be displayed.\n                            label: key,\n                            apply: this.getInsertTextForProperty(key, addValue, rawWord, value),\n                            type: \"property\",\n                            detail: typeStr,\n                            info: description,\n                        };\n                        collector.add(this.applySnippetCompletion(completion));\n                    }\n                });\n            }\n            const propertyNames = s.propertyNames;\n            if (typeof propertyNames === \"object\") {\n                if (propertyNames.enum) {\n                    propertyNames.enum.forEach((v) => {\n                        const label = v === null || v === void 0 ? void 0 : v.toString();\n                        if (label) {\n                            const completion = {\n                                label,\n                                apply: this.getInsertTextForProperty(label, addValue, rawWord),\n                                type: \"property\",\n                            };\n                            collector.add(this.applySnippetCompletion(completion));\n                        }\n                    });\n                }\n                if (propertyNames.const) {\n                    const label = propertyNames.const.toString();\n                    const completion = {\n                        label,\n                        apply: this.getInsertTextForProperty(label, addValue, rawWord),\n                        type: \"property\",\n                    };\n                    collector.add(this.applySnippetCompletion(completion));\n                }\n            }\n        });\n    }\n    // apply is the quoted key which will be applied.\n    // Normally the label needs to match the token\n    // prefix i.e. if the token begins with `\"to`, then the\n    // label needs to have the quotes as well for it to match.\n    // However we are manually filtering the results so we can\n    // just use the unquoted key as the label, which is nicer\n    // and gives us more control.\n    // If no property value is present, then we add the colon as well.\n    // Use snippetCompletion to handle insert value + position cursor e.g. \"key\": \"#{}\"\n    // doc: https://codemirror.net/docs/ref/#autocomplete.snippetCompletion\n    // idea: https://discuss.codemirror.net/t/autocomplete-cursor-position-in-apply-function/4088/3\n    getInsertTextForProperty(key, addValue, rawWord, propertySchema) {\n        var _a;\n        // expand schema property if it is a reference\n        propertySchema = propertySchema\n            ? this.expandSchemaProperty(propertySchema, this.schema)\n            : propertySchema;\n        const isJSON5 = ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.mode) === \"json5\";\n        let resultText = isJSON5\n            ? json5PropertyInsertSnippet(rawWord, key)\n            : `\"${key}\"`;\n        if (!addValue) {\n            return resultText;\n        }\n        resultText += \": \";\n        let value;\n        let nValueProposals = 0;\n        if (typeof propertySchema === \"object\") {\n            if (typeof propertySchema.default !== \"undefined\") {\n                if (!value) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.default, \"\");\n                }\n                nValueProposals++;\n            }\n            else {\n                if (propertySchema.enum) {\n                    if (!value && propertySchema.enum.length === 1) {\n                        value = this.getInsertTextForGuessedValue(propertySchema.enum[0], \"\");\n                    }\n                    nValueProposals += propertySchema.enum.length;\n                }\n                if (typeof propertySchema.const !== \"undefined\") {\n                    if (!value) {\n                        value = this.getInsertTextForGuessedValue(propertySchema.const, \"\");\n                    }\n                    nValueProposals++;\n                }\n                if (Array.isArray(propertySchema.examples) &&\n                    propertySchema.examples.length) {\n                    if (!value) {\n                        value = this.getInsertTextForGuessedValue(propertySchema.examples[0], \"\");\n                    }\n                    nValueProposals += propertySchema.examples.length;\n                }\n                if (value === undefined && nValueProposals === 0) {\n                    let type = Array.isArray(propertySchema.type)\n                        ? propertySchema.type[0]\n                        : propertySchema.type;\n                    if (!type) {\n                        if (propertySchema.properties) {\n                            type = \"object\";\n                        }\n                        else if (propertySchema.items) {\n                            type = \"array\";\n                        }\n                    }\n                    switch (type) {\n                        case \"boolean\":\n                            value = \"#{}\";\n                            break;\n                        case \"string\":\n                            value = isJSON5 ? \"'#{}'\" : '\"#{}\"';\n                            break;\n                        case \"object\":\n                            value = \"{#{}}\";\n                            break;\n                        case \"array\":\n                            value = \"[#{}]\";\n                            break;\n                        case \"number\":\n                        case \"integer\":\n                            value = \"#{0}\";\n                            break;\n                        case \"null\":\n                            value = \"#{null}\";\n                            break;\n                        default:\n                            // always advance the cursor after completing a property\n                            value = \"#{}\";\n                            break;\n                    }\n                }\n            }\n        }\n        if (!value || nValueProposals > 1) {\n            debug.log(\"xxx\", \"value\", value, \"nValueProposals\", nValueProposals, propertySchema);\n            value = \"#{}\";\n        }\n        return resultText + value;\n    }\n    getInsertTextForGuessedValue(value, separatorAfter = \"\") {\n        switch (typeof value) {\n            case \"object\":\n                if (value === null) {\n                    return \"${null}\" + separatorAfter;\n                }\n                return this.getInsertTextForValue(value, separatorAfter);\n            case \"string\": {\n                let snippetValue = JSON.stringify(value);\n                snippetValue = snippetValue.substr(1, snippetValue.length - 2); // remove quotes\n                snippetValue = this.getInsertTextForPlainText(snippetValue); // escape \\ and }\n                return '\"${' + snippetValue + '}\"' + separatorAfter;\n            }\n            case \"number\":\n            case \"boolean\":\n                return \"${\" + JSON.stringify(value) + \"}\" + separatorAfter;\n        }\n        return this.getInsertTextForValue(value, separatorAfter);\n    }\n    getInsertTextForPlainText(text) {\n        return text.replace(/[\\\\$}]/g, \"\\\\$&\"); // escape $, \\ and }\n    }\n    getInsertTextForValue(value, separatorAfter) {\n        const text = JSON.stringify(value, null, \"\\t\");\n        if (text === \"{}\") {\n            return \"{#{}}\" + separatorAfter;\n        }\n        else if (text === \"[]\") {\n            return \"[#{}]\" + separatorAfter;\n        }\n        return this.getInsertTextForPlainText(text + separatorAfter);\n    }\n    getValueCompletions(schema, ctx, types, collector) {\n        let node = syntaxTree(ctx.state).resolveInner(ctx.pos, -1);\n        let valueNode = null;\n        let parentKey = undefined;\n        debug.log(\"xxx\", \"getValueCompletions\", node, ctx);\n        if (node && isPrimitiveValueNode(node)) {\n            valueNode = node;\n            node = node.parent;\n        }\n        if (!node) {\n            this.addSchemaValueCompletions(schema, types, collector);\n            return;\n        }\n        if (node.name === TOKENS.PROPERTY) {\n            const keyNode = node.getChild(TOKENS.PROPERTY_NAME);\n            if (keyNode) {\n                parentKey = getWord(ctx.state.doc, keyNode);\n                node = node.parent;\n            }\n        }\n        debug.log(\"xxx\", \"node\", node, \"parentKey\", parentKey);\n        if (node && (parentKey !== undefined || node.name === TOKENS.ARRAY)) {\n            // Get matching schemas\n            const schemas = this.getSchemas(schema, ctx);\n            for (const s of schemas) {\n                if (typeof s !== \"object\") {\n                    return;\n                }\n                if (node.name === TOKENS.ARRAY && s.items) {\n                    let c = collector;\n                    if (s.uniqueItems) {\n                        c = Object.assign(Object.assign({}, c), { add(completion) {\n                                if (!c.completions.has(completion.label)) {\n                                    collector.add(completion);\n                                }\n                            },\n                            reserve(key) {\n                                collector.reserve(key);\n                            } });\n                    }\n                    if (Array.isArray(s.items)) {\n                        let arrayIndex = 0;\n                        if (valueNode) {\n                            // get index of next node in array\n                            const foundIdx = findNodeIndexInArrayNode(node, valueNode);\n                            if (foundIdx >= 0) {\n                                arrayIndex = foundIdx;\n                            }\n                        }\n                        const itemSchema = s.items[arrayIndex];\n                        if (itemSchema) {\n                            this.addSchemaValueCompletions(itemSchema, types, c);\n                        }\n                    }\n                    else {\n                        this.addSchemaValueCompletions(s.items, types, c);\n                    }\n                }\n                if (parentKey !== undefined) {\n                    let propertyMatched = false;\n                    if (s.properties) {\n                        const propertySchema = s.properties[parentKey];\n                        if (propertySchema) {\n                            propertyMatched = true;\n                            this.addSchemaValueCompletions(propertySchema, types, collector);\n                        }\n                    }\n                    if (s.patternProperties && !propertyMatched) {\n                        for (const pattern of Object.keys(s.patternProperties)) {\n                            const regex = this.extendedRegExp(pattern);\n                            if (regex === null || regex === void 0 ? void 0 : regex.test(parentKey)) {\n                                propertyMatched = true;\n                                const propertySchema = s.patternProperties[pattern];\n                                if (propertySchema) {\n                                    this.addSchemaValueCompletions(propertySchema, types, collector);\n                                }\n                            }\n                        }\n                    }\n                    if (s.additionalProperties && !propertyMatched) {\n                        const propertySchema = s.additionalProperties;\n                        this.addSchemaValueCompletions(propertySchema, types, collector);\n                    }\n                }\n                if (types[\"boolean\"]) {\n                    this.addBooleanValueCompletion(true, collector);\n                    this.addBooleanValueCompletion(false, collector);\n                }\n                if (types[\"null\"]) {\n                    this.addNullValueCompletion(collector);\n                }\n            }\n        }\n    }\n    addSchemaValueCompletions(schema, types, collector) {\n        if (typeof schema === \"object\") {\n            this.addEnumValueCompletions(schema, collector);\n            this.addDefaultValueCompletions(schema, collector);\n            this.collectTypes(schema, types);\n            if (Array.isArray(schema.allOf)) {\n                schema.allOf.forEach((s) => this.addSchemaValueCompletions(s, types, collector));\n            }\n            if (Array.isArray(schema.anyOf)) {\n                schema.anyOf.forEach((s) => this.addSchemaValueCompletions(s, types, collector));\n            }\n            if (Array.isArray(schema.oneOf)) {\n                schema.oneOf.forEach((s) => this.addSchemaValueCompletions(s, types, collector));\n            }\n        }\n    }\n    addDefaultValueCompletions(schema, collector, arrayDepth = 0) {\n        let hasProposals = false;\n        if (typeof schema.default !== \"undefined\") {\n            let type = schema.type;\n            let value = schema.default;\n            for (let i = arrayDepth; i > 0; i--) {\n                value = [value];\n                type = \"array\";\n            }\n            const completionItem = {\n                type: type === null || type === void 0 ? void 0 : type.toString(),\n                label: this.getLabelForValue(value),\n                detail: \"Default value\",\n            };\n            collector.add(completionItem);\n            hasProposals = true;\n        }\n        if (Array.isArray(schema.examples)) {\n            schema.examples.forEach((example) => {\n                let type = schema.type;\n                let value = example;\n                for (let i = arrayDepth; i > 0; i--) {\n                    value = [value];\n                    type = \"array\";\n                }\n                collector.add({\n                    type: type === null || type === void 0 ? void 0 : type.toString(),\n                    label: this.getLabelForValue(value),\n                });\n                hasProposals = true;\n            });\n        }\n        if (!hasProposals &&\n            typeof schema.items === \"object\" &&\n            !Array.isArray(schema.items) &&\n            arrayDepth < 5 /* beware of recursion */) {\n            this.addDefaultValueCompletions(schema.items, collector, arrayDepth + 1);\n        }\n    }\n    addEnumValueCompletions(schema, collector) {\n        var _a, _b;\n        if (typeof schema.const !== \"undefined\") {\n            collector.add({\n                type: (_a = schema.type) === null || _a === void 0 ? void 0 : _a.toString(),\n                label: this.getLabelForValue(schema.const),\n                info: schema.description,\n            });\n        }\n        if (Array.isArray(schema.enum)) {\n            for (let i = 0, length = schema.enum.length; i < length; i++) {\n                const enm = schema.enum[i];\n                collector.add({\n                    type: (_b = schema.type) === null || _b === void 0 ? void 0 : _b.toString(),\n                    label: this.getLabelForValue(enm),\n                    info: schema.description,\n                });\n            }\n        }\n    }\n    addBooleanValueCompletion(value, collector) {\n        collector.add({\n            type: \"boolean\",\n            label: value ? \"true\" : \"false\",\n        });\n    }\n    addNullValueCompletion(collector) {\n        collector.add({\n            type: \"null\",\n            label: \"null\",\n        });\n    }\n    collectTypes(schema, types) {\n        if (Array.isArray(schema.enum) || typeof schema.const !== \"undefined\") {\n            return;\n        }\n        const type = schema.type;\n        if (Array.isArray(type)) {\n            type.forEach((t) => (types[t] = true));\n        }\n        else if (type) {\n            types[type] = true;\n        }\n    }\n    getSchemas(schema, ctx) {\n        var _a;\n        const draft = new Draft07(this.schema);\n        let pointer = jsonPointerForPosition(ctx.state, ctx.pos);\n        let subSchema = draft.getSchema({ pointer });\n        if (isJsonError(subSchema)) {\n            subSchema = (_a = subSchema.data) === null || _a === void 0 ? void 0 : _a.schema;\n        }\n        // if we don't have a schema for the current pointer, try the parent pointer\n        if (!subSchema ||\n            subSchema.name === \"UnknownPropertyError\" ||\n            subSchema.enum ||\n            subSchema.type === \"undefined\") {\n            pointer = pointer.replace(/\\/[^/]*$/, \"/\");\n            subSchema = draft.getSchema({ pointer });\n        }\n        debug.log(\"xxx\", \"pointer..\", JSON.stringify(pointer));\n        // For some reason, it returns undefined schema for the root pointer\n        if (!pointer || pointer === \"/\") {\n            return [schema];\n        }\n        // const subSchema = new Draft07(this.schema).getSchema(pointer);\n        debug.log(\"xxx\", \"subSchema..\", subSchema);\n        if (!subSchema) {\n            return [];\n        }\n        if (Array.isArray(subSchema.allOf)) {\n            return [\n                subSchema,\n                ...subSchema.allOf.map((s) => this.expandSchemaProperty(s, schema)),\n            ];\n        }\n        if (Array.isArray(subSchema.oneOf)) {\n            return [\n                subSchema,\n                ...subSchema.oneOf.map((s) => this.expandSchemaProperty(s, schema)),\n            ];\n        }\n        if (Array.isArray(subSchema.anyOf)) {\n            return [\n                subSchema,\n                ...subSchema.anyOf.map((s) => this.expandSchemaProperty(s, schema)),\n            ];\n        }\n        return [subSchema];\n    }\n    expandSchemaProperty(property, schema) {\n        if (typeof property === \"object\" && property.$ref) {\n            const refSchema = this.getReferenceSchema(schema, property.$ref);\n            if (typeof refSchema === \"object\") {\n                const dereferenced = Object.assign(Object.assign({}, property), refSchema);\n                Reflect.deleteProperty(dereferenced, \"$ref\");\n                return dereferenced;\n            }\n        }\n        return property;\n    }\n    getReferenceSchema(schema, ref) {\n        const refPath = ref.split(\"/\");\n        let curReference = schema;\n        refPath.forEach((cur) => {\n            if (!cur) {\n                return;\n            }\n            if (cur === \"#\") {\n                curReference = schema;\n                return;\n            }\n            if (typeof curReference === \"object\") {\n                curReference = curReference[cur];\n            }\n        });\n        return curReference;\n    }\n    getLabelForValue(value) {\n        return JSON.stringify(value);\n    }\n    getValueFromLabel(value) {\n        return JSON.parse(value);\n    }\n    extendedRegExp(pattern) {\n        let flags = \"\";\n        if (pattern.startsWith(\"(?i)\")) {\n            pattern = pattern.substring(4);\n            flags = \"i\";\n        }\n        try {\n            return new RegExp(pattern, flags + \"u\");\n        }\n        catch (e) {\n            // could be an exception due to the 'u ' flag\n            try {\n                return new RegExp(pattern, flags);\n            }\n            catch (e) {\n                // invalid pattern\n                return undefined;\n            }\n        }\n    }\n}\n/**\n * provides a JSON schema enabled autocomplete extension for codemirror\n * @group Codemirror Extensions\n */\nexport function jsonCompletion(opts = {}) {\n    const completion = new JSONCompletion(opts);\n    return function jsonDoCompletion(ctx) {\n        return completion.doComplete(ctx);\n    };\n}\n/**\n * provides a JSON schema enabled autocomplete extension for codemirror and json5\n * @group Codemirror Extensions\n */\nexport function json5Completion(opts = {}) {\n    const completion = new JSONCompletion(Object.assign(Object.assign({}, opts), { mode: \"json5\" }));\n    return function jsonDoCompletion(ctx) {\n        return completion.doComplete(ctx);\n    };\n}\n", "// a little english-centric utility\n// to join members of an array with commas and \"or\"\nexport const joinWithOr = (arr, getPath) => {\n    const needsComma = arr.length > 2;\n    let data = arr.map((err, i) => {\n        const result = `<code>` + (getPath ? getPath(err) : err) + `</code>`;\n        if (i === arr.length - 1)\n            return \"or \" + result;\n        return result;\n    });\n    if (needsComma) {\n        return data.join(\", \");\n    }\n    return data.join(\" \");\n};\n", "import { json } from \"@codemirror/lang-json\";\nimport { EditorState } from \"@codemirror/state\";\nimport { getJsonPointers } from \"./jsonPointers.js\";\n/**\n * Return parsed data and json pointers for a given codemirror EditorState\n * @group Utilities\n */\nexport function parseJSONDocumentState(state) {\n    let data = null;\n    try {\n        data = JSON.parse(state.doc.toString());\n        // return pointers regardless of whether JSON.parse succeeds\n    }\n    catch (_a) { }\n    const pointers = getJsonPointers(state, \"json4\");\n    return { data, pointers };\n}\n/**\n * Mimics the behavior of `json-source-map`'s `parseJSONDocument` function using codemirror EditorState\n * @group Utilities\n */\nexport function parseJSONDocument(jsonString) {\n    const state = EditorState.create({ doc: jsonString, extensions: [json()] });\n    return parseJSONDocumentState(state);\n}\n", "// export function el(tagName: string, className?: string) {\n//   const e = document.createElement(tagName);\n//   if (className) {\n//     e.classList.add(className);\n//   }\n//   return e;\n// }\nexport function el(tagName, attributes, children = []) {\n    const e = document.createElement(tagName);\n    Object.entries(attributes).forEach(([k, v]) => {\n        if (k === \"text\") {\n            e.innerText = v;\n            return;\n        }\n        if (k === \"inner\") {\n            e.innerHTML = v;\n            return;\n        }\n        e.setAttribute(k, v);\n    });\n    children.forEach((c) => e.appendChild(c));\n    return e;\n}\n", "import { Draft04 } from \"json-schema-library\";\nimport { getJSONSchema, schemaStateField } from \"./state.js\";\nimport { joinWithOr } from \"./utils/formatting.js\";\nimport { parseJSONDocumentState } from \"./utils/parseJSONDocument.js\";\nimport { el } from \"./utils/dom.js\";\n// return an object path that matches with the json-source-map pointer\nconst getErrorPath = (error) => {\n    var _a, _b, _c;\n    // if a pointer is present, return without #\n    if (((_a = error === null || error === void 0 ? void 0 : error.data) === null || _a === void 0 ? void 0 : _a.pointer) && ((_b = error === null || error === void 0 ? void 0 : error.data) === null || _b === void 0 ? void 0 : _b.pointer) !== \"#\") {\n        return error.data.pointer.slice(1);\n    }\n    // return plain data.property if present\n    if ((_c = error === null || error === void 0 ? void 0 : error.data) === null || _c === void 0 ? void 0 : _c.property) {\n        return `/${error.data.property}`;\n    }\n    // else, return the empty pointer to represent the whole document\n    return \"\";\n};\nexport const handleRefresh = (vu) => {\n    return (vu.startState.field(schemaStateField) !== vu.state.field(schemaStateField));\n};\n/**\n * Helper for simpler class instantiaton\n * @group Codemirror Extensions\n */\nexport function jsonSchemaLinter(options) {\n    const validation = new JSONValidation(options);\n    return (view) => {\n        return validation.doValidation(view);\n    };\n}\n// all the error types that apply to a specific key or value\nconst positionalErrors = [\n    \"NoAdditionalPropertiesError\",\n    \"RequiredPropertyError\",\n    \"InvalidPropertyNameError\",\n    \"ForbiddenPropertyError\",\n    \"UndefinedValueError\",\n];\nexport class JSONValidation {\n    constructor(options) {\n        this.schema = null;\n        // rewrite the error message to be more human readable\n        this.rewriteError = (error) => {\n            var _a, _b, _c, _d, _e;\n            const errorData = error === null || error === void 0 ? void 0 : error.data;\n            const errors = errorData === null || errorData === void 0 ? void 0 : errorData.errors;\n            if (error.code === \"one-of-error\" && (errors === null || errors === void 0 ? void 0 : errors.length)) {\n                return `Expected one of ${joinWithOr(errors, (data) => data.data.expected)}`;\n            }\n            if (error.code === \"type-error\") {\n                return `Expected <code>${((_a = error === null || error === void 0 ? void 0 : error.data) === null || _a === void 0 ? void 0 : _a.expected) && Array.isArray((_b = error === null || error === void 0 ? void 0 : error.data) === null || _b === void 0 ? void 0 : _b.expected)\n                    ? joinWithOr((_c = error === null || error === void 0 ? void 0 : error.data) === null || _c === void 0 ? void 0 : _c.expected)\n                    : (_d = error === null || error === void 0 ? void 0 : error.data) === null || _d === void 0 ? void 0 : _d.expected}</code> but received <code>${(_e = error === null || error === void 0 ? void 0 : error.data) === null || _e === void 0 ? void 0 : _e.received}</code>`;\n            }\n            const message = error.message\n                // don't mention root object\n                .replaceAll(\"in `#` \", \"\")\n                .replaceAll(\"/\", \".\")\n                .replaceAll(\"#.\", \"\")\n                // replace backticks with <code> tags\n                .replaceAll(/`([^`]*)`/gm, \"<code>$1</code>\");\n            return message;\n        };\n        this.options = Object.assign({ jsonParser: parseJSONDocumentState }, options);\n        // TODO: support other versions of json schema.\n        // most standard schemas are draft 4 for some reason, probably\n        // backwards compatibility\n        //\n        // ajv did not support draft 4, so I used json-schema-library\n    }\n    get schemaTitle() {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this.schema) === null || _a === void 0 ? void 0 : _a.getSchema()) === null || _b === void 0 ? void 0 : _b.title) !== null && _c !== void 0 ? _c : \"json-schema\";\n    }\n    // validate using view as the linter extension signature requires\n    doValidation(view) {\n        const schema = getJSONSchema(view.state);\n        if (!schema) {\n            return [];\n        }\n        this.schema = new Draft04(schema);\n        if (!this.schema)\n            return [];\n        const text = view.state.doc.toString();\n        // ignore blank json strings\n        if (!text || text.trim().length < 3)\n            return [];\n        const json = this.options.jsonParser(view.state);\n        let errors = [];\n        try {\n            errors = this.schema.validate(json.data);\n        }\n        catch (_a) { }\n        if (!errors.length)\n            return [];\n        // reduce() because we want to filter out errors that don't have a pointer\n        return errors.reduce((acc, error) => {\n            var _a;\n            const pushRoot = () => {\n                const errorString = this.rewriteError(error);\n                acc.push({\n                    from: 0,\n                    to: 0,\n                    message: errorString,\n                    severity: \"error\",\n                    source: this.schemaTitle,\n                    renderMessage: () => {\n                        const dom = el(\"div\", {});\n                        dom.innerHTML = errorString;\n                        return dom;\n                    },\n                });\n            };\n            const errorPath = getErrorPath(error);\n            const pointer = json.pointers.get(errorPath);\n            if ((_a = error.name === \"MaxPropertiesError\") !== null && _a !== void 0 ? _a : error.name === \"MinPropertiesError\") {\n                pushRoot();\n            }\n            if (pointer) {\n                // if the error is a property error, use the key position\n                const isKeyError = positionalErrors.includes(error.name);\n                const errorString = this.rewriteError(error);\n                const from = isKeyError ? pointer.keyFrom : pointer.valueFrom;\n                const to = isKeyError ? pointer.keyTo : pointer.valueTo;\n                // skip error if no from/to value is found\n                if (to !== undefined && from !== undefined) {\n                    acc.push({\n                        from,\n                        to,\n                        // TODO: create a domnode and replace `` with <code></code>\n                        // renderMessage: () => error.message,\n                        message: errorString,\n                        renderMessage: () => {\n                            const dom = el(\"div\", {});\n                            dom.innerHTML = errorString;\n                            return dom;\n                        },\n                        severity: \"error\",\n                        source: this.schemaTitle,\n                    });\n                }\n            }\n            return acc;\n        }, []);\n    }\n}\n", "import { Draft04, isJsonError, } from \"json-schema-library\";\nimport { jsonPointerForPosition } from \"./utils/jsonPointers.js\";\nimport { joinWithOr } from \"./utils/formatting.js\";\nimport { debug } from \"./utils/debug.js\";\nimport { el } from \"./utils/dom.js\";\nimport { getJSONSchema } from \"./state.js\";\n/**\n * provides a JSON schema enabled tooltip extension for codemirror\n * @group Codemirror Extensions\n */\nexport function jsonSchemaHover(options) {\n    const hover = new JSONHover(options);\n    return async function jsonDoHover(view, pos, side) {\n        return hover.doHover(view, pos, side);\n    };\n}\nfunction formatComplexType(schema, type, draft) {\n    return `${type}: ${joinWithOr(schema[type].map((s) => {\n        var _a;\n        return (_a = s.type) !== null && _a !== void 0 ? _a : draft.resolveRef(s).type;\n    }))}`;\n}\nexport class JSONHover {\n    constructor(opts) {\n        this.opts = opts;\n        this.schema = null;\n        this.opts = Object.assign({ parser: JSON.parse }, this.opts);\n    }\n    getDataForCursor(view, pos, side) {\n        const schema = getJSONSchema(view.state);\n        if (!schema) {\n            // todo: should we even do anything without schema\n            // without taking over the existing mode responsibilties?\n            return null;\n        }\n        this.schema = new Draft04(schema);\n        const pointer = jsonPointerForPosition(view.state, pos, side);\n        let data = undefined;\n        // TODO: use the AST tree to return the right hand, data so that we don't have to parse the doc\n        try {\n            data = this.opts.parser(view.state.doc.toString());\n        }\n        catch (_a) { }\n        if (!pointer) {\n            return null;\n        }\n        // if the data is valid, we can infer a type for complex types\n        let subSchema = this.schema.getSchema({\n            pointer,\n            data,\n            withSchemaWarning: true,\n        });\n        if (isJsonError(subSchema)) {\n            if (subSchema === null || subSchema === void 0 ? void 0 : subSchema.data.schema[\"$ref\"]) {\n                subSchema = this.schema.resolveRef(subSchema);\n            }\n            else {\n                subSchema = subSchema === null || subSchema === void 0 ? void 0 : subSchema.data.schema;\n            }\n        }\n        return { schema: subSchema, pointer };\n    }\n    formatMessage(texts) {\n        const { message, typeInfo } = texts;\n        if (message) {\n            return el(\"div\", { class: \"cm6-json-schema-hover\" }, [\n                el(\"div\", {\n                    class: \"cm6-json-schema-hover--description\",\n                    text: message,\n                }),\n                el(\"div\", { class: \"cm6-json-schema-hover--code-wrapper\" }, [\n                    typeInfo.includes(\"<code>\")\n                        ? el(\"div\", {\n                            class: \"cm6-json-schema-hover--code\",\n                            inner: typeInfo,\n                        })\n                        : el(\"code\", {\n                            class: \"cm6-json-schema-hover--code\",\n                            text: typeInfo,\n                        }),\n                ]),\n            ]);\n        }\n        return el(\"div\", { class: \"cm6-json-schema-hover\" }, [\n            el(\"div\", { class: \"cm6-json-schema-hover--code-wrapper\" }, [\n                el(\"code\", { class: \"cm6-json-schema-hover--code\", text: typeInfo }),\n            ]),\n        ]);\n    }\n    getHoverTexts(data, draft) {\n        let typeInfo = null;\n        let message = null;\n        const { schema } = data;\n        if (schema.oneOf) {\n            typeInfo = formatComplexType(schema, \"oneOf\", draft);\n        }\n        if (schema.anyOf) {\n            typeInfo = formatComplexType(schema, \"anyOf\", draft);\n        }\n        if (schema.allOf) {\n            typeInfo = formatComplexType(schema, \"allOf\", draft);\n        }\n        if (schema.type) {\n            typeInfo = Array.isArray(schema.type)\n                ? joinWithOr(schema.type)\n                : schema.type;\n        }\n        if (schema.enum) {\n            typeInfo = `<code>enum</code>: ${joinWithOr(schema.enum)}`;\n        }\n        if (schema.format) {\n            typeInfo += ` <code>format</code>: ${schema.format}`;\n        }\n        if (schema.pattern) {\n            typeInfo += ` <code>pattern</code>: ${schema.pattern}`;\n        }\n        if (schema.description) {\n            message = schema.description;\n        }\n        return { message, typeInfo };\n    }\n    // return hover state for the current json schema property\n    async doHover(view, pos, side) {\n        var _a, _b, _c, _d;\n        const start = pos, end = pos;\n        try {\n            const cursorData = this.getDataForCursor(view, pos, side);\n            // if we don't have a (sub)schema, we can't show anything\n            if (!(cursorData === null || cursorData === void 0 ? void 0 : cursorData.schema))\n                return null;\n            const getHoverTexts = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.getHoverTexts) !== null && _b !== void 0 ? _b : this.getHoverTexts;\n            const hoverTexts = getHoverTexts(cursorData, this.schema);\n            // allow users to override the hover\n            const formatter = (_d = (_c = this.opts) === null || _c === void 0 ? void 0 : _c.formatHover) !== null && _d !== void 0 ? _d : this.formatMessage;\n            const formattedDom = formatter(hoverTexts);\n            return {\n                pos: start,\n                end,\n                arrow: true,\n                // to mimic similar modes for other editors\n                // otherwise, it gets into a z-index battle with completion/etc\n                above: true,\n                create: (view) => {\n                    return {\n                        dom: formattedDom,\n                    };\n                },\n            };\n        }\n        catch (err) {\n            debug.log(err);\n            return null;\n        }\n    }\n}\n", "import { json, jsonLanguage, jsonParseLinter } from \"@codemirror/lang-json\";\nimport { hoverTooltip } from \"@codemirror/view\";\nimport { jsonCompletion } from \"./json-completion.js\";\nimport { handleRefresh, jsonSchemaLinter } from \"./json-validation.js\";\nimport { jsonSchemaHover } from \"./json-hover.js\";\nimport { stateExtensions } from \"./state.js\";\nimport { linter } from \"@codemirror/lint\";\n/**\n * Full featured cm6 extension for json, including `@codemirror/lang-json`\n * @group Bundled Codemirror Extensions\n */\nexport function jsonSchema(schema) {\n    return [\n        json(),\n        linter(jsonParseLinter()),\n        linter(jsonSchemaLinter(), {\n            needsRefresh: handleRefresh,\n        }),\n        jsonLanguage.data.of({\n            autocomplete: jsonCompletion(),\n        }),\n        hoverTooltip(jsonSchemaHover()),\n        stateExtensions(schema),\n    ];\n}\n"],
  "mappings": "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",
  "names": ["isMergeableObject", "deepmerge", "getKeys", "t", "n", "r", "e", "o", "i", "l", "errors", "parser", "options", "BNF", "parser", "x", "module", "query", "index", "parse", "parser", "_a", "_a", "_a", "errors", "deepmerge", "LegacyCache", "_a", "index", "set", "_a", "errors", "resolvedSchema", "index", "_a", "errors", "toOmit", "_a", "import_json_pointer", "import_json_pointer", "EBNF", "query", "toString", "getTypeOf", "value", "index", "isValid", "ReturnType", "skip", "toString", "isArray", "index", "select", "query", "create", "InsertMode", "hasOwnProperty", "type", "query", "gp", "gp", "import_json_pointer", "suffixes", "suffixes", "isObject", "import_json_pointer", "suffixes", "_a", "parentPointer", "parseIdnEmail", "validUrl", "import_json_pointer", "gp", "cache", "resolveRef", "index", "_a", "type", "index", "hasOwnProperty", "errors", "pattern", "index", "deepEqual", "_a", "_a", "import_fast_deep_equal", "equal", "errors", "import_json_pointer", "COMPILED", "COMPILED_REF", "GET_REF", "GET_ROOT", "suffixes", "compileSchema", "_a", "parentPointer", "KeywordValidation", "errors", "keyword_default", "type_default", "keyword_default", "type_default", "compileSchema", "keyword_default", "type_default", "compileSchema", "index", "json", "_a", "_a", "properties", "pattern", "e", "_a", "_a", "errors", "json", "_a", "view"]
}
