{
  "version": 3,
  "sources": ["../../.pnpm/@scure+base@1.1.1/node_modules/@scure/base/lib/index.js", "../../.pnpm/light-bolt11-decoder@3.2.0/node_modules/light-bolt11-decoder/bolt11.js"],
  "sourcesContent": ["\"use strict\";\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n", "const {bech32, hex, utf8} = require('@scure/base')\n\n// defaults for encode; default timestamp is current time at call\nconst DEFAULTNETWORK = {\n  // default network is bitcoin\n  bech32: 'bc',\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  validWitnessVersions: [0]\n}\nconst TESTNETWORK = {\n  bech32: 'tb',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst SIGNETNETWORK = {\n  bech32: 'tbs',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst REGTESTNETWORK = {\n  bech32: 'bcrt',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst SIMNETWORK = {\n  bech32: 'sb',\n  pubKeyHash: 0x3f,\n  scriptHash: 0x7b,\n  validWitnessVersions: [0]\n}\n\nconst FEATUREBIT_ORDER = [\n  'option_data_loss_protect',\n  'initial_routing_sync',\n  'option_upfront_shutdown_script',\n  'gossip_queries',\n  'var_onion_optin',\n  'gossip_queries_ex',\n  'option_static_remotekey',\n  'payment_secret',\n  'basic_mpp',\n  'option_support_large_channel'\n]\n\nconst DIVISORS = {\n  m: BigInt(1e3),\n  u: BigInt(1e6),\n  n: BigInt(1e9),\n  p: BigInt(1e12)\n}\n\nconst MAX_MILLISATS = BigInt('2100000000000000000')\n\nconst MILLISATS_PER_BTC = BigInt(1e11)\n\nconst TAGCODES = {\n  payment_hash: 1,\n  payment_secret: 16,\n  description: 13,\n  payee: 19,\n  description_hash: 23, // commit to longer descriptions (used by lnurl-pay)\n  expiry: 6, // default: 3600 (1 hour)\n  min_final_cltv_expiry: 24, // default: 9\n  fallback_address: 9,\n  route_hint: 3, // for extra routing info (private etc.)\n  feature_bits: 5,\n  metadata: 27\n}\n\n// reverse the keys and values of TAGCODES and insert into TAGNAMES\nconst TAGNAMES = {}\nfor (let i = 0, keys = Object.keys(TAGCODES); i < keys.length; i++) {\n  const currentName = keys[i]\n  const currentCode = TAGCODES[keys[i]].toString()\n  TAGNAMES[currentCode] = currentName\n}\n\nconst TAGPARSERS = {\n  1: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  16: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  13: words => utf8.encode(bech32.fromWordsUnsafe(words)), // string variable length\n  19: words => hex.encode(bech32.fromWordsUnsafe(words)), // 264 bits\n  23: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  27: words => hex.encode(bech32.fromWordsUnsafe(words)), // variable\n  6: wordsToIntBE, // default: 3600 (1 hour)\n  24: wordsToIntBE, // default: 9\n  3: routingInfoParser, // for extra routing info (private etc.)\n  5: featureBitsParser // keep feature bits as array of 5 bit words\n}\n\nfunction getUnknownParser(tagCode) {\n  return words => ({\n    tagCode: parseInt(tagCode),\n    words: bech32.encode('unknown', words, Number.MAX_SAFE_INTEGER)\n  })\n}\n\nfunction wordsToIntBE(words) {\n  return words.reverse().reduce((total, item, index) => {\n    return total + item * Math.pow(32, index)\n  }, 0)\n}\n\n// first convert from words to buffer, trimming padding where necessary\n// parse in 51 byte chunks. See encoder for details.\nfunction routingInfoParser(words) {\n  const routes = []\n  let pubkey,\n    shortChannelId,\n    feeBaseMSats,\n    feeProportionalMillionths,\n    cltvExpiryDelta\n  let routesBuffer = bech32.fromWordsUnsafe(words)\n  while (routesBuffer.length > 0) {\n    pubkey = hex.encode(routesBuffer.slice(0, 33)) // 33 bytes\n    shortChannelId = hex.encode(routesBuffer.slice(33, 41)) // 8 bytes\n    feeBaseMSats = parseInt(hex.encode(routesBuffer.slice(41, 45)), 16) // 4 bytes\n    feeProportionalMillionths = parseInt(\n      hex.encode(routesBuffer.slice(45, 49)),\n      16\n    ) // 4 bytes\n    cltvExpiryDelta = parseInt(hex.encode(routesBuffer.slice(49, 51)), 16) // 2 bytes\n\n    routesBuffer = routesBuffer.slice(51)\n\n    routes.push({\n      pubkey,\n      short_channel_id: shortChannelId,\n      fee_base_msat: feeBaseMSats,\n      fee_proportional_millionths: feeProportionalMillionths,\n      cltv_expiry_delta: cltvExpiryDelta\n    })\n  }\n  return routes\n}\n\nfunction featureBitsParser(words) {\n  const bools = words\n    .slice()\n    .reverse()\n    .map(word => [\n      !!(word & 0b1),\n      !!(word & 0b10),\n      !!(word & 0b100),\n      !!(word & 0b1000),\n      !!(word & 0b10000)\n    ])\n    .reduce((finalArr, itemArr) => finalArr.concat(itemArr), [])\n  while (bools.length < FEATUREBIT_ORDER.length * 2) {\n    bools.push(false)\n  }\n\n  const featureBits = {}\n\n  FEATUREBIT_ORDER.forEach((featureName, index) => {\n    let status\n    if (bools[index * 2]) {\n      status = 'required'\n    } else if (bools[index * 2 + 1]) {\n      status = 'supported'\n    } else {\n      status = 'unsupported'\n    }\n    featureBits[featureName] = status\n  })\n\n  const extraBits = bools.slice(FEATUREBIT_ORDER.length * 2)\n  featureBits.extra_bits = {\n    start_bit: FEATUREBIT_ORDER.length * 2,\n    bits: extraBits,\n    has_required: extraBits.reduce(\n      (result, bit, index) =>\n        index % 2 !== 0 ? result || false : result || bit,\n      false\n    )\n  }\n\n  return featureBits\n}\n\nfunction hrpToMillisat(hrpString, outputString) {\n  let divisor, value\n  if (hrpString.slice(-1).match(/^[munp]$/)) {\n    divisor = hrpString.slice(-1)\n    value = hrpString.slice(0, -1)\n  } else if (hrpString.slice(-1).match(/^[^munp0-9]$/)) {\n    throw new Error('Not a valid multiplier for the amount')\n  } else {\n    value = hrpString\n  }\n\n  if (!value.match(/^\\d+$/))\n    throw new Error('Not a valid human readable amount')\n\n  const valueBN = BigInt(value)\n\n  const millisatoshisBN = divisor\n    ? (valueBN * MILLISATS_PER_BTC) / DIVISORS[divisor]\n    : valueBN * MILLISATS_PER_BTC\n\n  if (\n    (divisor === 'p' && !(valueBN % BigInt(10) === BigInt(0))) ||\n    millisatoshisBN > MAX_MILLISATS\n  ) {\n    throw new Error('Amount is outside of valid range')\n  }\n\n  return outputString ? millisatoshisBN.toString() : millisatoshisBN\n}\n\n// decode will only have extra comments that aren't covered in encode comments.\n// also if anything is hard to read I'll comment.\nfunction decode(paymentRequest, network) {\n  if (typeof paymentRequest !== 'string')\n    throw new Error('Lightning Payment Request must be string')\n  if (paymentRequest.slice(0, 2).toLowerCase() !== 'ln')\n    throw new Error('Not a proper lightning payment request')\n\n  const sections = []\n  const decoded = bech32.decode(paymentRequest, Number.MAX_SAFE_INTEGER)\n  paymentRequest = paymentRequest.toLowerCase()\n  const prefix = decoded.prefix\n  let words = decoded.words\n  let letters = paymentRequest.slice(prefix.length + 1)\n  let sigWords = words.slice(-104)\n  words = words.slice(0, -104)\n\n  // Without reverse lookups, can't say that the multipier at the end must\n  // have a number before it, so instead we parse, and if the second group\n  // doesn't have anything, there's a good chance the last letter of the\n  // coin type got captured by the third group, so just re-regex without\n  // the number.\n  let prefixMatches = prefix.match(/^ln(\\S+?)(\\d*)([a-zA-Z]?)$/)\n  if (prefixMatches && !prefixMatches[2])\n    prefixMatches = prefix.match(/^ln(\\S+)$/)\n  if (!prefixMatches) {\n    throw new Error('Not a proper lightning payment request')\n  }\n\n  // \"ln\" section\n  sections.push({\n    name: 'lightning_network',\n    letters: 'ln'\n  })\n\n  // \"bc\" section\n  const bech32Prefix = prefixMatches[1]\n  let coinNetwork\n  if (!network) {\n    switch (bech32Prefix) {\n      case DEFAULTNETWORK.bech32:\n        coinNetwork = DEFAULTNETWORK\n        break\n      case TESTNETWORK.bech32:\n        coinNetwork = TESTNETWORK\n        break\n      case SIGNETNETWORK.bech32:\n        coinNetwork = SIGNETNETWORK\n        break\n      case REGTESTNETWORK.bech32:\n        coinNetwork = REGTESTNETWORK\n        break\n      case SIMNETWORK.bech32:\n        coinNetwork = SIMNETWORK\n        break\n    }\n  } else {\n    if (\n      network.bech32 === undefined ||\n      network.pubKeyHash === undefined ||\n      network.scriptHash === undefined ||\n      !Array.isArray(network.validWitnessVersions)\n    )\n      throw new Error('Invalid network')\n    coinNetwork = network\n  }\n  if (!coinNetwork || coinNetwork.bech32 !== bech32Prefix) {\n    throw new Error('Unknown coin bech32 prefix')\n  }\n  sections.push({\n    name: 'coin_network',\n    letters: bech32Prefix,\n    value: coinNetwork\n  })\n\n  // amount section\n  const value = prefixMatches[2]\n  let millisatoshis\n  if (value) {\n    const divisor = prefixMatches[3]\n    millisatoshis = hrpToMillisat(value + divisor, true)\n    sections.push({\n      name: 'amount',\n      letters: prefixMatches[2] + prefixMatches[3],\n      value: millisatoshis\n    })\n  } else {\n    millisatoshis = null\n  }\n\n  // \"1\" separator\n  sections.push({\n    name: 'separator',\n    letters: '1'\n  })\n\n  // timestamp\n  const timestamp = wordsToIntBE(words.slice(0, 7))\n  words = words.slice(7) // trim off the left 7 words\n  sections.push({\n    name: 'timestamp',\n    letters: letters.slice(0, 7),\n    value: timestamp\n  })\n  letters = letters.slice(7)\n\n  let tagName, parser, tagLength, tagWords\n  // we have no tag count to go on, so just keep hacking off words\n  // until we have none.\n  while (words.length > 0) {\n    const tagCode = words[0].toString()\n    tagName = TAGNAMES[tagCode] || 'unknown_tag'\n    parser = TAGPARSERS[tagCode] || getUnknownParser(tagCode)\n    words = words.slice(1)\n\n    tagLength = wordsToIntBE(words.slice(0, 2))\n    words = words.slice(2)\n\n    tagWords = words.slice(0, tagLength)\n    words = words.slice(tagLength)\n\n    sections.push({\n      name: tagName,\n      tag: letters[0],\n      letters: letters.slice(0, 1 + 2 + tagLength),\n      value: parser(tagWords) // see: parsers for more comments\n    })\n    letters = letters.slice(1 + 2 + tagLength)\n  }\n\n  // signature\n  sections.push({\n    name: 'signature',\n    letters: letters.slice(0, 104),\n    value: hex.encode(bech32.fromWordsUnsafe(sigWords))\n  })\n  letters = letters.slice(104)\n\n  // checksum\n  sections.push({\n    name: 'checksum',\n    letters: letters\n  })\n\n  let result = {\n    paymentRequest,\n    sections,\n\n    get expiry() {\n      let exp = sections.find(s => s.name === 'expiry')\n      if (exp) return getValue('timestamp') + exp.value\n    },\n\n    get route_hints() {\n      return sections.filter(s => s.name === 'route_hint').map(s => s.value)\n    }\n  }\n\n  for (let name in TAGCODES) {\n    if (name === 'route_hint') {\n      // route hints can be multiple, so this won't work for them\n      continue\n    }\n\n    Object.defineProperty(result, name, {\n      get() {\n        return getValue(name)\n      }\n    })\n  }\n\n  return result\n\n  function getValue(name) {\n    let section = sections.find(s => s.name === name)\n    return section ? section.value : undefined\n  }\n}\n\nmodule.exports = {\n  decode,\n  hrpToMillisat\n}\n"],
  "mappings": "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",
  "names": ["alphabet", "padding", "checksum", "_words"]
}
