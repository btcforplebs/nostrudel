import {
  require_fast_deep_equal
} from "./chunk-IXRKK3TF.js";
import {
  linter,
  snippetCompletion
} from "./chunk-OZO6R4K4.js";
import {
  json,
  jsonLanguage,
  jsonParseLinter
} from "./chunk-SLEDYGFD.js";
import {
  syntaxTree
} from "./chunk-WPJTVW25.js";
import {
  EditorState,
  StateEffect,
  StateField,
  hoverTooltip
} from "./chunk-3LK7YESN.js";
import {
  __commonJS,
  __toESM
} from "./chunk-ULBN3QDT.js";

// node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys2(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys2(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys2(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge2(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module.exports = deepmerge_1;
  }
});

// node_modules/.pnpm/@sagold+json-pointer@5.1.2/node_modules/@sagold/json-pointer/dist/jsonPointer.js
var require_jsonPointer = __commonJS({
  "node_modules/.pnpm/@sagold+json-pointer@5.1.2/node_modules/@sagold/json-pointer/dist/jsonPointer.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("jsonPointer", [], t) : "object" == typeof exports ? exports.jsonPointer = t() : e.jsonPointer = t();
    }("undefined" != typeof self ? self : exports, () => (() => {
      "use strict";
      var e = { d: (t2, n2) => {
        for (var r2 in n2) e.o(n2, r2) && !e.o(t2, r2) && Object.defineProperty(t2, r2, { enumerable: true, get: n2[r2] });
      }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      } }, t = {};
      function n(e2) {
        return "#" === e2 || "" === e2 || Array.isArray(e2) && 0 === e2.length || false;
      }
      e.r(t), e.d(t, { default: () => S, get: () => c, isRoot: () => n, join: () => _, remove: () => j, removeUndefinedItems: () => v, set: () => y, split: () => s, splitLast: () => x });
      const r = /~1/g, o = /~0/g, i = /\/+/g, l = /(^[#/]*|\/+$)/g;
      function u(e2) {
        return e2.replace(r, "/").replace(o, "~");
      }
      function f(e2) {
        return u(decodeURIComponent(e2));
      }
      function s(e2) {
        if (null == e2 || "string" != typeof e2 || n(e2)) return Array.isArray(e2) ? e2 : [];
        const t2 = e2.indexOf("#") >= 0 ? f : u, r2 = (e2 = (e2 = e2.replace(i, "/")).replace(l, "")).split("/");
        for (let e3 = 0, n2 = r2.length; e3 < n2; e3 += 1) r2[e3] = t2(r2[e3]);
        return r2;
      }
      function c(e2, t2, r2 = void 0) {
        if (null == t2 || null == e2) return r2;
        if (n(t2)) return e2;
        const o2 = p(e2, s(t2));
        return void 0 === o2 ? r2 : o2;
      }
      function p(e2, t2) {
        const n2 = t2.shift();
        if (void 0 !== e2) return void 0 !== n2 ? p(e2[n2], t2) : e2;
      }
      const a = /^\[.*\]$/, d = /^\[(.+)\]$/;
      function g(e2, t2) {
        return "__proto__" === e2 || "constructor" == e2 && t2.length > 0 && "prototype" == t2[0];
      }
      function y(e2, t2, n2) {
        if (null == t2) return e2;
        const r2 = s(t2);
        if (0 === r2.length) return e2;
        null == e2 && (e2 = a.test(r2[0]) ? [] : {});
        let o2, i2, l2 = e2;
        for (; r2.length > 1; ) o2 = r2.shift(), i2 = a.test(r2[0]), g(o2, r2) || (l2 = m(l2, o2, i2));
        return o2 = r2.pop(), h(l2, o2, n2), e2;
      }
      function h(e2, t2, n2) {
        let r2;
        const o2 = t2.match(d);
        "[]" === t2 && Array.isArray(e2) ? e2.push(n2) : o2 ? (r2 = o2.pop(), e2[r2] = n2) : e2[t2] = n2;
      }
      function m(e2, t2, n2) {
        if (null != e2[t2]) return e2[t2];
        const r2 = n2 ? [] : {};
        return h(e2, t2, r2), r2;
      }
      function v(e2) {
        let t2 = 0, n2 = 0;
        for (; t2 + n2 < e2.length; ) void 0 === e2[t2 + n2] && (n2 += 1), e2[t2] = e2[t2 + n2], t2 += 1;
        return e2.length = e2.length - n2, e2;
      }
      function j(e2, t2, n2) {
        const r2 = s(t2), o2 = r2.pop(), i2 = c(e2, r2);
        return i2 && delete i2[o2], Array.isArray(i2) && true !== n2 && v(i2), e2;
      }
      const b = /\/+/g, A = /~/g, P = /\//g;
      function O(e2, t2) {
        if (0 === e2.length) return t2 ? "#" : "";
        for (let n2 = 0, r2 = e2.length; n2 < r2; n2 += 1) e2[n2] = e2[n2].replace(A, "~0").replace(P, "~1"), t2 && (e2[n2] = encodeURIComponent(e2[n2]));
        return ((t2 ? "#/" : "/") + e2.join("/")).replace(b, "/");
      }
      function _(e2, ...t2) {
        const n2 = [];
        if (Array.isArray(e2)) return O(e2, true === arguments[1]);
        const r2 = arguments[arguments.length - 1], o2 = "boolean" == typeof r2 ? r2 : e2 && "#" === e2[0];
        for (let e3 = 0, t3 = arguments.length; e3 < t3; e3 += 1) n2.push.apply(n2, s(arguments[e3]));
        const i2 = [];
        for (let e3 = 0, t3 = n2.length; e3 < t3; e3 += 1) if (".." === n2[e3]) {
          if (0 === i2.length) return o2 ? "#" : "";
          i2.pop();
        } else i2.push(n2[e3]);
        return O(i2, o2);
      }
      function x(e2) {
        const t2 = s(e2);
        if (0 === t2.length) return "string" == typeof e2 && "#" === e2[0] ? ["#", t2[0]] : ["", void 0];
        if (1 === t2.length) return "#" === e2[0] ? ["#", t2[0]] : ["", t2[0]];
        const n2 = t2.pop();
        return [_(t2, "#" === e2[0]), n2];
      }
      const S = { get: c, set: y, remove: j, join: _, split: s, splitLast: x, isRoot: n, removeUndefinedItems: v };
      return t;
    })());
  }
});

// node_modules/.pnpm/ebnf@1.9.1/node_modules/ebnf/dist/TokenError.js
var require_TokenError = __commonJS({
  "node_modules/.pnpm/ebnf@1.9.1/node_modules/ebnf/dist/TokenError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenError = void 0;
    var TokenError = class extends Error {
      constructor(message, token) {
        super(message);
        this.message = message;
        this.token = token;
        if (token && token.errors)
          token.errors.push(this);
        else
          throw this;
      }
      inspect() {
        return "SyntaxError: " + this.message;
      }
    };
    exports.TokenError = TokenError;
  }
});

// node_modules/.pnpm/ebnf@1.9.1/node_modules/ebnf/dist/Parser.js
var require_Parser = __commonJS({
  "node_modules/.pnpm/ebnf@1.9.1/node_modules/ebnf/dist/Parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = exports.findRuleByName = exports.parseRuleName = exports.escapeRegExp = exports.readToken = void 0;
    var UPPER_SNAKE_RE = /^[A-Z0-9_]+$/;
    var decorationRE = /(\?|\+|\*)$/;
    var preDecorationRE = /^(@|&|!)/;
    var WS_RULE = "WS";
    var TokenError_1 = require_TokenError();
    function readToken(txt, expr) {
      let result = expr.exec(txt);
      if (result && result.index == 0) {
        if (result[0].length == 0 && expr.source.length > 0)
          return null;
        return {
          type: null,
          text: result[0],
          rest: txt.substr(result[0].length),
          start: 0,
          end: result[0].length - 1,
          fullText: result[0],
          errors: [],
          children: [],
          parent: null
        };
      }
      return null;
    }
    exports.readToken = readToken;
    function escapeRegExp(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    exports.escapeRegExp = escapeRegExp;
    function fixRest(token) {
      token.rest = "";
      token.children && token.children.forEach((c) => fixRest(c));
    }
    function fixPositions(token, start) {
      token.start += start;
      token.end += start;
      token.children && token.children.forEach((c) => fixPositions(c, token.start));
    }
    function agregateErrors(errors2, token) {
      if (token.errors && token.errors.length)
        token.errors.forEach((err) => errors2.push(err));
      token.children && token.children.forEach((tok) => agregateErrors(errors2, tok));
    }
    function parseRuleName(name) {
      let postDecoration = decorationRE.exec(name);
      let preDecoration = preDecorationRE.exec(name);
      let postDecorationText = postDecoration && postDecoration[0] || "";
      let preDecorationText = preDecoration && preDecoration[0] || "";
      let out = {
        raw: name,
        name: name.replace(decorationRE, "").replace(preDecorationRE, ""),
        isOptional: postDecorationText == "?" || postDecorationText == "*",
        allowRepetition: postDecorationText == "+" || postDecorationText == "*",
        atLeastOne: postDecorationText == "+",
        lookupPositive: preDecorationText == "&",
        lookupNegative: preDecorationText == "!",
        pinned: preDecorationText == "@",
        lookup: false,
        isLiteral: false
      };
      out.isLiteral = out.name[0] == "'" || out.name[0] == '"';
      out.lookup = out.lookupNegative || out.lookupPositive;
      return out;
    }
    exports.parseRuleName = parseRuleName;
    function findRuleByName(name, parser2) {
      let parsed = parseRuleName(name);
      return parser2.cachedRules[parsed.name] || null;
    }
    exports.findRuleByName = findRuleByName;
    function stripRules(token, re) {
      if (token.children) {
        let localRules = token.children.filter((x) => x.type && re.test(x.type));
        for (let i = 0; i < localRules.length; i++) {
          let indexOnChildren = token.children.indexOf(localRules[i]);
          if (indexOnChildren != -1) {
            token.children.splice(indexOnChildren, 1);
          }
        }
        token.children.forEach((c) => stripRules(c, re));
      }
    }
    var ignoreMissingRules = ["EOF"];
    var Parser = class {
      constructor(grammarRules, options) {
        this.grammarRules = grammarRules;
        this.options = options;
        this.cachedRules = {};
        this.debug = options ? options.debug === true : false;
        let errors2 = [];
        let neededRules = [];
        grammarRules.forEach((rule) => {
          let parsedName = parseRuleName(rule.name);
          if (parsedName.name in this.cachedRules) {
            errors2.push("Duplicated rule " + parsedName.name);
            return;
          } else {
            this.cachedRules[parsedName.name] = rule;
          }
          if (!rule.bnf || !rule.bnf.length) {
            let error = "Missing rule content, rule: " + rule.name;
            if (errors2.indexOf(error) == -1)
              errors2.push(error);
          } else {
            rule.bnf.forEach((options2) => {
              if (typeof options2[0] === "string") {
                let parsed = parseRuleName(options2[0]);
                if (parsed.name == rule.name) {
                  let error = "Left recursion is not allowed, rule: " + rule.name;
                  if (errors2.indexOf(error) == -1)
                    errors2.push(error);
                }
              }
              options2.forEach((option) => {
                if (typeof option == "string") {
                  let name = parseRuleName(option);
                  if (!name.isLiteral && neededRules.indexOf(name.name) == -1 && ignoreMissingRules.indexOf(name.name) == -1)
                    neededRules.push(name.name);
                }
              });
            });
          }
          if (WS_RULE == rule.name)
            rule.implicitWs = false;
          if (rule.implicitWs) {
            if (neededRules.indexOf(WS_RULE) == -1)
              neededRules.push(WS_RULE);
          }
          if (rule.recover) {
            if (neededRules.indexOf(rule.recover) == -1)
              neededRules.push(rule.recover);
          }
        });
        neededRules.forEach((ruleName) => {
          if (!(ruleName in this.cachedRules)) {
            errors2.push("Missing rule " + ruleName);
          }
        });
        if (errors2.length)
          throw new Error(errors2.join("\n"));
      }
      getAST(txt, target) {
        if (!target) {
          target = this.grammarRules.filter((x) => !x.fragment && x.name.indexOf("%") != 0)[0].name;
        }
        let result = this.parse(txt, target);
        if (result) {
          agregateErrors(result.errors, result);
          fixPositions(result, 0);
          stripRules(result, /^%/);
          if (!this.options || !this.options.keepUpperRules)
            stripRules(result, UPPER_SNAKE_RE);
          let rest = result.rest;
          if (rest) {
            new TokenError_1.TokenError("Unexpected end of input: \n" + rest, result);
          }
          fixRest(result);
          result.rest = rest;
        }
        return result;
      }
      emitSource() {
        return "CANNOT EMIT SOURCE FROM BASE Parser";
      }
      parse(txt, target, recursion = 0) {
        let out = null;
        let type = parseRuleName(target);
        let expr;
        let printable = this.debug && /*!isLiteral &*/
        !UPPER_SNAKE_RE.test(type.name);
        printable && console.log(new Array(recursion).join("│  ") + "Trying to get " + target + " from " + JSON.stringify(txt.split("\n")[0]));
        let realType = type.name;
        let targetLex = findRuleByName(type.name, this);
        if (type.name == "EOF") {
          if (txt.length) {
            return null;
          } else if (txt.length == 0) {
            return {
              type: "EOF",
              text: "",
              rest: "",
              start: 0,
              end: 0,
              fullText: "",
              errors: [],
              children: [],
              parent: null
            };
          }
        }
        try {
          if (!targetLex && type.isLiteral) {
            let src = type.name.trim();
            if (src.startsWith('"')) {
              src = JSON.parse(src);
            } else if (src.startsWith("'")) {
              src = src.replace(/^'(.+)'$/, "$1").replace(/\\'/g, "'");
            }
            if (src === "") {
              return {
                type: "%%EMPTY%%",
                text: "",
                rest: txt,
                start: 0,
                end: 0,
                fullText: "",
                errors: [],
                children: [],
                parent: null
              };
            }
            expr = new RegExp(escapeRegExp(src));
            realType = null;
          }
        } catch (e) {
          if (e instanceof ReferenceError) {
            console.error(e);
          }
          return null;
        }
        if (expr) {
          let result = readToken(txt, expr);
          if (result) {
            result.type = realType;
            return result;
          }
        } else {
          let options = targetLex.bnf;
          if (options instanceof Array) {
            options.forEach((phases) => {
              if (out)
                return;
              let pinned = null;
              let tmp = {
                type: type.name,
                text: "",
                children: [],
                end: 0,
                errors: [],
                fullText: "",
                parent: null,
                start: 0,
                rest: txt
              };
              if (targetLex.fragment)
                tmp.fragment = true;
              let tmpTxt = txt;
              let position = 0;
              let allOptional = phases.length > 0;
              let foundSomething = false;
              for (let i = 0; i < phases.length; i++) {
                if (typeof phases[i] == "string") {
                  let localTarget = parseRuleName(phases[i]);
                  allOptional = allOptional && localTarget.isOptional;
                  let got;
                  let foundAtLeastOne = false;
                  do {
                    got = null;
                    if (targetLex.implicitWs) {
                      got = this.parse(tmpTxt, localTarget.name, recursion + 1);
                      if (!got) {
                        let WS;
                        do {
                          WS = this.parse(tmpTxt, WS_RULE, recursion + 1);
                          if (WS) {
                            tmp.text = tmp.text + WS.text;
                            tmp.end = tmp.text.length;
                            WS.parent = tmp;
                            tmp.children.push(WS);
                            tmpTxt = tmpTxt.substr(WS.text.length);
                            position += WS.text.length;
                          } else {
                            break;
                          }
                        } while (WS && WS.text.length);
                      }
                    }
                    got = got || this.parse(tmpTxt, localTarget.name, recursion + 1);
                    if (localTarget.lookupNegative) {
                      if (got)
                        return;
                      break;
                    }
                    if (localTarget.lookupPositive) {
                      if (!got)
                        return;
                    }
                    if (!got) {
                      if (localTarget.isOptional)
                        break;
                      if (localTarget.atLeastOne && foundAtLeastOne)
                        break;
                    }
                    if (got && targetLex.pinned == i + 1) {
                      pinned = got;
                      printable && console.log(new Array(recursion + 1).join("│  ") + "└─ " + got.type + " PINNED");
                    }
                    if (!got)
                      got = this.parseRecovery(targetLex, tmpTxt, recursion + 1);
                    if (!got) {
                      if (pinned) {
                        out = tmp;
                        got = {
                          type: "SyntaxError",
                          text: tmpTxt,
                          children: [],
                          end: tmpTxt.length,
                          errors: [],
                          fullText: "",
                          parent: null,
                          start: 0,
                          rest: ""
                        };
                        if (tmpTxt.length) {
                          new TokenError_1.TokenError(`Unexpected end of input. Expecting ${localTarget.name} Got: ${tmpTxt}`, got);
                        } else {
                          new TokenError_1.TokenError(`Unexpected end of input. Missing ${localTarget.name}`, got);
                        }
                        printable && console.log(new Array(recursion + 1).join("│  ") + "└─ " + got.type + " " + JSON.stringify(got.text));
                      } else {
                        return;
                      }
                    }
                    foundAtLeastOne = true;
                    foundSomething = true;
                    if (got.type == "%%EMPTY%%") {
                      break;
                    }
                    got.start += position;
                    got.end += position;
                    if (!localTarget.lookupPositive && got.type) {
                      if (got.fragment) {
                        got.children && got.children.forEach((x) => {
                          x.start += position;
                          x.end += position;
                          x.parent = tmp;
                          tmp.children.push(x);
                        });
                      } else {
                        got.parent = tmp;
                        tmp.children.push(got);
                      }
                    }
                    if (localTarget.lookup)
                      got.lookup = true;
                    printable && console.log(new Array(recursion + 1).join("│  ") + "└─ " + got.type + " " + JSON.stringify(got.text));
                    if (!localTarget.lookup && !got.lookup) {
                      tmp.text = tmp.text + got.text;
                      tmp.end = tmp.text.length;
                      tmpTxt = tmpTxt.substr(got.text.length);
                      position += got.text.length;
                    }
                    tmp.rest = tmpTxt;
                  } while (got && localTarget.allowRepetition && tmpTxt.length && !got.lookup);
                } else {
                  let got = readToken(tmpTxt, phases[i]);
                  if (!got) {
                    return;
                  }
                  printable && console.log(new Array(recursion + 1).join("│  ") + "└> " + JSON.stringify(got.text) + phases[i].source);
                  foundSomething = true;
                  got.start += position;
                  got.end += position;
                  tmp.text = tmp.text + got.text;
                  tmp.end = tmp.text.length;
                  tmpTxt = tmpTxt.substr(got.text.length);
                  position += got.text.length;
                  tmp.rest = tmpTxt;
                }
              }
              if (foundSomething) {
                out = tmp;
                printable && console.log(new Array(recursion).join("│  ") + "├<─┴< PUSHING " + out.type + " " + JSON.stringify(out.text));
              }
            });
          }
          if (out && targetLex.simplifyWhenOneChildren && out.children.length == 1) {
            out = out.children[0];
          }
        }
        if (!out) {
          printable && console.log(target + " NOT RESOLVED FROM " + txt);
        }
        return out;
      }
      parseRecovery(recoverableToken, tmpTxt, recursion) {
        if (recoverableToken.recover && tmpTxt.length) {
          let printable = this.debug;
          printable && console.log(new Array(recursion + 1).join("│  ") + "Trying to recover until token " + recoverableToken.recover + " from " + JSON.stringify(tmpTxt.split("\n")[0] + tmpTxt.split("\n")[1]));
          let tmp = {
            type: "SyntaxError",
            text: "",
            children: [],
            end: 0,
            errors: [],
            fullText: "",
            parent: null,
            start: 0,
            rest: ""
          };
          let got;
          do {
            got = this.parse(tmpTxt, recoverableToken.recover, recursion + 1);
            if (got) {
              new TokenError_1.TokenError('Unexpected input: "' + tmp.text + `" Expecting: ${recoverableToken.name}`, tmp);
              break;
            } else {
              tmp.text = tmp.text + tmpTxt[0];
              tmp.end = tmp.text.length;
              tmpTxt = tmpTxt.substr(1);
            }
          } while (!got && tmpTxt.length > 0);
          if (tmp.text.length > 0 && got) {
            printable && console.log(new Array(recursion + 1).join("│  ") + "Recovered text: " + JSON.stringify(tmp.text));
            return tmp;
          }
        }
        return null;
      }
    };
    exports.Parser = Parser;
    exports.default = Parser;
  }
});

// node_modules/.pnpm/ebnf@1.9.1/node_modules/ebnf/dist/Grammars/W3CEBNF.js
var require_W3CEBNF = __commonJS({
  "node_modules/.pnpm/ebnf@1.9.1/node_modules/ebnf/dist/Grammars/W3CEBNF.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Parser_1 = require_Parser();
    var BNF;
    (function(BNF2) {
      BNF2.RULES = [
        {
          name: "Grammar",
          bnf: [["RULE_S*", "%Atomic*", "EOF"]]
        },
        {
          name: "%Atomic",
          bnf: [["Production", "RULE_S*"]],
          fragment: true
        },
        {
          name: "Production",
          bnf: [["NCName", "RULE_S*", '"::="', "RULE_WHITESPACE*", "Choice", "RULE_WHITESPACE*", "RULE_EOL+", "RULE_S*"]]
        },
        {
          name: "NCName",
          bnf: [[/[a-zA-Z][a-zA-Z_0-9]*/]]
        },
        {
          name: "Choice",
          bnf: [["SequenceOrDifference", "%_Choice_1*"]],
          fragment: true
        },
        {
          name: "%_Choice_1",
          bnf: [["RULE_WHITESPACE*", '"|"', "RULE_WHITESPACE*", "SequenceOrDifference"]],
          fragment: true
        },
        {
          name: "SequenceOrDifference",
          bnf: [["Item", "RULE_WHITESPACE*", "%_Item_1?"]]
        },
        {
          name: "%_Item_1",
          bnf: [["Minus", "Item"], ["Item*"]],
          fragment: true
        },
        {
          name: "Minus",
          bnf: [['"-"']]
        },
        {
          name: "Item",
          bnf: [["RULE_WHITESPACE*", "%Primary", "PrimaryDecoration?"]],
          fragment: true
        },
        {
          name: "PrimaryDecoration",
          bnf: [['"?"'], ['"*"'], ['"+"']]
        },
        {
          name: "DecorationName",
          bnf: [['"ebnf://"', /[^\x5D#]+/]]
        },
        {
          name: "%Primary",
          bnf: [["NCName"], ["StringLiteral"], ["CharCode"], ["CharClass"], ["SubItem"]],
          fragment: true
        },
        {
          name: "SubItem",
          bnf: [['"("', "RULE_WHITESPACE*", "Choice", "RULE_WHITESPACE*", '")"']]
        },
        {
          name: "StringLiteral",
          bnf: [[`'"'`, /[^"]*/, `'"'`], [`"'"`, /[^']*/, `"'"`]],
          pinned: 1
        },
        {
          name: "CharCode",
          bnf: [['"#x"', /[0-9a-zA-Z]+/]]
        },
        {
          name: "CharClass",
          bnf: [["'['", "'^'?", "%RULE_CharClass_1+", '"]"']]
        },
        {
          name: "%RULE_CharClass_1",
          bnf: [["CharCodeRange"], ["CharRange"], ["CharCode"], ["RULE_Char"]],
          fragment: true
        },
        {
          name: "RULE_Char",
          bnf: [[/\x09/], [/\x0A/], [/\x0D/], [/[\x20-\x5c]/], [/[\x5e-\uD7FF]/], [/[\uE000-\uFFFD]/]]
        },
        {
          name: "CharRange",
          bnf: [["RULE_Char", '"-"', "RULE_Char"]]
        },
        {
          name: "CharCodeRange",
          bnf: [["CharCode", '"-"', "CharCode"]]
        },
        {
          name: "RULE_WHITESPACE",
          bnf: [["%RULE_WHITESPACE_CHAR*"], ["Comment", "RULE_WHITESPACE*"]]
        },
        {
          name: "RULE_S",
          bnf: [["RULE_WHITESPACE", "RULE_S*"], ["RULE_EOL", "RULE_S*"]]
        },
        {
          name: "%RULE_WHITESPACE_CHAR",
          bnf: [[/\x09/], [/\x20/]],
          fragment: true
        },
        {
          name: "Comment",
          bnf: [['"/*"', "%RULE_Comment_Body*", '"*/"']]
        },
        {
          name: "%RULE_Comment_Body",
          bnf: [['!"*/"', /[^*]/]],
          fragment: true
        },
        {
          name: "RULE_EOL",
          bnf: [[/\x0D/, /\x0A/], [/\x0A/], [/\x0D/]]
        },
        {
          name: "Link",
          bnf: [["'['", "Url", "']'"]]
        },
        {
          name: "Url",
          bnf: [[/[^\x5D:/?#]/, '"://"', /[^\x5D#]+/, "%Url1?"]]
        },
        {
          name: "%Url1",
          bnf: [['"#"', "NCName"]],
          fragment: true
        }
      ];
      BNF2.defaultParser = new Parser_1.Parser(BNF2.RULES, { debug: false });
      const preDecorationRE = /^(!|&)/;
      const decorationRE = /(\?|\+|\*)$/;
      const subExpressionRE = /^%/;
      function getBNFRule(name, parser2) {
        if (typeof name == "string") {
          if (preDecorationRE.test(name))
            return "";
          let subexpression = subExpressionRE.test(name);
          if (subexpression) {
            let decoration = decorationRE.exec(name);
            let decorationText = decoration ? decoration[0] + " " : "";
            let lonely = isLonelyRule(name, parser2);
            if (lonely)
              return getBNFBody(name, parser2) + decorationText;
            return "(" + getBNFBody(name, parser2) + ")" + decorationText;
          }
          return name;
        } else {
          return name.source.replace(/\\(?:x|u)([a-zA-Z0-9]+)/g, "#x$1").replace(/\[\\(?:x|u)([a-zA-Z0-9]+)-\\(?:x|u)([a-zA-Z0-9]+)\]/g, "[#x$1-#x$2]");
        }
      }
      function isLonelyRule(name, parser2) {
        let rule = Parser_1.findRuleByName(name, parser2);
        return rule && rule.bnf.length == 1 && rule.bnf[0].length == 1 && (rule.bnf[0][0] instanceof RegExp || rule.bnf[0][0][0] == '"' || rule.bnf[0][0][0] == "'");
      }
      function getBNFChoice(rules, parser2) {
        return rules.map((x) => getBNFRule(x, parser2)).join(" ");
      }
      function getBNFBody(name, parser2) {
        let rule = Parser_1.findRuleByName(name, parser2);
        if (rule)
          return rule.bnf.map((x) => getBNFChoice(x, parser2)).join(" | ");
        return "RULE_NOT_FOUND {" + name + "}";
      }
      function emit(parser2) {
        let acumulator = [];
        parser2.grammarRules.forEach((l) => {
          if (!/^%/.test(l.name)) {
            let recover = l.recover ? " /* { recoverUntil=" + l.recover + " } */" : "";
            acumulator.push(l.name + " ::= " + getBNFBody(l.name, parser2) + recover);
          }
        });
        return acumulator.join("\n");
      }
      BNF2.emit = emit;
      let subitems = 0;
      function restar(total, resta) {
        console.log("reberia restar " + resta + " a " + total);
        throw new Error("Difference not supported yet");
      }
      function convertRegex(txt) {
        return new RegExp(txt.replace(/#x([a-zA-Z0-9]{4})/g, "\\u$1").replace(/#x([a-zA-Z0-9]{3})/g, "\\u0$1").replace(/#x([a-zA-Z0-9]{2})/g, "\\x$1").replace(/#x([a-zA-Z0-9]{1})/g, "\\x0$1"));
      }
      function getSubItems(tmpRules, seq, parentName) {
        let anterior = null;
        let bnfSeq = [];
        seq.children.forEach((x, i) => {
          if (x.type == "Minus") {
            restar(anterior, x);
          } else {
          }
          let decoration = seq.children[i + 1];
          decoration = decoration && decoration.type == "PrimaryDecoration" && decoration.text || "";
          let preDecoration = "";
          switch (x.type) {
            case "SubItem":
              let name = "%" + (parentName + subitems++);
              createRule(tmpRules, x, name);
              bnfSeq.push(preDecoration + name + decoration);
              break;
            case "NCName":
            case "StringLiteral":
              bnfSeq.push(preDecoration + x.text + decoration);
              break;
            case "CharCode":
            case "CharClass":
              if (decoration || preDecoration) {
                let newRule = {
                  name: "%" + (parentName + subitems++),
                  bnf: [[convertRegex(x.text)]]
                };
                tmpRules.push(newRule);
                bnfSeq.push(preDecoration + newRule.name + decoration);
              } else {
                bnfSeq.push(convertRegex(x.text));
              }
              break;
            case "PrimaryDecoration":
              break;
            default:
              throw new Error(" HOW SHOULD I PARSE THIS? " + x.type + " -> " + JSON.stringify(x.text));
          }
          anterior = x;
        });
        return bnfSeq;
      }
      function createRule(tmpRules, token, name) {
        let bnf = token.children.filter((x) => x.type == "SequenceOrDifference").map((s) => getSubItems(tmpRules, s, name));
        let rule = {
          name,
          bnf
        };
        let recover = null;
        bnf.forEach((x) => {
          recover = recover || x["recover"];
          delete x["recover"];
        });
        if (name.indexOf("%") == 0)
          rule.fragment = true;
        if (recover)
          rule.recover = recover;
        tmpRules.push(rule);
      }
      function getRules(source, parser2 = BNF2.defaultParser) {
        let ast = parser2.getAST(source);
        if (!ast)
          throw new Error("Could not parse " + source);
        if (ast.errors && ast.errors.length) {
          throw ast.errors[0];
        }
        let tmpRules = [];
        ast.children.filter((x) => x.type == "Production").map((x) => {
          let name = x.children.filter((x2) => x2.type == "NCName")[0].text;
          createRule(tmpRules, x, name);
        });
        return tmpRules;
      }
      BNF2.getRules = getRules;
      function Transform(source, subParser = BNF2.defaultParser) {
        return getRules(source.join(""), subParser);
      }
      BNF2.Transform = Transform;
      class Parser extends Parser_1.Parser {
        constructor(source, options) {
          const subParser = options && options.debugRulesParser === true ? new Parser_1.Parser(BNF2.RULES, { debug: true }) : BNF2.defaultParser;
          super(getRules(source, subParser), options);
        }
        emitSource() {
          return emit(this);
        }
      }
      BNF2.Parser = Parser;
    })(BNF || (BNF = {}));
    exports.default = BNF;
  }
});

// node_modules/.pnpm/valid-url@1.0.9/node_modules/valid-url/index.js
var require_valid_url = __commonJS({
  "node_modules/.pnpm/valid-url@1.0.9/node_modules/valid-url/index.js"(exports, module) {
    (function(module2) {
      "use strict";
      module2.exports.is_uri = is_iri;
      module2.exports.is_http_uri = is_http_iri;
      module2.exports.is_https_uri = is_https_iri;
      module2.exports.is_web_uri = is_web_iri;
      module2.exports.isUri = is_iri;
      module2.exports.isHttpUri = is_http_iri;
      module2.exports.isHttpsUri = is_https_iri;
      module2.exports.isWebUri = is_web_iri;
      var splitUri = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
      };
      function is_iri(value) {
        if (!value) {
          return;
        }
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;
        if (/%[^0-9a-f]/i.test(value)) return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path = "";
        var query2 = "";
        var fragment = "";
        var out = "";
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query2 = splitted[4];
        fragment = splitted[5];
        if (!(scheme && scheme.length && path.length >= 0)) return;
        if (authority && authority.length) {
          if (!(path.length === 0 || /^\//.test(path))) return;
        } else {
          if (/^\/\//.test(path)) return;
        }
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase())) return;
        out += scheme + ":";
        if (authority && authority.length) {
          out += "//" + authority;
        }
        out += path;
        if (query2 && query2.length) {
          out += "?" + query2;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
          return;
        }
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path = "";
        var port = "";
        var query2 = "";
        var fragment = "";
        var out = "";
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query2 = splitted[4];
        fragment = splitted[5];
        if (!scheme) return;
        if (allowHttps) {
          if (scheme.toLowerCase() != "https") return;
        } else {
          if (scheme.toLowerCase() != "http") return;
        }
        if (!authority) {
          return;
        }
        if (/:(\d+)$/.test(authority)) {
          port = authority.match(/:(\d+)$/)[0];
          authority = authority.replace(/:\d+$/, "");
        }
        out += scheme + ":";
        out += "//" + authority;
        if (port) {
          out += port;
        }
        out += path;
        if (query2 && query2.length) {
          out += "?" + query2;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_https_iri(value) {
        return is_http_iri(value, true);
      }
      function is_web_iri(value) {
        return is_http_iri(value) || is_https_iri(value);
      }
    })(module);
  }
});

// node_modules/.pnpm/nearley@2.20.1/node_modules/nearley/lib/nearley.js
var require_nearley = __commonJS({
  "node_modules/.pnpm/nearley@2.20.1/node_modules/nearley/lib/nearley.js"(exports, module) {
    (function(root, factory) {
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.nearley = factory();
      }
    })(exports, function() {
      function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;
        this.postprocess = postprocess;
        return this;
      }
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " ● " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " → " + symbolSequence;
      };
      function State(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
          children.push(node.right.data);
          node = node.left;
        } while (node.left);
        children.reverse();
        return children;
      };
      State.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
      };
      function Column(grammar, index2) {
        this.grammar = grammar;
        this.index = index2;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w = 0; w < states.length; w++) {
          var state = states[w];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser.fail) {
              var wantedBy = state.wantedBy;
              for (var i = wantedBy.length; i--; ) {
                var left = wantedBy[i];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i = 0; i < nulls.length; i++) {
                  var right = nulls[i];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i = 0; i < rules.length; i++) {
          var r = rules[i];
          var wantedBy = this.wants[exp];
          var s = new State(r, 0, this.index, wantedBy);
          this.states.push(s);
        }
      };
      Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
      };
      function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      Grammar.fromCompiled = function(rules, start) {
        var lexer = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r) {
          return new Rule(r.name, r.symbols, r.postprocess);
        });
        var g = new Grammar(rules, start);
        g.lexer = lexer;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(
            Math.max(0, this.line - 5),
            this.line
          );
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1) nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message += " at line " + this.line + " col " + col + ":\n\n";
          message += lines.map(function(line, i) {
            return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message += "\n" + pad("", lastLineDigits + col) + "^\n";
          return message;
        } else {
          return message + " at index " + (this.index - 1);
        }
        function pad(n, length) {
          var s = String(n);
          return Array(length - s.length + 1).join(" ") + s;
        }
      };
      function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
          var grammar = rules;
          var options = start;
        } else {
          var grammar = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar;
        this.options = {
          keepHistory: false,
          lexer: grammar.lexer || new StreamLexer()
        };
        for (var key in options || {}) {
          this.options[key] = options[key];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column(grammar, 0);
        var table = this.table = [column];
        column.wants[grammar.start] = [];
        column.predict(grammar.start);
        column.process();
        this.current = 0;
      }
      Parser.fail = {};
      Parser.prototype.feed = function(chunk) {
        var lexer = this.lexer;
        lexer.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer.next();
            if (!token) {
              break;
            }
          } catch (e) {
            var nextColumn = new Column(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err = new Error(this.reportLexerError(e));
            err.offset = this.current;
            err.token = e.token;
            throw err;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n = this.current + 1;
          var nextColumn = new Column(this.grammar, n);
          this.table.push(nextColumn);
          var literal = token.text !== void 0 ? token.text : token.value;
          var value = lexer.constructor === StreamLexer ? token.value : token;
          var scannable = column.scannable;
          for (var w = scannable.length; w--; ) {
            var state = scannable[w];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value) : expect.type ? expect.type === token.type : expect.literal === literal) {
              var next = state.nextState({ data: value, token, isToken: true, reference: n - 1 });
              nextColumn.states.push(next);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            var err = new Error(this.reportError(token));
            err.offset = this.current;
            err.token = token;
            throw err;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
          var state = stateStack[j];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser.prototype.getSymbolDisplay = function(symbol) {
        return getSymbolLongDisplay(symbol);
      };
      Parser.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser.prototype.restore = function(column) {
        var index2 = column.index;
        this.current = index2;
        this.table[index2] = column;
        this.table.splice(index2 + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser.prototype.rewind = function(index2) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index2]);
      };
      Parser.prototype.finish = function() {
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t) {
          if (t.rule.name === start && t.dot === t.rule.symbols.length && t.reference === 0 && t.data !== Parser.fail) {
            considerations.push(t);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return "character matching " + symbol;
          } else if (symbol.type) {
            return symbol.type + " token";
          } else if (symbol.test) {
            return "token matching " + String(symbol.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      function getSymbolShortDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return symbol.toString();
          } else if (symbol.type) {
            return "%" + symbol.type;
          } else if (symbol.test) {
            return "<" + String(symbol.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      return {
        Parser,
        Grammar,
        Rule
      };
    });
  }
});

// node_modules/.pnpm/smtp-address-parser@1.0.10/node_modules/smtp-address-parser/dist/lib/grammar.js
var require_grammar = __commonJS({
  "node_modules/.pnpm/smtp-address-parser@1.0.10/node_modules/smtp-address-parser/dist/lib/grammar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function id(d) {
      return d[0];
    }
    var deepFlatten = (arr) => [].concat(...arr.map((v) => Array.isArray(v) ? deepFlatten(v) : v));
    function flat_string(d) {
      if (d) {
        if (Array.isArray(d))
          return deepFlatten(d).join("");
        return d;
      }
      return "";
    }
    var grammar = {
      Lexer: void 0,
      ParserRules: [
        { "name": "Reverse_path", "symbols": ["Path"] },
        { "name": "Reverse_path$string$1", "symbols": [{ "literal": "<" }, { "literal": ">" }], "postprocess": (d) => d.join("") },
        { "name": "Reverse_path", "symbols": ["Reverse_path$string$1"] },
        { "name": "Forward_path$subexpression$1$subexpression$1", "symbols": [{ "literal": "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { "literal": "@" }], "postprocess": function(d) {
          return d.join("");
        } },
        { "name": "Forward_path$subexpression$1", "symbols": ["Forward_path$subexpression$1$subexpression$1", "Domain", { "literal": ">" }] },
        { "name": "Forward_path", "symbols": ["Forward_path$subexpression$1"] },
        { "name": "Forward_path$subexpression$2", "symbols": [{ "literal": "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { "literal": ">" }], "postprocess": function(d) {
          return d.join("");
        } },
        { "name": "Forward_path", "symbols": ["Forward_path$subexpression$2"] },
        { "name": "Forward_path", "symbols": ["Path"] },
        { "name": "Path$ebnf$1$subexpression$1", "symbols": ["A_d_l", { "literal": ":" }] },
        { "name": "Path$ebnf$1", "symbols": ["Path$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "Path$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "Path", "symbols": [{ "literal": "<" }, "Path$ebnf$1", "Mailbox", { "literal": ">" }] },
        { "name": "A_d_l$ebnf$1", "symbols": [] },
        { "name": "A_d_l$ebnf$1$subexpression$1", "symbols": [{ "literal": "," }, "At_domain"] },
        { "name": "A_d_l$ebnf$1", "symbols": ["A_d_l$ebnf$1", "A_d_l$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "A_d_l", "symbols": ["At_domain", "A_d_l$ebnf$1"] },
        { "name": "At_domain", "symbols": [{ "literal": "@" }, "Domain"] },
        { "name": "Domain$ebnf$1", "symbols": [] },
        { "name": "Domain$ebnf$1$subexpression$1", "symbols": [{ "literal": "." }, "sub_domain"] },
        { "name": "Domain$ebnf$1", "symbols": ["Domain$ebnf$1", "Domain$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Domain", "symbols": ["sub_domain", "Domain$ebnf$1"] },
        { "name": "sub_domain", "symbols": ["U_label"] },
        { "name": "Let_dig", "symbols": ["ALPHA_DIGIT"], "postprocess": id },
        { "name": "Ldh_str$ebnf$1", "symbols": [] },
        { "name": "Ldh_str$ebnf$1", "symbols": ["Ldh_str$ebnf$1", "ALPHA_DIG_DASH"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Ldh_str", "symbols": ["Ldh_str$ebnf$1", "Let_dig"] },
        { "name": "U_Let_dig", "symbols": ["ALPHA_DIGIT_U"], "postprocess": id },
        { "name": "U_Ldh_str$ebnf$1", "symbols": [] },
        { "name": "U_Ldh_str$ebnf$1", "symbols": ["U_Ldh_str$ebnf$1", "ALPHA_DIG_DASH_U"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "U_Ldh_str", "symbols": ["U_Ldh_str$ebnf$1", "U_Let_dig"] },
        { "name": "U_label$ebnf$1$subexpression$1", "symbols": ["U_Ldh_str"] },
        { "name": "U_label$ebnf$1", "symbols": ["U_label$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "U_label$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "U_label", "symbols": ["U_Let_dig", "U_label$ebnf$1"] },
        { "name": "address_literal$subexpression$1", "symbols": ["IPv4_address_literal"] },
        { "name": "address_literal$subexpression$1", "symbols": ["IPv6_address_literal"] },
        { "name": "address_literal$subexpression$1", "symbols": ["General_address_literal"] },
        { "name": "address_literal", "symbols": [{ "literal": "[" }, "address_literal$subexpression$1", { "literal": "]" }] },
        {
          "name": "non_local_part",
          "symbols": ["Domain"],
          "postprocess": function(d) {
            return { DomainName: flat_string(d[0]) };
          }
        },
        {
          "name": "non_local_part",
          "symbols": ["address_literal"],
          "postprocess": function(d) {
            return { AddressLiteral: flat_string(d[0]) };
          }
        },
        {
          "name": "Mailbox",
          "symbols": ["Local_part", { "literal": "@" }, "non_local_part"],
          "postprocess": function(d) {
            return { localPart: flat_string(d[0]), domainPart: flat_string(d[2]) };
          }
        },
        {
          "name": "Local_part",
          "symbols": ["Dot_string"],
          "postprocess": function(d) {
            return { DotString: flat_string(d[0]) };
          }
        },
        {
          "name": "Local_part",
          "symbols": ["Quoted_string"],
          "postprocess": function(d) {
            return { QuotedString: flat_string(d[0]) };
          }
        },
        { "name": "Dot_string$ebnf$1", "symbols": [] },
        { "name": "Dot_string$ebnf$1$subexpression$1", "symbols": [{ "literal": "." }, "Atom"] },
        { "name": "Dot_string$ebnf$1", "symbols": ["Dot_string$ebnf$1", "Dot_string$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Dot_string", "symbols": ["Atom", "Dot_string$ebnf$1"] },
        { "name": "Atom$ebnf$1", "symbols": [/[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/] },
        { "name": "Atom$ebnf$1", "symbols": ["Atom$ebnf$1", /[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Atom", "symbols": ["Atom$ebnf$1"] },
        { "name": "Quoted_string$ebnf$1", "symbols": [] },
        { "name": "Quoted_string$ebnf$1", "symbols": ["Quoted_string$ebnf$1", "QcontentSMTP"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Quoted_string", "symbols": ["DQUOTE", "Quoted_string$ebnf$1", "DQUOTE"] },
        { "name": "QcontentSMTP", "symbols": ["qtextSMTP"] },
        { "name": "QcontentSMTP", "symbols": ["quoted_pairSMTP"] },
        { "name": "quoted_pairSMTP", "symbols": [{ "literal": "\\" }, /[\x20-\x7e]/] },
        { "name": "qtextSMTP", "symbols": [/[\x20-\x21\x23-\x5b\x5d-\x7e\u0080-\uFFFF]/], "postprocess": id },
        { "name": "IPv4_address_literal$macrocall$2", "symbols": [{ "literal": "." }, "Snum"] },
        { "name": "IPv4_address_literal$macrocall$1", "symbols": ["IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2"] },
        { "name": "IPv4_address_literal", "symbols": ["Snum", "IPv4_address_literal$macrocall$1"] },
        { "name": "IPv6_address_literal$subexpression$1", "symbols": [/[iI]/, /[pP]/, /[vV]/, { "literal": "6" }, { "literal": ":" }], "postprocess": function(d) {
          return d.join("");
        } },
        { "name": "IPv6_address_literal", "symbols": ["IPv6_address_literal$subexpression$1", "IPv6_addr"] },
        { "name": "General_address_literal$ebnf$1", "symbols": ["dcontent"] },
        { "name": "General_address_literal$ebnf$1", "symbols": ["General_address_literal$ebnf$1", "dcontent"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "General_address_literal", "symbols": ["Standardized_tag", { "literal": ":" }, "General_address_literal$ebnf$1"] },
        { "name": "Standardized_tag", "symbols": ["Ldh_str"] },
        { "name": "dcontent", "symbols": [/[\x21-\x5a\x5e-\x7e]/], "postprocess": id },
        { "name": "Snum", "symbols": ["DIGIT"] },
        { "name": "Snum$subexpression$1", "symbols": [/[1-9]/, "DIGIT"] },
        { "name": "Snum", "symbols": ["Snum$subexpression$1"] },
        { "name": "Snum$subexpression$2", "symbols": [{ "literal": "1" }, "DIGIT", "DIGIT"] },
        { "name": "Snum", "symbols": ["Snum$subexpression$2"] },
        { "name": "Snum$subexpression$3", "symbols": [{ "literal": "2" }, /[0-4]/, "DIGIT"] },
        { "name": "Snum", "symbols": ["Snum$subexpression$3"] },
        { "name": "Snum$subexpression$4", "symbols": [{ "literal": "2" }, { "literal": "5" }, /[0-5]/] },
        { "name": "Snum", "symbols": ["Snum$subexpression$4"] },
        { "name": "IPv6_addr", "symbols": ["IPv6_full"] },
        { "name": "IPv6_addr", "symbols": ["IPv6_comp"] },
        { "name": "IPv6_addr", "symbols": ["IPv6v4_full"] },
        { "name": "IPv6_addr", "symbols": ["IPv6v4_comp"] },
        { "name": "IPv6_hex", "symbols": ["HEXDIG"] },
        { "name": "IPv6_hex$subexpression$1", "symbols": ["HEXDIG", "HEXDIG"] },
        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$1"] },
        { "name": "IPv6_hex$subexpression$2", "symbols": ["HEXDIG", "HEXDIG", "HEXDIG"] },
        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$2"] },
        { "name": "IPv6_hex$subexpression$3", "symbols": ["HEXDIG", "HEXDIG", "HEXDIG", "HEXDIG"] },
        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$3"] },
        { "name": "IPv6_full$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6_full$macrocall$1", "symbols": ["IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2"] },
        { "name": "IPv6_full", "symbols": ["IPv6_hex", "IPv6_full$macrocall$1"] },
        { "name": "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6_comp$ebnf$1$subexpression$1$macrocall$1", "symbols": ["IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2"] },
        { "name": "IPv6_comp$ebnf$1$subexpression$1", "symbols": ["IPv6_hex", "IPv6_comp$ebnf$1$subexpression$1$macrocall$1"] },
        { "name": "IPv6_comp$ebnf$1", "symbols": ["IPv6_comp$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "IPv6_comp$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "IPv6_comp$string$1", "symbols": [{ "literal": ":" }, { "literal": ":" }], "postprocess": (d) => d.join("") },
        { "name": "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6_comp$ebnf$2$subexpression$1$macrocall$1", "symbols": ["IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2"] },
        { "name": "IPv6_comp$ebnf$2$subexpression$1", "symbols": ["IPv6_hex", "IPv6_comp$ebnf$2$subexpression$1$macrocall$1"] },
        { "name": "IPv6_comp$ebnf$2", "symbols": ["IPv6_comp$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "IPv6_comp$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "IPv6_comp", "symbols": ["IPv6_comp$ebnf$1", "IPv6_comp$string$1", "IPv6_comp$ebnf$2"] },
        { "name": "IPv6v4_full$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6v4_full$macrocall$1", "symbols": ["IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2"] },
        { "name": "IPv6v4_full", "symbols": ["IPv6_hex", "IPv6v4_full$macrocall$1", { "literal": ":" }, "IPv4_address_literal"] },
        { "name": "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1", "symbols": ["IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2"] },
        { "name": "IPv6v4_comp$ebnf$1$subexpression$1", "symbols": ["IPv6_hex", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1"] },
        { "name": "IPv6v4_comp$ebnf$1", "symbols": ["IPv6v4_comp$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "IPv6v4_comp$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "IPv6v4_comp$string$1", "symbols": [{ "literal": ":" }, { "literal": ":" }], "postprocess": (d) => d.join("") },
        { "name": "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", "symbols": ["IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2"] },
        { "name": "IPv6v4_comp$ebnf$2$subexpression$1", "symbols": ["IPv6_hex", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", { "literal": ":" }] },
        { "name": "IPv6v4_comp$ebnf$2", "symbols": ["IPv6v4_comp$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "IPv6v4_comp$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "IPv6v4_comp", "symbols": ["IPv6v4_comp$ebnf$1", "IPv6v4_comp$string$1", "IPv6v4_comp$ebnf$2", "IPv4_address_literal"] },
        { "name": "DIGIT", "symbols": [/[0-9]/], "postprocess": id },
        { "name": "ALPHA_DIGIT_U", "symbols": [/[0-9A-Za-z\u0080-\uFFFF]/], "postprocess": id },
        { "name": "ALPHA_DIGIT", "symbols": [/[0-9A-Za-z]/], "postprocess": id },
        { "name": "ALPHA_DIG_DASH", "symbols": [/[-0-9A-Za-z]/], "postprocess": id },
        { "name": "ALPHA_DIG_DASH_U", "symbols": [/[-0-9A-Za-z\u0080-\uFFFF]/], "postprocess": id },
        { "name": "HEXDIG", "symbols": [/[0-9A-Fa-f]/], "postprocess": id },
        { "name": "DQUOTE", "symbols": [{ "literal": '"' }], "postprocess": id }
      ],
      ParserStart: "Reverse_path"
    };
    exports.default = grammar;
  }
});

// node_modules/.pnpm/smtp-address-parser@1.0.10/node_modules/smtp-address-parser/dist/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/smtp-address-parser@1.0.10/node_modules/smtp-address-parser/dist/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.canonicalize = exports.canonicalize_quoted_string = exports.normalize = exports.normalize_dot_string = exports.parse = void 0;
    var nearley = require_nearley();
    var grammar_1 = __importDefault(require_grammar());
    grammar_1.default.ParserStart = "Mailbox";
    var grammar = nearley.Grammar.fromCompiled(grammar_1.default);
    function parse2(address) {
      const parser2 = new nearley.Parser(grammar);
      parser2.feed(address);
      if (parser2.results.length !== 1) {
        throw new Error("address parsing failed: ambiguous grammar");
      }
      return parser2.results[0];
    }
    exports.parse = parse2;
    function normalize_dot_string(dot_string) {
      const tagless = function() {
        const plus_loc = dot_string.indexOf("+");
        if (plus_loc === -1) {
          return dot_string;
        }
        return dot_string.substr(0, plus_loc);
      }();
      const dotless = tagless.replace(/\./g, "");
      return dotless.toLowerCase();
    }
    exports.normalize_dot_string = normalize_dot_string;
    function normalize(address) {
      var _a2, _b;
      const a = parse2(address);
      const domain = (_a2 = a.domainPart.AddressLiteral) !== null && _a2 !== void 0 ? _a2 : a.domainPart.DomainName.toLowerCase();
      const local = (_b = a.localPart.QuotedString) !== null && _b !== void 0 ? _b : normalize_dot_string(a.localPart.DotString);
      return `${local}@${domain}`;
    }
    exports.normalize = normalize;
    function canonicalize_quoted_string(quoted_string) {
      const unquoted = quoted_string.substr(1).substr(0, quoted_string.length - 2);
      const unescaped = unquoted.replace(/(?:\\(.))/g, "$1");
      const reescaped = unescaped.replace(/(?:(["\\]))/g, "\\$1");
      return `"${reescaped}"`;
    }
    exports.canonicalize_quoted_string = canonicalize_quoted_string;
    function canonicalize(address) {
      var _a2;
      const a = parse2(address);
      const domain = (_a2 = a.domainPart.AddressLiteral) !== null && _a2 !== void 0 ? _a2 : a.domainPart.DomainName.toLowerCase();
      const local = a.localPart.QuotedString ? canonicalize_quoted_string(a.localPart.QuotedString) : a.localPart.DotString;
      return `${local}@${domain}`;
    }
    exports.canonicalize = canonicalize;
  }
});

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/debug.js
var debug = {
  log: (...args) => {
    if (true) {
      return;
    }
    console.log(...args);
  }
};

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/constants.js
var TOKENS = {
  STRING: "String",
  NUMBER: "Number",
  TRUE: "True",
  FALSE: "False",
  NULL: "Null",
  OBJECT: "Object",
  ARRAY: "Array",
  PROPERTY: "Property",
  PROPERTY_NAME: "PropertyName",
  PROPERTY_COLON: "PropertyColon",
  JSON_TEXT: "JsonText",
  INVALID: "⚠"
};
var PRIMITIVE_TYPES = [
  TOKENS.STRING,
  TOKENS.NUMBER,
  TOKENS.TRUE,
  TOKENS.FALSE,
  TOKENS.NULL
];
var COMPLEX_TYPES = [TOKENS.OBJECT, TOKENS.ARRAY];

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/node.js
var getNodeAtPosition = (state, pos, side = -1) => {
  return syntaxTree(state).resolveInner(pos, side);
};
var stripSurroundingQuotes = (str) => {
  return str.replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
};
var getWord = (doc, node, stripQuotes = true) => {
  const word = node ? doc.sliceString(node.from, node.to) : "";
  return stripQuotes ? stripSurroundingQuotes(word) : word;
};
var isInvalidValueNode = (node) => {
  var _a2, _b;
  return node.name === TOKENS.INVALID && (((_a2 = node.prevSibling) === null || _a2 === void 0 ? void 0 : _a2.name) === TOKENS.PROPERTY_NAME || ((_b = node.prevSibling) === null || _b === void 0 ? void 0 : _b.name) === TOKENS.PROPERTY_COLON);
};
var isPrimitiveValueNode = (node) => {
  return PRIMITIVE_TYPES.includes(node.name) || isInvalidValueNode(node);
};
var isValueNode = (node) => {
  return [...PRIMITIVE_TYPES, ...COMPLEX_TYPES].includes(node.name) || isInvalidValueNode(node);
};
var isPropertyNameNode = (node) => {
  var _a2, _b;
  return node.name === TOKENS.PROPERTY_NAME || node.name === TOKENS.INVALID && (((_a2 = node.prevSibling) === null || _a2 === void 0 ? void 0 : _a2.name) === TOKENS.PROPERTY || ((_b = node.prevSibling) === null || _b === void 0 ? void 0 : _b.name) === "{");
};
var getChildrenNodes = (node) => {
  const children = [];
  let child = node.firstChild;
  while (child) {
    if (child) {
      children.push(child);
    }
    child = child === null || child === void 0 ? void 0 : child.nextSibling;
  }
  return children;
};
var getChildValueNode = (node) => {
  return getChildrenNodes(node).find((n) => isPrimitiveValueNode(n));
};
var getArrayNodeChildren = (node) => {
  return getChildrenNodes(node).filter((n) => PRIMITIVE_TYPES.includes(n.name) || COMPLEX_TYPES.includes(n.name));
};
var findNodeIndexInArrayNode = (arrayNode, valueNode) => {
  return getArrayNodeChildren(arrayNode).findIndex((nd) => nd.from === valueNode.from && nd.to === valueNode.to);
};

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/state.js
var schemaEffect = StateEffect.define();
var schemaStateField = StateField.define({
  create() {
  },
  update(schema, tr) {
    for (const e of tr.effects) {
      if (e.is(schemaEffect)) {
        return e.value;
      }
    }
    return schema;
  }
});
var updateSchema = (view, schema) => {
  view.dispatch({
    effects: schemaEffect.of(schema)
  });
};
var getJSONSchema = (state) => {
  return state.field(schemaStateField);
};
var stateExtensions = (schema) => [
  schemaStateField.init(() => schema)
];

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/config/strings.js
var strings_default = {
  // validation errors
  AdditionalItemsError: "Array at `{{pointer}}` may not have an additional item `{{key}}`",
  AdditionalPropertiesError: "Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`",
  AllOfError: "Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`",
  AnyOfError: "Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`",
  ConstError: "Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`",
  containsAnyError: "The array at `{{pointer}}` must contain at least one item",
  ContainsArrayError: "The property at `{{pointer}}` must not be an array",
  ContainsError: "The array at `{{pointer}}` must contain an element that matches `{{schema}}`",
  EnumError: "Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`",
  ForbiddenPropertyError: "Property name `{{property}}` at `{{pointer}}` is not allowed",
  FormatDateError: "Value `{{value}}` at `{{pointer}}` is not a valid date",
  FormatDateTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid date-time",
  FormatEmailError: "Value `{{value}}` at `{{pointer}}` is not a valid email",
  FormatHostnameError: "Value `{{value}}` at `{{pointer}}` is not a valid hostname",
  FormatIPV4Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address",
  FormatIPV4LeadingZeroError: "IPv4 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatIPV6Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address",
  FormatIPV6LeadingZeroError: "IPv6 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatJsonPointerError: "Value `{{value}}` at `{{pointer}}` is not a valid json-pointer",
  FormatRegExError: "Value `{{value}}` at `{{pointer}}` is not a valid regular expression",
  FormatTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid time",
  FormatURIError: "Value `{{value}}` at `{{pointer}}` is not a valid uri",
  FormatURIReferenceError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-reference",
  FormatURITemplateError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-template",
  FormatURLError: "Value `{{value}}` at `{{pointer}}` is not a valid url",
  InvalidDataError: "No value may be specified in `{{pointer}}`",
  InvalidPropertyNameError: "Invalid property name `{{property}}` at `{{pointer}}`",
  MaximumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum",
  MaxItemsError: "Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",
  MaxLengthError: "Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.",
  MaxPropertiesError: "Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",
  MinimumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum",
  MinItemsError: "Too few items in `{{pointer}}`, should be at least `{{minItems}}`, but got `{{length}}`",
  MinItemsOneError: "At least one item is required in `{{pointer}}`",
  MinLengthError: "Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.",
  MinLengthOneError: "A value is required in `{{pointer}}`",
  MinPropertiesError: "Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`",
  MissingDependencyError: "The required propery '{{missingProperty}}' in `{{pointer}}` is missing",
  MissingOneOfPropertyError: "Value at `{{pointer}}` property: `{{property}}`",
  MultipleOfError: "Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`",
  MultipleOneOfError: "Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`",
  NoAdditionalPropertiesError: "Additional property `{{property}}` in `{{pointer}}` is not allowed",
  NotError: "Value `{{value}}` at pointer should not match schema `{{not}}`",
  OneOfError: "Value `{{value}}` in `{{pointer}}` does not match any given oneof schema",
  OneOfPropertyError: "Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`",
  PatternError: "Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`",
  PatternPropertiesError: "Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}",
  RequiredPropertyError: "The required property `{{key}}` is missing at `{{pointer}}`",
  SchemaWarning: "Failed retrieving a schema from '{{pointer}}' to key '{{key}}'",
  TypeError: "Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`",
  UndefinedValueError: "Value must not be undefined in `{{pointer}}`",
  UniqueItemsError: "Items in array must be unique. Value `{{value}}` in `{{pointer}}` is a duplicate of {{duplicatePointer}}.",
  UnknownPropertyError: "Could not find a valid schema for property `{{pointer}}` within object",
  ValueNotEmptyError: "A value for `{{property}}` is required at `{{pointer}}`"
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/getTypeOf.js
var toString = Object.prototype.toString;
function getTypeOf(value) {
  const type = toString.call(value).match(/\s([^\]]+)\]/).pop().toLowerCase();
  if (type === "file") {
    return "object";
  }
  return type;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/render.js
var OBJECT_TYPE = "object";
var ARRAY_TYPE = "array";
function render(template, data = {}) {
  return template.replace(/\{\{\w+\}\}/g, (match) => {
    const key = match.replace(/[{}]/g, "");
    const variable = data[key];
    const variableType = getTypeOf(variable);
    if (variableType === OBJECT_TYPE || variableType === ARRAY_TYPE) {
      return JSON.stringify(variable);
    }
    return variable;
  });
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/__.js
function __(keyword, data, fallback = keyword) {
  var _a2;
  const template = (_a2 = strings_default[keyword]) !== null && _a2 !== void 0 ? _a2 : fallback;
  return render(template, data);
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/createCustomError.js
function dashCase(text) {
  return text.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function createError(name, data) {
  return {
    type: "error",
    name,
    code: dashCase(name),
    message: __(name, data),
    data
  };
}
function createCustomError(name) {
  return createError.bind(null, name);
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/flattenArray.js
function flattenArray(list, result = []) {
  for (let i = 0; i < list.length; i += 1) {
    const item = list[i];
    if (Array.isArray(item)) {
      flattenArray(item, result);
    } else {
      result.push(item);
    }
  }
  return result;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/config/settings.js
var settings_default = {
  DECLARATOR_ONEOF: "oneOfProperty",
  GET_TEMPLATE_RECURSION_LIMIT: 1,
  propertyBlacklist: ["_id"],
  templateDefaultOptions: {
    addOptionalProps: false,
    removeInvalidData: false,
    extendDefaults: true
  }
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/schema/createOneOfSchemaResult.js
function createOneOfSchemaResult(schema, oneOfSchema, oneOfIndex) {
  const childSchema = { ...oneOfSchema };
  Object.defineProperty(childSchema, "getOneOfOrigin", {
    enumerable: false,
    value: () => ({
      index: oneOfIndex,
      schema
    })
  });
  return childSchema;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/types.js
function isJsonError(error) {
  return (error === null || error === void 0 ? void 0 : error.type) === "error";
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/filter.js
function isPromise(obj) {
  return obj instanceof Promise;
}
function errorOrPromise(error) {
  return isJsonError(error) || isPromise(error);
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/features/oneOf.js
var { DECLARATOR_ONEOF } = settings_default;
function resolveOneOf(draft, data, schema = draft.rootSchema, pointer = "#") {
  if (data != null && schema[DECLARATOR_ONEOF]) {
    const errors3 = [];
    const oneOfProperty = schema[DECLARATOR_ONEOF];
    const oneOfValue = data[schema[DECLARATOR_ONEOF]];
    if (oneOfValue === void 0) {
      return draft.errors.missingOneOfPropertyError({
        property: oneOfProperty,
        pointer,
        schema,
        value: data
      });
    }
    for (let i = 0; i < schema.oneOf.length; i += 1) {
      const one = draft.resolveRef(schema.oneOf[i]);
      const oneOfPropertySchema = draft.step(oneOfProperty, one, data, pointer);
      if (isJsonError(oneOfPropertySchema)) {
        return oneOfPropertySchema;
      }
      let result = flattenArray(draft.validate(oneOfValue, oneOfPropertySchema, pointer));
      result = result.filter(errorOrPromise);
      if (result.length > 0) {
        errors3.push(...result);
      } else {
        return createOneOfSchemaResult(schema, one, i);
      }
    }
    return draft.errors.oneOfPropertyError({
      property: oneOfProperty,
      value: oneOfValue,
      pointer,
      schema,
      errors: errors3
    });
  }
  const matches = [];
  const errors2 = [];
  for (let i = 0; i < schema.oneOf.length; i += 1) {
    const one = draft.resolveRef(schema.oneOf[i]);
    let result = flattenArray(draft.validate(data, one, pointer));
    result = result.filter(errorOrPromise);
    if (result.length > 0) {
      errors2.push(...result);
    } else {
      matches.push({ index: i, schema: one });
    }
  }
  if (matches.length === 1) {
    return createOneOfSchemaResult(schema, matches[0].schema, matches[0].index);
  }
  if (matches.length > 1) {
    return draft.errors.multipleOneOfError({
      value: data,
      pointer,
      schema,
      matches
    });
  }
  return draft.errors.oneOfError({
    value: JSON.stringify(data),
    pointer,
    schema,
    oneOf: schema.oneOf,
    errors: errors2
  });
}
function fuzzyObjectValue(draft, one, data, pointer) {
  if (data == null || one.properties == null) {
    return -1;
  }
  let value = 0;
  const keys = Object.keys(one.properties);
  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];
    if (data[key] != null && draft.isValid(data[key], one.properties[key], pointer)) {
      value += 1;
    }
  }
  return value;
}
function resolveOneOfFuzzy(draft, data, schema = draft.rootSchema, pointer = "#") {
  if (data != null && schema[DECLARATOR_ONEOF]) {
    const errors2 = [];
    const oneOfProperty = schema[DECLARATOR_ONEOF];
    const oneOfValue = data[schema[DECLARATOR_ONEOF]];
    if (oneOfValue === void 0) {
      return draft.errors.missingOneOfPropertyError({
        property: oneOfProperty,
        pointer,
        schema,
        value: data
      });
    }
    for (let i = 0; i < schema.oneOf.length; i += 1) {
      const one = draft.resolveRef(schema.oneOf[i]);
      const oneOfPropertySchema = draft.step(oneOfProperty, one, data, pointer);
      if (isJsonError(oneOfPropertySchema)) {
        return oneOfPropertySchema;
      }
      let result = flattenArray(draft.validate(oneOfValue, oneOfPropertySchema, pointer));
      result = result.filter(errorOrPromise);
      if (result.length > 0) {
        errors2.push(...result);
      } else {
        return createOneOfSchemaResult(schema, one, i);
      }
    }
    return draft.errors.oneOfPropertyError({
      property: oneOfProperty,
      value: oneOfValue,
      pointer,
      schema,
      errors: errors2
    });
  }
  const matches = [];
  for (let i = 0; i < schema.oneOf.length; i += 1) {
    const one = draft.resolveRef(schema.oneOf[i]);
    if (draft.isValid(data, one, pointer)) {
      matches.push({ schema: one, index: i });
    }
  }
  if (matches.length === 1) {
    return createOneOfSchemaResult(schema, matches[0].schema, matches[0].index);
  }
  if (getTypeOf(data) === "object") {
    let schemaOfItem;
    let schemaOfIndex = -1;
    let fuzzyGreatest = 0;
    for (let i = 0; i < schema.oneOf.length; i += 1) {
      const one = draft.resolveRef(schema.oneOf[i]);
      const fuzzyValue = fuzzyObjectValue(draft, one, data);
      if (fuzzyGreatest < fuzzyValue) {
        fuzzyGreatest = fuzzyValue;
        schemaOfItem = schema.oneOf[i];
        schemaOfIndex = i;
      }
    }
    if (schemaOfItem === void 0) {
      return draft.errors.oneOfError({
        value: JSON.stringify(data),
        pointer,
        schema,
        oneOf: schema.oneOf
      });
    }
    return createOneOfSchemaResult(schema, schemaOfItem, schemaOfIndex);
  }
  if (matches.length > 1) {
    return draft.errors.multipleOneOfError({ matches, pointer, schema, value: data });
  }
  return draft.errors.oneOfError({
    value: JSON.stringify(data),
    pointer,
    schema,
    oneOf: schema.oneOf
  });
}
var validateOneOf = (draft, schema, value, pointer) => {
  if (Array.isArray(schema.oneOf)) {
    const schemaOrError = draft.resolveOneOf(value, schema, pointer);
    if (isJsonError(schemaOrError)) {
      return schemaOrError;
    }
  }
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/merge.js
var import_deepmerge = __toESM(require_cjs());
var overwriteMerge = (destinationArray, sourceArray) => sourceArray;
var merge_default = (a, b) => (0, import_deepmerge.default)(a, b, { arrayMerge: overwriteMerge });
var mergeUniqueItems = (destinationArray, sourceArray) => {
  const all = destinationArray.concat(sourceArray);
  return all.filter((item, pos) => all.indexOf(item) === pos);
};
var mergeArraysUnique = (a, b) => (0, import_deepmerge.default)(a, b, { arrayMerge: mergeUniqueItems });

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/mergeSchema.js
function mergeSchema(a, b) {
  const aType = getTypeOf(a);
  const bType = getTypeOf(b);
  if (aType !== bType) {
    return a;
  }
  const result = mergeArraysUnique(a, b);
  if (a.getOneOfOrigin) {
    Object.defineProperty(result, "getOneOfOrigin", {
      enumerable: false,
      value: a.getOneOfOrigin
    });
  } else if (b.getOneOfOrigin) {
    Object.defineProperty(result, "getOneOfOrigin", {
      enumerable: false,
      value: b.getOneOfOrigin
    });
  }
  return result;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/omit.js
function omit(object, ...keysToOmit) {
  const result = {};
  Object.keys(object).forEach((key) => {
    if (!keysToOmit.includes(key)) {
      result[key] = object[key];
    }
  });
  if (object.getOneOfOrigin) {
    Object.defineProperty(result, "getOneOfOrigin", {
      enumerable: false,
      value: object.getOneOfOrigin
    });
  }
  return result;
}

// node_modules/.pnpm/fast-copy@3.0.2/node_modules/fast-copy/dist/esm/index.mjs
var toStringFunction = Function.prototype.toString;
var create = Object.create;
var toStringObject = Object.prototype.toString;
var LegacyCache = (
  /** @class */
  function() {
    function LegacyCache2() {
      this._keys = [];
      this._values = [];
    }
    LegacyCache2.prototype.has = function(key) {
      return !!~this._keys.indexOf(key);
    };
    LegacyCache2.prototype.get = function(key) {
      return this._values[this._keys.indexOf(key)];
    };
    LegacyCache2.prototype.set = function(key, value) {
      this._keys.push(key);
      this._values.push(value);
    };
    return LegacyCache2;
  }()
);
function createCacheLegacy() {
  return new LegacyCache();
}
function createCacheModern() {
  return /* @__PURE__ */ new WeakMap();
}
var createCache = typeof WeakMap !== "undefined" ? createCacheModern : createCacheLegacy;
function getCleanClone(prototype) {
  if (!prototype) {
    return create(null);
  }
  var Constructor = prototype.constructor;
  if (Constructor === Object) {
    return prototype === Object.prototype ? {} : create(prototype);
  }
  if (Constructor && ~toStringFunction.call(Constructor).indexOf("[native code]")) {
    try {
      return new Constructor();
    } catch (_a2) {
    }
  }
  return create(prototype);
}
function getRegExpFlagsLegacy(regExp) {
  var flags = "";
  if (regExp.global) {
    flags += "g";
  }
  if (regExp.ignoreCase) {
    flags += "i";
  }
  if (regExp.multiline) {
    flags += "m";
  }
  if (regExp.unicode) {
    flags += "u";
  }
  if (regExp.sticky) {
    flags += "y";
  }
  return flags;
}
function getRegExpFlagsModern(regExp) {
  return regExp.flags;
}
var getRegExpFlags = /test/g.flags === "g" ? getRegExpFlagsModern : getRegExpFlagsLegacy;
function getTagLegacy(value) {
  var type = toStringObject.call(value);
  return type.substring(8, type.length - 1);
}
function getTagModern(value) {
  return value[Symbol.toStringTag] || getTagLegacy(value);
}
var getTag = typeof Symbol !== "undefined" ? getTagModern : getTagLegacy;
var defineProperty = Object.defineProperty;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var _a = Object.prototype;
var hasOwnProperty = _a.hasOwnProperty;
var propertyIsEnumerable = _a.propertyIsEnumerable;
var SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === "function";
function getStrictPropertiesModern(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;
function copyOwnPropertiesStrict(value, clone, state) {
  var properties = getStrictProperties(value);
  for (var index2 = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index2 < length_1; ++index2) {
    property = properties[index2];
    if (property === "callee" || property === "caller") {
      continue;
    }
    descriptor = getOwnPropertyDescriptor(value, property);
    if (!descriptor) {
      clone[property] = state.copier(value[property], state);
      continue;
    }
    if (!descriptor.get && !descriptor.set) {
      descriptor.value = state.copier(descriptor.value, state);
    }
    try {
      defineProperty(clone, property, descriptor);
    } catch (error) {
      clone[property] = descriptor.value;
    }
  }
  return clone;
}
function copyArrayLoose(array, state) {
  var clone = new state.Constructor();
  state.cache.set(array, clone);
  for (var index2 = 0, length_2 = array.length; index2 < length_2; ++index2) {
    clone[index2] = state.copier(array[index2], state);
  }
  return clone;
}
function copyArrayStrict(array, state) {
  var clone = new state.Constructor();
  state.cache.set(array, clone);
  return copyOwnPropertiesStrict(array, clone, state);
}
function copyArrayBuffer(arrayBuffer, _state) {
  return arrayBuffer.slice(0);
}
function copyBlob(blob, _state) {
  return blob.slice(0, blob.size, blob.type);
}
function copyDataView(dataView, state) {
  return new state.Constructor(copyArrayBuffer(dataView.buffer));
}
function copyDate(date, state) {
  return new state.Constructor(date.getTime());
}
function copyMapLoose(map, state) {
  var clone = new state.Constructor();
  state.cache.set(map, clone);
  map.forEach(function(value, key) {
    clone.set(key, state.copier(value, state));
  });
  return clone;
}
function copyMapStrict(map, state) {
  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);
}
function copyObjectLooseLegacy(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone[key] = state.copier(object[key], state);
    }
  }
  return clone;
}
function copyObjectLooseModern(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone[key] = state.copier(object[key], state);
    }
  }
  var symbols = getOwnPropertySymbols(object);
  for (var index2 = 0, length_3 = symbols.length, symbol = void 0; index2 < length_3; ++index2) {
    symbol = symbols[index2];
    if (propertyIsEnumerable.call(object, symbol)) {
      clone[symbol] = state.copier(object[symbol], state);
    }
  }
  return clone;
}
var copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;
function copyObjectStrict(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  return copyOwnPropertiesStrict(object, clone, state);
}
function copyPrimitiveWrapper(primitiveObject, state) {
  return new state.Constructor(primitiveObject.valueOf());
}
function copyRegExp(regExp, state) {
  var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));
  clone.lastIndex = regExp.lastIndex;
  return clone;
}
function copySelf(value, _state) {
  return value;
}
function copySetLoose(set2, state) {
  var clone = new state.Constructor();
  state.cache.set(set2, clone);
  set2.forEach(function(value) {
    clone.add(state.copier(value, state));
  });
  return clone;
}
function copySetStrict(set2, state) {
  return copyOwnPropertiesStrict(set2, copySetLoose(set2, state), state);
}
var isArray = Array.isArray;
var assign = Object.assign;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
var DEFAULT_LOOSE_OPTIONS = {
  array: copyArrayLoose,
  arrayBuffer: copyArrayBuffer,
  blob: copyBlob,
  dataView: copyDataView,
  date: copyDate,
  error: copySelf,
  map: copyMapLoose,
  object: copyObjectLoose,
  regExp: copyRegExp,
  set: copySetLoose
};
var DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {
  array: copyArrayStrict,
  map: copyMapStrict,
  object: copyObjectStrict,
  set: copySetStrict
});
function getTagSpecificCopiers(options) {
  return {
    Arguments: options.object,
    Array: options.array,
    ArrayBuffer: options.arrayBuffer,
    Blob: options.blob,
    Boolean: copyPrimitiveWrapper,
    DataView: options.dataView,
    Date: options.date,
    Error: options.error,
    Float32Array: options.arrayBuffer,
    Float64Array: options.arrayBuffer,
    Int8Array: options.arrayBuffer,
    Int16Array: options.arrayBuffer,
    Int32Array: options.arrayBuffer,
    Map: options.map,
    Number: copyPrimitiveWrapper,
    Object: options.object,
    Promise: copySelf,
    RegExp: options.regExp,
    Set: options.set,
    String: copyPrimitiveWrapper,
    WeakMap: copySelf,
    WeakSet: copySelf,
    Uint8Array: options.arrayBuffer,
    Uint8ClampedArray: options.arrayBuffer,
    Uint16Array: options.arrayBuffer,
    Uint32Array: options.arrayBuffer,
    Uint64Array: options.arrayBuffer
  };
}
function createCopier(options) {
  var normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);
  var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);
  var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;
  function copier(value, state) {
    state.prototype = state.Constructor = void 0;
    if (!value || typeof value !== "object") {
      return value;
    }
    if (state.cache.has(value)) {
      return state.cache.get(value);
    }
    state.prototype = getPrototypeOf(value);
    state.Constructor = state.prototype && state.prototype.constructor;
    if (!state.Constructor || state.Constructor === Object) {
      return object(value, state);
    }
    if (isArray(value)) {
      return array(value, state);
    }
    var tagSpecificCopier = tagSpecificCopiers[getTag(value)];
    if (tagSpecificCopier) {
      return tagSpecificCopier(value, state);
    }
    return typeof value.then === "function" ? value : object(value, state);
  }
  return function copy(value) {
    return copier(value, {
      Constructor: void 0,
      cache: createCache(),
      copier,
      prototype: void 0
    });
  };
}
function createStrictCopier(options) {
  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));
}
var copyStrict = createStrictCopier({});
var index = createCopier({});

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/copy.js
var copy_default = index;

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/features/if.js
function resolveIfSchema(draft, schema, data) {
  if (schema.if == null) {
    return void 0;
  }
  if (schema.if === false) {
    return schema.else;
  }
  if (schema.if && (schema.then || schema.else)) {
    const ifErrors = draft.validate(data, draft.resolveRef(schema.if));
    if (ifErrors.length === 0 && schema.then) {
      return draft.resolveRef(schema.then);
    }
    if (ifErrors.length !== 0 && schema.else) {
      return draft.resolveRef(schema.else);
    }
  }
}
var validateIf = (draft, schema, value, pointer) => {
  const resolvedSchema = resolveIfSchema(draft, schema, value);
  if (resolvedSchema) {
    return draft.validate(value, resolvedSchema, pointer);
  }
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/features/allOf.js
function resolveSchema(draft, schemaToResolve, data) {
  var _a2;
  const schema = { ...(_a2 = draft.resolveRef(schemaToResolve)) !== null && _a2 !== void 0 ? _a2 : {} };
  const ifSchema = resolveIfSchema(draft, schema, data);
  if (ifSchema) {
    return ifSchema;
  }
  return omit(schema, "if", "then", "else");
}
function resolveAllOf(draft, data, schema = draft.rootSchema) {
  let mergedSchema = copy_default(schema);
  for (let i = 0; i < schema.allOf.length; i += 1) {
    const allOfSchema = resolveSchema(draft, schema.allOf[i], data);
    mergedSchema = mergeSchema(mergedSchema, allOfSchema);
  }
  delete mergedSchema.allOf;
  return mergedSchema;
}
function mergeAllOfSchema(draft, schema) {
  const { allOf } = schema;
  if (!Array.isArray(allOf) || allOf.length === 0) {
    return;
  }
  let resolvedSchema = {};
  allOf.forEach((subschema) => {
    resolvedSchema = mergeSchema(resolvedSchema, draft.resolveRef(subschema));
  });
  return resolvedSchema;
}
var validateAllOf = (draft, schema, value, pointer) => {
  const { allOf } = schema;
  if (!Array.isArray(allOf) || allOf.length === 0) {
    return;
  }
  const errors2 = [];
  schema.allOf.forEach((subSchema) => {
    errors2.push(...draft.validate(value, subSchema, pointer));
  });
  return errors2;
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/resolveRef.strict.js
function resolveRef(schema, rootSchema) {
  if (schema == null || schema.$ref == null) {
    return schema;
  }
  if (schema.getRoot) {
    const resolvedSchema2 = schema.getRoot().getRef(schema);
    return resolvedSchema2;
  }
  const resolvedSchema = rootSchema.getRef(schema);
  return resolvedSchema;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/resolveRef.merge.js
function resolveRefMerge(schema, rootSchema) {
  if (schema == null || schema.$ref == null) {
    return schema;
  }
  const resolvedSchema = rootSchema.getRef(schema);
  const mergedSchema = Object.assign({}, resolvedSchema, schema);
  delete mergedSchema.$ref;
  Object.defineProperty(mergedSchema, "__ref", { enumerable: false, value: schema.__ref });
  Object.defineProperty(mergedSchema, "getRoot", { enumerable: false, value: schema.getRoot });
  return mergedSchema;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/uniqueItems.js
function uniqueItems(list) {
  return list.filter((item, index2) => list.indexOf(item) === index2);
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/isObject.js
function isObject(v) {
  return getTypeOf(v) === "object";
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/features/dependencies.js
function resolveDependencies(draft, schema, data) {
  const { dependencies } = schema;
  if (!isObject(dependencies) || !isObject(data)) {
    return;
  }
  let updated = false;
  let resolvedSchema = { required: [] };
  Object.keys(dependencies).forEach((prop) => {
    var _a2, _b;
    if (data[prop] == null && !(((_a2 = schema.required) === null || _a2 === void 0 ? void 0 : _a2.includes(prop)) || ((_b = resolvedSchema.required) === null || _b === void 0 ? void 0 : _b.includes(prop)))) {
      return;
    }
    const dependency = dependencies[prop];
    if (Array.isArray(dependency)) {
      updated = true;
      resolvedSchema.required.push(...dependency);
      return;
    }
    if (isObject(dependency)) {
      updated = true;
      resolvedSchema = mergeSchema(resolvedSchema, draft.resolveRef(dependency));
      return;
    }
  });
  if (updated) {
    resolvedSchema.required = uniqueItems(resolvedSchema.required);
    return resolvedSchema;
  }
}
var validateDependencies = (draft, schema, value, pointer) => {
  if (getTypeOf(schema.dependencies) !== "object") {
    return void 0;
  }
  const errors2 = [];
  Object.keys(value).forEach((property) => {
    if (schema.dependencies[property] === void 0) {
      return;
    }
    if (schema.dependencies[property] === true) {
      return;
    }
    if (schema.dependencies[property] === false) {
      errors2.push(draft.errors.missingDependencyError({ pointer, schema, value }));
      return;
    }
    let dependencyErrors;
    const type = getTypeOf(schema.dependencies[property]);
    if (type === "array") {
      dependencyErrors = schema.dependencies[property].filter((dependency) => value[dependency] === void 0).map((missingProperty) => draft.errors.missingDependencyError({ missingProperty, pointer, schema, value }));
    } else if (type === "object") {
      dependencyErrors = draft.validate(value, schema.dependencies[property], pointer);
    } else {
      throw new Error(`Invalid dependency definition for ${pointer}/${property}. Must be string[] or schema`);
    }
    errors2.push(...dependencyErrors);
  });
  return errors2.length > 0 ? errors2 : void 0;
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/features/anyOf.js
function mergeValidAnyOfSchema(draft, schema, data) {
  if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {
    return;
  }
  let resolvedSchema;
  schema.anyOf.forEach((anySchema) => {
    anySchema = draft.resolveRef(anySchema);
    if (draft.isValid(data, anySchema)) {
      resolvedSchema = resolvedSchema ? mergeSchema(resolvedSchema, anySchema) : anySchema;
    }
  });
  return resolvedSchema;
}
function resolveAnyOf(draft, data, schema = draft.rootSchema, pointer = "#") {
  const { anyOf } = schema;
  if (!Array.isArray(anyOf) || anyOf.length === 0) {
    return schema;
  }
  const resolvedSchema = mergeValidAnyOfSchema(draft, schema, data);
  if (resolvedSchema == null) {
    return draft.errors.anyOfError({ pointer, schema, value: data, anyOf: JSON.stringify(anyOf) });
  }
  const mergedSchema = mergeSchema(schema, resolvedSchema);
  return omit(mergedSchema, "anyOf");
}
var validateAnyOf = (draft, schema, value, pointer) => {
  if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {
    return void 0;
  }
  for (let i = 0; i < schema.anyOf.length; i += 1) {
    if (draft.isValid(value, schema.anyOf[i])) {
      return void 0;
    }
  }
  return draft.errors.anyOfError({ pointer, schema, value, anyOf: schema.anyOf });
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/resolveDynamicSchema.js
var toOmit = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];
var dynamicProperties = ["allOf", "anyOf", "oneOf", "dependencies", "if"];
function isDynamicSchema(schema) {
  const givenProps = Object.keys(schema);
  return dynamicProperties.findIndex((prop) => givenProps.includes(prop)) !== -1;
}
function resolveDynamicSchema(draft, schema, data, pointer) {
  let resolvedSchema;
  let error;
  schema = draft.resolveRef(schema);
  if (schema.oneOf) {
    const oneOfSchema = resolveOneOfFuzzy(draft, data, schema, pointer);
    if (isJsonError(oneOfSchema)) {
      error = oneOfSchema;
    } else if (oneOfSchema) {
      resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, oneOfSchema);
    }
  }
  if (Array.isArray(schema.allOf)) {
    const allOf = schema.allOf.map((s) => {
      if (isDynamicSchema(s)) {
        let result = resolveDynamicSchema(draft, s, data, pointer);
        if (result) {
          result = mergeSchema(s, result);
          return omit(result, ...toOmit);
        }
        return void 0;
      }
      return s;
    });
    if (allOf.length > 0) {
      const allOfSchema = mergeAllOfSchema(draft, { allOf });
      resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, allOfSchema);
    }
  }
  const anyOfSchema = mergeValidAnyOfSchema(draft, schema, data);
  if (anyOfSchema) {
    resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, anyOfSchema);
  }
  const dependenciesSchema = resolveDependencies(draft, schema, data);
  if (dependenciesSchema) {
    resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, dependenciesSchema);
  }
  const ifSchema = resolveIfSchema(draft, schema, data);
  if (ifSchema) {
    resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, ifSchema);
  }
  if (resolvedSchema == null) {
    return error;
  }
  const nestedSchema = resolveDynamicSchema(draft, resolvedSchema, data, pointer);
  if (nestedSchema) {
    resolvedSchema = mergeSchema(resolvedSchema, nestedSchema);
  }
  return omit(resolvedSchema, ...toOmit);
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/reduceSchema.js
var toOmit2 = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];
function reduceSchema(draft, schema, data, pointer) {
  let resolvedSchema = resolveDynamicSchema(draft, schema, data, pointer);
  if (resolvedSchema) {
    resolvedSchema = mergeSchema(schema, resolvedSchema);
    return omit(resolvedSchema, ...toOmit2);
  }
  return schema;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft/index.js
var Draft = class {
  constructor(config, schema) {
    this.remotes = {};
    this.errors = {};
    this.typeKeywords = {};
    this.validateKeyword = {};
    this.validateType = {};
    this.validateFormat = {};
    this.config = config;
    this.typeKeywords = copy_default(config.typeKeywords);
    this.validateKeyword = Object.assign({}, config.validateKeyword);
    this.validateType = Object.assign({}, config.validateType);
    this.validateFormat = Object.assign({}, config.validateFormat);
    this.errors = Object.assign({}, config.errors);
    this.setSchema(schema);
  }
  get rootSchema() {
    return this.__rootSchema;
  }
  set rootSchema(rootSchema) {
    if (rootSchema == null) {
      return;
    }
    this.__rootSchema = this.config.compileSchema(this, rootSchema);
  }
  /**
   * register a json-schema to be referenced from another json-schema
   * @param url - base-url of json-schema (aka id)
   * @param schema - json-schema root
   */
  addRemoteSchema(url, schema) {
    this.config.addRemoteSchema(this, url, schema);
  }
  compileSchema(schema) {
    var _a2;
    return this.config.compileSchema(this, schema, (_a2 = this.rootSchema) !== null && _a2 !== void 0 ? _a2 : schema);
  }
  createSchemaOf(data) {
    return this.config.createSchemaOf(data);
  }
  /**
   * Iterates over data, retrieving its schema
   *
   * @param data - the data to iterate
   * @param callback - will be called with (schema, data, pointer) on each item
   * @param [schema] - the schema matching the data. Defaults to rootSchema
   * @param [pointer] - pointer to current data. Default to rootPointer
   */
  each(data, callback, schema, pointer) {
    return this.config.each(this, data, callback, schema, pointer);
  }
  eachSchema(callback, schema = this.rootSchema) {
    return this.config.eachSchema(schema, callback);
  }
  getChildSchemaSelection(property, schema) {
    return this.config.getChildSchemaSelection(this, property, schema);
  }
  /**
   * Returns the json-schema of a data-json-pointer.
   *
   * To resolve dynamic schema where the type of json-schema is evaluated by
   * its value, a data object has to be passed in options.
   *
   * Per default this function will return `undefined` for valid properties that
   * do not have a defined schema. Use the option `withSchemaWarning: true` to
   * receive an error with `code: schema-warning` containing the location of its
   * last evaluated json-schema.
   *
   * Notes
   *      - uses draft.step to walk through data and schema
   *
   * @param draft
   * @param pointer - json pointer in data to get the json schema for
   * @param [options.data] - the data object, which includes the json pointers value. This is optional, as
   *    long as no oneOf, anyOf, etc statement is part of the pointers schema
   * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema
   * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition
   * @return resolved json-schema object of requested json-pointer location
   */
  getSchema(options) {
    return this.config.getSchema(this, options);
  }
  /**
   * Create data object matching the given schema
   *
   * @param [data] - optional template data
   * @param [schema] - json schema, defaults to rootSchema
   * @return created template data
   */
  getTemplate(data, schema, opts = this.config.templateDefaultOptions) {
    return this.config.getTemplate(this, data, schema, opts);
  }
  isValid(data, schema, pointer) {
    return this.config.isValid(this, data, schema, pointer);
  }
  resolveAnyOf(data, schema, pointer) {
    return this.config.resolveAnyOf(this, data, schema, pointer);
  }
  resolveAllOf(data, schema) {
    return this.config.resolveAllOf(this, data, schema);
  }
  resolveRef(schema) {
    return this.config.resolveRef(schema, this.rootSchema);
  }
  resolveOneOf(data, schema, pointer) {
    return this.config.resolveOneOf(this, data, schema, pointer);
  }
  setSchema(schema) {
    this.rootSchema = schema;
  }
  /**
   * Returns the json-schema of the given object property or array item.
   * e.g. it steps by one key into the data
   *
   *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and
   *  returns the correct schema.
   *
   * @param  key       - property-name or array-index
   * @param  schema    - json schema of current data
   * @param  data      - parent of key
   * @param  [pointer] - pointer to schema and data (parent of key)
   * @return Schema or Error if failed resolving key
   */
  step(key, schema, data, pointer) {
    return this.config.step(this, key, schema, data, pointer);
  }
  /**
   * Validate data by a json schema
   *
   * @param value - value to validate
   * @param [schema] - json schema, defaults to rootSchema
   * @param [pointer] - json pointer pointing to value (used for error-messages only)
   * @return list of errors or empty
   */
  validate(data, schema, pointer) {
    return this.config.validate(this, data, schema, pointer);
  }
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/addRemoteSchema.js
function addRemoteSchema(draft, url, schema) {
  schema.id = schema.id || url;
  draft.remotes[url] = draft.compileSchema(schema);
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/eachSchema.js
var import_json_pointer3 = __toESM(require_jsonPointer());

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/schema/getTypeDefs.js
var import_json_pointer2 = __toESM(require_jsonPointer());

// node_modules/.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/parser/index.js
var import_W3CEBNF = __toESM(require_W3CEBNF());

// node_modules/.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/parser/jsonQueryGrammar.js
var propertyRegex = "[^?/{}*,()#]+";
var jsonQueryGrammar = `
root ::= ("#" recursion | recursion | (query | pattern) recursion* | "#" SEP? | SEP)
recursion ::= (SEP query | pattern)*

query ::= (ESC escaped ESC | property | all | any | regex) typecheck? lookahead?
property ::= ${propertyRegex}
regex ::= "{" [^}]+ "}"
SEP ::= "/"
all ::= "**"
any ::= "*"

typecheck ::= "?:" ("value" | "boolean" | "string" | "number" | "object" | "array")
lookahead ::= "?" expression ((andExpr | orExpr) expression)*
andExpr ::= S? "&&" S?
orExpr ::= S? "||" S?

expression ::= (exprProperty | ESC escaped ESC) ((isnot | is) (exprProperty | regex | ESC escaped ESC))*
exprProperty ::= [a-zA-Z0-9-_ $]+
escaped ::= [^"]+
is ::= ":"
isnot ::= ":!"
ESC ::= '"'

pattern ::= S? "(" (SEP query | pattern (orPattern? pattern)*)* ")" quantifier? S? lookahead?
quantifier ::= "+" | "*" | [0-9]+
orPattern ::= S? "," S?

S ::= [ ]*
`;

// node_modules/.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/parser/index.js
var parser = new import_W3CEBNF.default.Parser(jsonQueryGrammar);
var parse = (query2) => parser.getAST(query2);

// node_modules/.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/interpreter/keys.js
var VALUE_INDEX = 0;
var POINTER_INDEX = 3;

// node_modules/.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/interpreter/nodes.js
var join = (a, b) => `${a}/${b}`;
var toString2 = Object.prototype.toString;
var rContainer = /Object|Array/;
var isContainer = (v) => rContainer.test(toString2.call(v));
var getTypeOf2 = (v) => toString2.call(v).match(/\s([^\]]+)\]/).pop().toLowerCase();
function nodeAsRegex(node) {
  return new RegExp(node.text.replace(/(^{|}$)/g, ""));
}
function forEach(parent, callback) {
  if (Array.isArray(parent)) {
    parent.forEach(callback);
  } else if (Object.prototype.toString.call(parent) === "[object Object]") {
    Object.keys(parent).forEach(function(key) {
      callback(parent[key], key, parent);
    });
  }
}
function getKeys(value) {
  if (Array.isArray(value)) {
    return value.map(function(value2, index2) {
      return `${index2}`;
    });
  }
  if (Object.prototype.toString.call(value) === "[object Object]") {
    return Object.keys(value);
  }
  return [];
}
var cache = {
  mem: [],
  get(entry, prop) {
    const v = entry[VALUE_INDEX][prop];
    if (cache.mem.includes(v)) {
      return void 0;
    }
    if (isContainer(v)) {
      cache.mem.push(v);
    }
    return [v, prop, entry[VALUE_INDEX], join(entry[POINTER_INDEX], prop)];
  },
  reset() {
    cache.mem.length = 0;
  }
};
var expand = {
  any(node, entry) {
    const value = entry[VALUE_INDEX];
    return getKeys(value).map((prop) => [
      value[prop],
      prop,
      value,
      join(entry[POINTER_INDEX], prop)
    ]);
  },
  all(node, entry) {
    const result = [entry];
    forEach(entry[VALUE_INDEX], (value, prop) => {
      const childEntry = cache.get(entry, prop);
      childEntry && result.push(...expand.all(node, childEntry));
    });
    return result;
  },
  regex(node, entry) {
    const regex = nodeAsRegex(node);
    const value = entry[VALUE_INDEX];
    return getKeys(value).filter((prop) => regex.test(prop)).map((prop) => [
      value[prop],
      prop,
      value,
      join(entry[POINTER_INDEX], prop)
    ]);
  }
};
var select = {
  // alias to property (but escaped)
  escaped: (node, entry) => select.property(node, entry),
  property: (node, entry) => {
    const prop = node.text;
    if (entry[VALUE_INDEX] && entry[VALUE_INDEX][prop] !== void 0) {
      return [
        entry[VALUE_INDEX][prop],
        prop,
        entry[VALUE_INDEX],
        join(entry[POINTER_INDEX], prop)
      ];
    }
  },
  typecheck: (node, entry) => {
    const checkedTyped = node.text.replace(/^\?:/, "");
    if (checkedTyped === "value") {
      return isContainer(entry[VALUE_INDEX]) ? void 0 : entry;
    }
    const type = getTypeOf2(entry[VALUE_INDEX]);
    if (type === checkedTyped) {
      return entry;
    }
  },
  lookahead: (node, entry) => {
    let valid = true;
    let or = false;
    node.children.forEach((expr) => {
      if (expr.type === "expression") {
        const isValid2 = select.expression(expr, entry) !== void 0;
        valid = or === true ? valid || isValid2 : valid && isValid2;
      } else {
        or = expr.type === "orExpr";
      }
    });
    return valid ? entry : void 0;
  },
  expression: (node, entry) => {
    const prop = node.children[0].text;
    const cmp = node.children[1];
    const test = node.children[2];
    const value = entry[VALUE_INDEX];
    if (isContainer(value) === false) {
      return void 0;
    }
    return expressionMatches(value[prop], cmp, test) ? entry : void 0;
  }
};
function expressionMatches(value, cmp, test) {
  if (cmp === void 0) {
    return value !== void 0;
  }
  let valid;
  const valueString = `${value}`;
  if (test.type === "regex") {
    const regex = nodeAsRegex(test);
    valid = regex.test(valueString);
  } else {
    valid = valueString === test.text;
  }
  if (cmp.type === "isnot") {
    valid = valid === false && value !== void 0;
  }
  return valid;
}

// node_modules/.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/interpreter/index.js
function collect(func, input, node, pointer) {
  const result = [];
  for (let i = 0, l = input.length; i < l; i += 1) {
    result.push(...func(node, input[i], node, pointer));
  }
  return result;
}
function reduce(func, input, node, pointer) {
  const result = [];
  for (let i = 0, l = input.length; i < l; i += 1) {
    const output = func(node, input[i], pointer);
    if (output) {
      result.push(output);
    }
  }
  return result;
}
function query(data, ast, pointer) {
  let result = data;
  ast.children.forEach((node) => {
    if (expand[node.type]) {
      result = collect(expand[node.type], result, node, pointer);
    } else if (select[node.type]) {
      result = reduce(select[node.type], result, node, pointer);
    } else {
      throw new Error(`Unknown filter ${node.type}`);
    }
  });
  return result;
}
function runPatternOnce(inputSet, ast, pointer) {
  const resultingSet = [];
  let workingSet = inputSet;
  ast.children.forEach((node) => {
    if (node.type === "orPattern") {
      resultingSet.push(...workingSet);
      workingSet = inputSet;
      return;
    }
    workingSet = runNode(workingSet, node, pointer);
  });
  resultingSet.push(...workingSet);
  return resultingSet;
}
function getIterationCount(quantifier) {
  if (quantifier == null) {
    return 1;
  }
  if (quantifier === "*" || quantifier === "+") {
    return Infinity;
  }
  const count = parseInt(quantifier);
  return isNaN(count) ? 1 : count;
}
function pattern(data, ast, pointer) {
  const result = [];
  const quantifier = ast.children.find((node) => node.type === "quantifier");
  const iterationCount = getIterationCount(quantifier && quantifier.text);
  let workingSet = data;
  if (quantifier && quantifier.text === "*") {
    result.push(...workingSet);
  }
  let count = 0;
  while (workingSet.length > 0 && count < iterationCount) {
    workingSet = runPatternOnce(workingSet, ast, pointer);
    result.push(...workingSet);
    count += 1;
  }
  return result;
}
function skip(data, ast, pointer) {
  let result = data;
  ast.children.forEach((n) => result = runNode(result, n, pointer));
  return result;
}
function runNode(data, ast, pointer) {
  let result;
  if (ast.type === "query") {
    result = query(data, ast, pointer);
  } else if (ast.type === "pattern") {
    result = pattern(data, ast, pointer);
  } else {
    result = skip(data, ast, pointer);
  }
  cache.reset();
  cache.mem.push(data);
  return result;
}
function run(data, ast) {
  cache.reset();
  cache.mem.push(data);
  return runNode([[data, null, null, "#"]], ast);
}

// node_modules/.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/get.js
var returnTypes = {
  value: (r) => r.map((e) => e[VALUE_INDEX]),
  pointer: (r) => r.map((e) => e[POINTER_INDEX]),
  all: (r) => r,
  map: (r) => {
    const map = {};
    r.forEach((e) => map[e[POINTER_INDEX]] = e[VALUE_INDEX]);
    return map;
  }
};
var ReturnType;
(function(ReturnType2) {
  ReturnType2["POINTER"] = "pointer";
  ReturnType2["VALUE"] = "value";
  ReturnType2["ALL"] = "all";
  ReturnType2["MAP"] = "map";
})(ReturnType || (ReturnType = {}));
get.POINTER = ReturnType.POINTER;
get.VALUE = ReturnType.VALUE;
get.ALL = ReturnType.ALL;
get.MAP = ReturnType.MAP;
function get(data, queryString, returnType = ReturnType.VALUE) {
  if (queryString == null) {
    return [];
  }
  queryString = queryString.replace(/(\/$)/g, "");
  if (queryString === "") {
    queryString = "#";
  }
  const ast = parse(queryString);
  if (ast == null) {
    throw new Error(`empty ast for '${queryString}'`);
  }
  if (ast.rest !== "") {
    throw new Error(`Failed parsing queryString from: '${ast.rest}'`);
  }
  const result = run(data, ast);
  if (typeof returnType === "function") {
    return result.map((r) => returnType(...r));
  } else if (returnTypes[returnType]) {
    return returnTypes[returnType](result);
  }
  return result;
}

// node_modules/.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/split.js
var skip2 = ["root", "recursion"];
function buildPath(node, path = []) {
  if (skip2.includes(node.type)) {
    node.children.forEach((n) => buildPath(n, path));
    return path;
  }
  path.push(node.text);
  return path;
}
function split(queryString) {
  if (queryString == null || queryString === "") {
    return [];
  }
  const ast = parse(queryString);
  return buildPath(ast);
}

// node_modules/.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/set.js
var cp = (v) => JSON.parse(JSON.stringify(v));
var toString3 = Object.prototype.toString;
var getType = (v) => toString3.call(v).match(/\s([^\]]+)\]/).pop().toLowerCase();
var isProperty = new RegExp(`^("[^"]+"|${propertyRegex})$`);
var ignoreTypes = ["string", "number", "boolean", "null"];
var isArray2 = /^\[\d*\]$/;
var arrayHasIndex = /^\[(\d+)\]$/;
var isEscaped = /^".+"$/;
var isArrayProp = /(^\[\d*\]$|^\d+$)/;
function convertToIndex(index2) {
  return parseInt(index2.replace(/^(\[|\]$)/, ""));
}
function removeEscape(property) {
  return isEscaped.test(property) ? property.replace(/(^"|"$)/g, "") : property;
}
function insert(array, index2, value) {
  if (array.length <= index2) {
    array[index2] = value;
  } else {
    array.splice(index2, 0, value);
  }
}
function select2(workingSet, query2) {
  const nextSet = [];
  workingSet.forEach((d) => nextSet.push(...get(d[0], query2, ReturnType.ALL)));
  return nextSet;
}
function addToArray(result, index2, value, force) {
  const target = result[0];
  if (/^\[\]$/.test(index2)) {
    target.push(value);
    const i = target.length - 1;
    return [target[i], i, target, `${result[3]}/${i}}`];
  }
  if (force == null && getType(target[index2]) === "object" && getType(value) === "object") {
    Object.assign(target[index2], value);
    return [target[index2], index2, target, `${result[3]}/${index2}}`];
  }
  if (force === set.INSERT_ITEMS || force == null && arrayHasIndex.test(index2)) {
    const arrayIndex = convertToIndex(index2);
    insert(target, arrayIndex, value);
    return [
      target[arrayIndex],
      arrayIndex,
      target,
      `${result[3]}/${arrayIndex}}`
    ];
  }
  if (force === set.REPLACE_ITEMS || force == null) {
    const arrayIndex = convertToIndex(index2);
    target[arrayIndex] = value;
    return [
      target[arrayIndex],
      arrayIndex,
      target,
      `${result[3]}/${arrayIndex}}`
    ];
  }
  throw new Error(`Unknown array index '${index2}' with force-option '${force}'`);
}
function create2(workingSet, query2, keyIsArray, force) {
  query2 = removeEscape(query2);
  return workingSet.filter((o) => {
    if (Array.isArray(o[0]) && isArrayProp.test(query2)) {
      return true;
    }
    return ignoreTypes.includes(getType(o[0][query2])) === false;
  }).map((r) => {
    const container = keyIsArray ? [] : {};
    const o = r[0];
    const containerType = getType(container);
    const itemType = getType(o[query2]);
    if (Array.isArray(o) && itemType !== containerType) {
      return addToArray(r, query2, container, force);
    }
    o[query2] = o[query2] || container;
    return [o[query2], query2, o, `${r[3]}/${query2}`];
  });
}
var InsertMode;
(function(InsertMode2) {
  InsertMode2["REPLACE_ITEMS"] = "replace";
  InsertMode2["INSERT_ITEMS"] = "insert";
})(InsertMode || (InsertMode = {}));
set.REPLACE_ITEMS = InsertMode.REPLACE_ITEMS;
set.INSERT_ITEMS = InsertMode.INSERT_ITEMS;
function set(data, queryString, value, force) {
  if (queryString == null) {
    return cp(data);
  }
  queryString = queryString.replace(/(\/$)/g, "");
  if (queryString === "") {
    return cp(value);
  }
  const result = cp(data);
  let workingSet = [[result, null, null, "#"]];
  const path = split(queryString);
  const property = path.pop();
  const arrayWithoutIndex = isArray2.test(property) && arrayHasIndex.test(property) === false;
  if (isProperty.test(property) === false || arrayWithoutIndex) {
    throw new Error(`Unsupported query '${queryString}' ending with non-property`);
  }
  path.forEach((query2, index2) => {
    if ("__proto__" === query2 || "prototyped" === query2 || "constructor" === query2) {
      return;
    }
    if (isProperty.test(query2) === false) {
      workingSet = select2(workingSet, query2);
      return;
    }
    const nextKey = index2 >= path.length - 1 ? property : path[index2 + 1];
    const insertArray = isArrayProp.test(nextKey);
    workingSet = create2(workingSet, query2, insertArray, force);
  });
  workingSet.forEach((r) => {
    let targetValue = value;
    if (getType(value) === "function") {
      targetValue = value(r[3], property, r[0], `${r[3]}/${property}`);
    }
    const d = r[0];
    if (Array.isArray(d)) {
      addToArray(r, property, targetValue, force);
    } else {
      const unescapedProp = removeEscape(property);
      if ("__proto__" === unescapedProp || "prototyped" === unescapedProp || "constructor" === unescapedProp) {
        return;
      }
      d[unescapedProp] = targetValue;
    }
  });
  return result;
}

// node_modules/.pnpm/@sagold+json-query@6.2.0/node_modules/@sagold/json-query/dist/module/lib/remove.js
var import_json_pointer = __toESM(require_jsonPointer());

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/schema/types.js
var Types = {
  $ref: {
    type: false
  },
  allOf: {
    type: false,
    definitions: ["allOf/*"]
  },
  anyOf: {
    type: false,
    definitions: ["anyOf/*"]
  },
  array: {
    type: true,
    // ignore additionalItems:TypeDef, when items:TypeDef
    definitions: [
      "allOf/*",
      "anyOf/*",
      "oneOf/*",
      "not",
      "items",
      "items/*",
      "additionalItems"
    ],
    validationKeywords: ["minItems", "maxItems", "uniqueItems"],
    keywords: ["items", "additionalItems", "minItems", "maxItems", "uniqueItems"]
  },
  boolean: {
    type: true
  },
  enum: {
    type: false
  },
  integer: {
    type: true,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minimum", "maximum", "multipleOf"]
  },
  not: {
    type: false,
    definitions: ["not"]
  },
  number: {
    type: true,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minimum", "maximum", "multipleOf"]
  },
  null: {
    type: true
  },
  object: {
    type: true,
    // patternProperties also validate properties
    // dependencies:(string, TypeDef) extend current TypeDef
    // additional Properties validate only remaining properties (after properties & pattern)
    definitions: [
      "allOf/*",
      "anyOf/*",
      "oneOf/*",
      "not",
      "properties/*",
      "additionalProperties",
      "patternProperties/*",
      "dependencies/*"
    ],
    validationKeywords: ["minProperties", "maxProperties", "required"],
    keywords: [
      "properties",
      "additionalProperties",
      "patternProperties",
      "dependencies",
      "minProperties",
      "maxProperties",
      "required"
    ]
  },
  oneOf: {
    type: false,
    definitions: ["oneOf/*"]
  },
  string: {
    type: true,
    definitions: ["allOf/*", "anyOf/*", "oneOf/*", "not"],
    validationKeywords: ["minLength", "maxLength", "pattern"]
  }
};
var types_default = Types;

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/schema/getTypeId.js
var typeKeywords = Object.keys(types_default).filter((id) => types_default[id].type === false);
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
function getTypeId(schema) {
  if (isObject(schema) === false) {
    return void 0;
  }
  if (schema.enum) {
    return "enum";
  }
  const type = schema.type;
  if (Array.isArray(type) || types_default[type]) {
    return type;
  }
  const ids = typeKeywords.filter((type2) => schema[type2]);
  if (ids.length === 1) {
    return ids[0];
  }
  if (ids.length === 0) {
    for (let i = 0, l = types_default.object.keywords.length; i < l; i += 1) {
      const keyword = types_default.object.keywords[i];
      if (hasOwnProperty2.call(schema, keyword)) {
        return "object";
      }
    }
    for (let i = 0, l = types_default.array.keywords.length; i < l; i += 1) {
      const keyword = types_default.array.keywords[i];
      if (hasOwnProperty2.call(schema, keyword)) {
        return "array";
      }
    }
    return void 0;
  }
  throw new Error(`Mutiple typeIds [${ids.join(", ")}] matched in ${JSON.stringify(schema)}`);
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/schema/getTypeDefs.js
function getTypeDefs(schema) {
  const defs = [];
  const id = getTypeId(schema);
  if (id == null) {
    return defs;
  }
  let type;
  if (Array.isArray(id)) {
    type = {};
    for (let i = 0, l = id.length; i < l; i += 1) {
      Object.assign(type, types_default[id[i]]);
    }
  } else {
    type = types_default[id];
  }
  if (type.definitions == null) {
    return defs;
  }
  type.definitions.forEach((query2) => {
    get(schema, query2, (value, key, parent, pointer) => {
      if (isObject(value) && getTypeId(value)) {
        defs.push({ pointer: import_json_pointer2.default.join(import_json_pointer2.default.split(pointer), false), def: value });
      }
    });
  });
  return defs;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/eachSchema.js
function nextTypeDefs(schema, pointer) {
  if (this.callback(schema, pointer) === true) {
    return;
  }
  const defs = getTypeDefs(schema);
  defs.forEach((next) => this.nextTypeDefs(next.def, import_json_pointer3.default.join(pointer, next.pointer, false)));
}
function eachDefinition(walk, schema, pointer, key = "definitions") {
  const defs = schema[key];
  Object.keys(defs).forEach((defId) => {
    if (defs[defId] === false || isObject(defs[defId])) {
      walk.nextTypeDefs(defs[defId], import_json_pointer3.default.join(pointer, key, defId, false));
      return;
    }
  });
}
function eachSchema(schema, callback, pointer = "#") {
  const walk = { callback, nextTypeDefs };
  walk.nextTypeDefs(schema, pointer);
  if (schema.definitions != null) {
    walk.callback = (defschema, schemaPointer) => {
      callback(defschema, schemaPointer);
      if (defschema.definitions != null) {
        eachDefinition(walk, defschema, schemaPointer);
      }
    };
    eachDefinition(walk, schema, pointer);
  }
  if (schema.$defs != null) {
    walk.callback = (defschema, schemaPointer) => {
      callback(defschema, schemaPointer);
      if (defschema.definitions != null) {
        eachDefinition(walk, defschema, schemaPointer);
      }
    };
    eachDefinition(walk, schema, pointer, "$defs");
  }
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/compile/joinScope.js
var suffixes = /(#|\/)+$/;
var trailingHash = /#$/;
var isDomain = /^[^:]+:\/\/[^/]+\//;
var trailingFragments = /\/[^/]*$/;
var idAndPointer = /#.*$/;
function joinScope(previous, id) {
  if (previous == null && id == null) {
    return "#";
  }
  if (id == null) {
    return previous.replace(trailingHash, "");
  }
  if (previous == null) {
    return id.replace(trailingHash, "");
  }
  if (id[0] === "#") {
    return `${previous.replace(idAndPointer, "")}${id.replace(suffixes, "")}`;
  }
  if (isDomain.test(id)) {
    return id.replace(trailingHash, "");
  }
  return `${previous.replace(trailingFragments, "")}/${id.replace(trailingHash, "")}`;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/compile/getRef.js
var import_json_pointer4 = __toESM(require_jsonPointer());

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/compile/splitRef.js
var suffixes2 = /(#|\/)+$/g;
var emptyValues = ["", null, "#"];
function splitRef($ref) {
  if (emptyValues.includes($ref)) {
    return [];
  }
  $ref = $ref.replace(suffixes2, "");
  if ($ref.indexOf("#") === -1) {
    return [$ref.replace(suffixes2, "")];
  }
  if ($ref.indexOf("#") === 0) {
    return [$ref.replace(suffixes2, "")];
  }
  const result = $ref.split("#");
  result[0] = result[0].replace(suffixes2, "");
  result[1] = `#${result[1].replace(suffixes2, "")}`;
  return result;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/compile/getRef.js
var suffixes3 = /(#|\/)+$/g;
var isObject2 = (val) => getTypeOf(val) === "object";
function getRef(context, rootSchema, $ref) {
  if (isObject2($ref)) {
    $ref = $ref.__ref || $ref.$ref;
  }
  if ($ref == null) {
    return rootSchema;
  }
  let schema;
  const $remote = $ref.replace(suffixes3, "");
  if (context.remotes[$remote]) {
    schema = context.remotes[$remote];
    if (schema && schema.$ref) {
      return getRef(context, rootSchema, schema.$ref);
    }
    return schema;
  }
  if (context.ids[$ref]) {
    schema = (0, import_json_pointer4.get)(rootSchema, context.ids[$ref]);
    if (schema && schema.$ref) {
      return getRef(context, rootSchema, schema.$ref);
    }
    return schema;
  }
  const fragments = splitRef($ref);
  if (fragments.length === 0) {
    return rootSchema;
  }
  if (fragments.length === 1) {
    $ref = fragments[0];
    if (context.remotes[$ref]) {
      schema = context.remotes[$ref];
      return getRef(context, rootSchema, schema.$ref);
    }
    if (context.ids[$ref]) {
      schema = (0, import_json_pointer4.get)(rootSchema, context.ids[$ref]);
      if (schema && schema.$ref) {
        return getRef(context, rootSchema, schema.$ref);
      }
      return schema;
    }
  }
  if (fragments.length === 2) {
    const base = fragments[0];
    $ref = fragments[1];
    if (context.remotes[base]) {
      if (context.remotes[base].getRef) {
        return context.remotes[base].getRef($ref);
      }
      return getRef(context, context.remotes[base], $ref);
    }
    if (context.ids[base]) {
      return getRef(context, (0, import_json_pointer4.get)(rootSchema, context.ids[base]), $ref);
    }
  }
  schema = (0, import_json_pointer4.get)(rootSchema, context.ids[$ref] || $ref);
  if (schema && schema.$ref) {
    return getRef(context, rootSchema, schema.$ref);
  }
  return schema;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/compile/index.js
var import_json_pointer5 = __toESM(require_jsonPointer());
var COMPILED = "__compiled";
var COMPILED_REF = "__ref";
var GET_REF = "getRef";
var GET_ROOT = "getRoot";
var suffixes4 = /(#|\/)+$/g;
function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {
  if (!schemaToCompile || schemaToCompile[COMPILED] !== void 0) {
    return schemaToCompile;
  }
  const context = { ids: {}, remotes: draft.remotes };
  const rootSchemaAsString = JSON.stringify(schemaToCompile);
  const compiledSchema = JSON.parse(rootSchemaAsString);
  Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });
  Object.defineProperty(compiledSchema, GET_REF, {
    enumerable: false,
    value: getRef.bind(null, context, compiledSchema)
  });
  if (force === false && rootSchemaAsString.includes("$ref") === false) {
    return compiledSchema;
  }
  if (schemaToCompile !== rootSchema) {
    Object.defineProperty(compiledSchema, "definitions", {
      enumerable: false,
      value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, schemaToCompile.definitions, schemaToCompile.$defs)
    });
  }
  const scopes = {};
  const getRoot = () => compiledSchema;
  eachSchema(compiledSchema, (schema, pointer) => {
    var _a2;
    if (schema.id) {
      if (schema.id.startsWith("http") && /(allOf|anyOf|oneOf)\/\d+$/.test(pointer)) {
        const parentPointer2 = pointer.replace(/\/(allOf|anyOf|oneOf)\/\d+$/, "");
        const parentSchema = (0, import_json_pointer5.get)(compiledSchema, parentPointer2);
        schema.id = (_a2 = parentSchema.id) !== null && _a2 !== void 0 ? _a2 : schema.id;
      }
      context.ids[schema.id.replace(suffixes4, "")] = pointer;
    }
    pointer = `#${pointer}`.replace(/##+/, "#");
    const previousPointer = pointer.replace(/\/[^/]+$/, "");
    const parentPointer = pointer.replace(/\/[^/]+\/[^/]+$/, "");
    const previousScope = scopes[previousPointer] || scopes[parentPointer];
    const scope = joinScope(previousScope, schema.id);
    scopes[pointer] = scope;
    if (context.ids[scope] == null) {
      context.ids[scope] = pointer;
    }
    if (schema.$ref && !schema[COMPILED_REF]) {
      Object.defineProperty(schema, COMPILED_REF, {
        enumerable: false,
        value: joinScope(scope, schema.$ref)
      });
      Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });
    }
  });
  return compiledSchema;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/compileSchema.js
var compileSchema_default = compileSchema;

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/each.js
function each(draft, data, callback, schema = draft.rootSchema, pointer = "#") {
  schema = draft.resolveRef(schema);
  callback(schema, data, pointer);
  const dataType = getTypeOf(data);
  if (dataType === "object") {
    Object.keys(data).forEach((key) => {
      const nextSchema = draft.step(key, schema, data, pointer);
      const next = data[key];
      draft.each(next, callback, nextSchema, `${pointer}/${key}`);
    });
  } else if (dataType === "array") {
    data.forEach((next, key) => {
      const nextSchema = draft.step(key, schema, data, pointer);
      draft.each(next, callback, nextSchema, `${pointer}/${key}`);
    });
  }
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/validation/errors.js
var errors = {
  additionalItemsError: createCustomError("AdditionalItemsError"),
  additionalPropertiesError: createCustomError("AdditionalPropertiesError"),
  anyOfError: createCustomError("AnyOfError"),
  allOfError: createCustomError("AllOfError"),
  constError: createCustomError("ConstError"),
  containsError: createCustomError("ContainsError"),
  containsArrayError: createCustomError("ContainsArrayError"),
  containsAnyError: createCustomError("ContainsAnyError"),
  enumError: createCustomError("EnumError"),
  forbiddenPropertyError: createCustomError("ForbiddenPropertyError"),
  formatURLError: createCustomError("FormatURLError"),
  formatURIError: createCustomError("FormatURIError"),
  formatURIReferenceError: createCustomError("FormatURIReferenceError"),
  formatURITemplateError: createCustomError("FormatURITemplateError"),
  formatDateError: createCustomError("FormatDateError"),
  formatDateTimeError: createCustomError("FormatDateTimeError"),
  formatEmailError: createCustomError("FormatEmailError"),
  formatHostnameError: createCustomError("FormatHostnameError"),
  formatIPV4Error: createCustomError("FormatIPV4Error"),
  formatIPV4LeadingZeroError: createCustomError("FormatIPV4LeadingZeroError"),
  formatIPV6Error: createCustomError("FormatIPV6Error"),
  formatIPV6LeadingZeroError: createCustomError("FormatIPV6LeadingZeroError"),
  formatJsonPointerError: createCustomError("FormatJsonPointerError"),
  formatRegExError: createCustomError("FormatRegExError"),
  formatTimeError: createCustomError("FormatTimeError"),
  invalidSchemaError: createCustomError("InvalidSchemaError"),
  invalidDataError: createCustomError("InvalidDataError"),
  invalidTypeError: createCustomError("InvalidTypeError"),
  invalidPropertyNameError: createCustomError("InvalidPropertyNameError"),
  maximumError: createCustomError("MaximumError"),
  maxItemsError: createCustomError("MaxItemsError"),
  maxLengthError: createCustomError("MaxLengthError"),
  maxPropertiesError: createCustomError("MaxPropertiesError"),
  minimumError: createCustomError("MinimumError"),
  minItemsError: createCustomError("MinItemsError"),
  minItemsOneError: createCustomError("MinItemsOneError"),
  minLengthError: createCustomError("MinLengthError"),
  minLengthOneError: createCustomError("MinLengthOneError"),
  minPropertiesError: createCustomError("MinPropertiesError"),
  missingDependencyError: createCustomError("MissingDependencyError"),
  missingOneOfPropertyError: createCustomError("MissingOneOfPropertyError"),
  multipleOfError: createCustomError("MultipleOfError"),
  multipleOneOfError: createCustomError("MultipleOneOfError"),
  noAdditionalPropertiesError: createCustomError("NoAdditionalPropertiesError"),
  notError: createCustomError("NotError"),
  oneOfError: createCustomError("OneOfError"),
  oneOfPropertyError: createCustomError("OneOfPropertyError"),
  patternError: createCustomError("PatternError"),
  patternPropertiesError: createCustomError("PatternPropertiesError"),
  requiredPropertyError: createCustomError("RequiredPropertyError"),
  schemaWarning: createCustomError("SchemaWarning"),
  typeError: createCustomError("TypeError"),
  undefinedValueError: createCustomError("UndefinedValueError"),
  uniqueItemsError: createCustomError("UniqueItemsError"),
  unknownPropertyError: createCustomError("UnknownPropertyError"),
  valueNotEmptyError: createCustomError("ValueNotEmptyError")
};
var errors_default = errors;

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/validation/format.js
var import_valid_url = __toESM(require_valid_url());
var import_smtp_address_parser = __toESM(require_lib());
var isValidDateTime = new RegExp("^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$");
var isValidIPV4 = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
var isValidIPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
var isValidHostname = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/;
var matchDate = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var matchTime = /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var isValidJsonPointer = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var isValidRelativeJsonPointer = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var isValidURIRef = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var isValidURITemplate = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var formatValidators = {
  date: (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    const matches = value.match(matchDate);
    if (!matches) {
      return draft.errors.formatDateTimeError({ value, pointer, schema });
    }
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    const isLeapYear = year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    if (month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear ? 29 : DAYS[month])) {
      return void 0;
    }
    return draft.errors.formatDateError({ value, pointer, schema });
  },
  "date-time": (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (value === "" || isValidDateTime.test(value)) {
      if (new Date(value).toString() === "Invalid Date") {
        return draft.errors.formatDateTimeError({ value, pointer, schema });
      }
      return void 0;
    }
    return draft.errors.formatDateTimeError({ value, pointer, schema });
  },
  email: (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (value[0] === '"') {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    const [name, host, ...rest] = value.split("@");
    if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    if (name[0] === "." || name.endsWith(".") || name.includes("..")) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name)) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    if (!host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part))) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    return void 0;
  },
  /**
   * @draft 7
   * [RFC6531] https://json-schema.org/draft-07/json-schema-validation.html#RFC6531
   */
  "idn-email": (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    try {
      (0, import_smtp_address_parser.parse)(value);
      return void 0;
    } catch (e) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
  },
  hostname: (draft, schema, value, pointer) => {
    if (typeof value !== "string") {
      return void 0;
    }
    if (value === "" || isValidHostname.test(value)) {
      return void 0;
    }
    return draft.errors.formatHostnameError({ value, pointer, schema });
  },
  ipv4: (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (value && value[0] === "0") {
      return draft.errors.formatIPV4LeadingZeroError({ value, pointer, schema });
    }
    if (value.length <= 15 && isValidIPV4.test(value)) {
      return void 0;
    }
    return draft.errors.formatIPV4Error({ value, pointer, schema });
  },
  ipv6: (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (value && value[0] === "0") {
      return draft.errors.formatIPV6LeadingZeroError({ value, pointer, schema });
    }
    if (value.length <= 45 && isValidIPV6.test(value)) {
      return void 0;
    }
    return draft.errors.formatIPV6Error({ value, pointer, schema });
  },
  "json-pointer": (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (isValidJsonPointer.test(value)) {
      return void 0;
    }
    return draft.errors.formatJsonPointerError({ value, pointer, schema });
  },
  "relative-json-pointer": (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (isValidRelativeJsonPointer.test(value)) {
      return void 0;
    }
    return draft.errors.formatJsonPointerError({ value, pointer, schema });
  },
  regex: (draft, schema, value, pointer) => {
    if (typeof value === "string" && /\\Z$/.test(value) === false) {
      try {
        new RegExp(value);
        return void 0;
      } catch (e) {
      }
      return draft.errors.formatRegExError({ value, pointer, schema });
    }
    if (typeof value === "object" || typeof value === "number" || Array.isArray(value)) {
      return void 0;
    }
    return draft.errors.formatRegExError({ value, pointer, schema });
  },
  // hh:mm:ss.sTZD
  // https://opis.io/json-schema/2.x/formats.html
  // regex https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch04s07.html
  time: (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    const matches = value.match(matchTime);
    return matches ? void 0 : draft.errors.formatDateTimeError({ value, pointer, schema });
  },
  uri: (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (import_valid_url.default.isUri(value)) {
      return void 0;
    }
    return draft.errors.formatURIError({ value, pointer, schema });
  },
  "uri-reference": (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (isValidURIRef.test(value)) {
      return void 0;
    }
    return draft.errors.formatURIReferenceError({ value, pointer, schema });
  },
  "uri-template": (draft, schema, value, pointer) => {
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (isValidURITemplate.test(value)) {
      return void 0;
    }
    return draft.errors.formatURITemplateError({ value, pointer, schema });
  },
  url: (draft, schema, value, pointer) => {
    if (value === "" || import_valid_url.default.isWebUri(value)) {
      return void 0;
    }
    return draft.errors.formatURLError({ value, pointer, schema });
  }
};
var format_default = formatValidators;

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/getSchema.js
var import_json_pointer6 = __toESM(require_jsonPointer());
var emptyObject = {};
function getSchema(draft, options = emptyObject) {
  const { pointer = "#", data, schema = draft.rootSchema, withSchemaWarning = false } = options;
  const path = import_json_pointer6.default.split(pointer);
  const result = _getSchema(draft, draft.resolveRef(schema), path, "#", data);
  if (!withSchemaWarning && (result === null || result === void 0 ? void 0 : result.code) === "schema-warning") {
    return void 0;
  }
  return result;
}
function _getSchema(draft, schema, path, pointer, data = emptyObject) {
  if (path.length === 0) {
    return draft.resolveRef(schema);
  }
  const key = path.shift();
  schema = draft.step(key, schema, data, pointer);
  if (isJsonError(schema)) {
    return schema;
  }
  data = data[key];
  return _getSchema(draft, schema, path, `${pointer}/${key}`, data);
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/isEmpty.js
function isEmpty(v) {
  const type = getTypeOf(v);
  switch (type) {
    case "string":
    case "array":
      return (v === null || v === void 0 ? void 0 : v.length) === 0;
    case "null":
    case "undefined":
      return true;
    case "object":
      return Object.keys(v).length === 0;
    default:
      return false;
  }
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/getTemplate.js
var defaultOptions = settings_default.templateDefaultOptions;
var cache2;
function shouldResolveRef(schema, pointer) {
  const { $ref } = schema;
  if ($ref == null) {
    return true;
  }
  const value = cache2[pointer] == null || cache2[pointer][$ref] == null ? 0 : cache2[pointer][$ref];
  return value < settings_default.GET_TEMPLATE_RECURSION_LIMIT;
}
function resolveRef2(draft, schema, pointer) {
  const { $ref } = schema;
  if ($ref == null) {
    return schema;
  }
  cache2[pointer] = cache2[pointer] || {};
  cache2[pointer][$ref] = cache2[pointer][$ref] || 0;
  cache2[pointer][$ref] += 1;
  return draft.resolveRef(schema);
}
function convertValue(type, value) {
  if (type === "string") {
    return JSON.stringify(value);
  } else if (typeof value !== "string") {
    return null;
  }
  try {
    value = JSON.parse(value);
    if (typeof value === type) {
      return value;
    }
  } catch (e) {
  }
  return null;
}
function createTemplateSchema(draft, schema, data, pointer, opts) {
  if (getTypeOf(schema) !== "object") {
    return Object.assign({ pointer }, schema);
  }
  if (shouldResolveRef(schema, pointer) === false && data == null) {
    return false;
  }
  let templateSchema = copy_default(resolveRef2(draft, schema, pointer));
  if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {
    if (shouldResolveRef(schema.anyOf[0], `${pointer}/anyOf/0`)) {
      const resolvedAnyOf = resolveRef2(draft, schema.anyOf[0], `${pointer}/anyOf/0`);
      templateSchema = merge_default(templateSchema, resolvedAnyOf);
      templateSchema.pointer = schema.anyOf[0].$ref || templateSchema.pointer;
    }
    delete templateSchema.anyOf;
  }
  if (Array.isArray(schema.allOf)) {
    const mayResolve = schema.allOf.map((allOf, index2) => shouldResolveRef(allOf, `${pointer}/allOf/${index2}`)).reduceRight((next, before) => next && before, true);
    if (mayResolve) {
      const allOf = [];
      let extendedData = copy_default(data);
      for (let i = 0; i < schema.allOf.length; i += 1) {
        allOf.push(resolveSchema(draft, schema.allOf[i], extendedData));
        extendedData = getTemplate(draft, extendedData, { type: schema.type, ...allOf[i] }, `${pointer}/allOf/${i}`, opts);
      }
      const resolvedSchema = mergeAllOfSchema(draft, { allOf });
      if (resolvedSchema) {
        templateSchema = mergeSchema(templateSchema, resolvedSchema);
      }
    }
  }
  templateSchema.pointer = templateSchema.pointer || schema.$ref || pointer;
  return templateSchema;
}
var isJsonSchema = (template) => template && typeof template === "object";
function getTemplate(draft, data, _schema, pointer, opts) {
  var _a2;
  if (_schema == null) {
    throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(data)}`);
  }
  if (pointer == null) {
    throw new Error("Missing pointer");
  }
  let schema = createTemplateSchema(draft, _schema, data, pointer, opts);
  if (!isJsonSchema(schema)) {
    return void 0;
  }
  pointer = schema.pointer;
  if (schema === null || schema === void 0 ? void 0 : schema.const) {
    return schema.const;
  }
  if (Array.isArray(schema.oneOf)) {
    if (isEmpty(data)) {
      const type2 = schema.oneOf[0].type || schema.type || schema.const && typeof schema.const || getTypeOf(data);
      schema = { ...schema.oneOf[0], type: type2 };
    } else {
      const resolvedSchema = resolveOneOfFuzzy(draft, data, schema);
      if (isJsonError(resolvedSchema)) {
        if (data != null && opts.removeInvalidData !== true) {
          return data;
        }
        schema = schema.oneOf[0];
        data = void 0;
      } else {
        resolvedSchema.type = (_a2 = resolvedSchema.type) !== null && _a2 !== void 0 ? _a2 : schema.type;
        schema = resolvedSchema;
      }
    }
  }
  if (!isJsonSchema(schema) || schema.type == null) {
    return void 0;
  }
  if (data instanceof File) {
    return data;
  }
  const type = Array.isArray(schema.type) ? selectType(schema.type, data, schema.default) : schema.type;
  const javascriptTypeOfData = getTypeOf(data);
  if (data != null && javascriptTypeOfData !== type && !(javascriptTypeOfData === "number" && type === "integer")) {
    data = convertValue(type, data);
  }
  if (TYPE[type] == null) {
    if (opts.removeInvalidData) {
      return void 0;
    }
    return data;
  }
  const templateData = TYPE[type](draft, schema, data, pointer, opts);
  return templateData;
}
function selectType(types, data, defaultValue) {
  if (data == void 0) {
    if (defaultValue != null) {
      const defaultType = getTypeOf(defaultValue);
      if (types.includes(defaultType)) {
        return defaultType;
      }
    }
    return types[0];
  }
  const dataType = getTypeOf(data);
  if (types.includes(dataType)) {
    return dataType;
  }
  return types[0];
}
var TYPE = {
  null: (draft, schema, data) => getDefault(schema, data, null),
  string: (draft, schema, data) => getDefault(schema, data, ""),
  number: (draft, schema, data) => getDefault(schema, data, 0),
  integer: (draft, schema, data) => getDefault(schema, data, 0),
  boolean: (draft, schema, data) => getDefault(schema, data, false),
  object: (draft, schema, data, pointer, opts) => {
    var _a2;
    const template = schema.default === void 0 ? {} : schema.default;
    const d = {};
    const required = opts.extendDefaults === false && schema.default !== void 0 ? [] : (_a2 = schema.required) !== null && _a2 !== void 0 ? _a2 : [];
    if (schema.properties) {
      Object.keys(schema.properties).forEach((key) => {
        const value = data == null || data[key] == null ? template[key] : data[key];
        const isRequired = required.includes(key);
        if (value != null || isRequired || opts.addOptionalProps) {
          d[key] = getTemplate(draft, value, schema.properties[key], `${pointer}/properties/${key}`, opts);
        }
      });
    }
    let dependenciesSchema = resolveDependencies(draft, schema, d);
    if (dependenciesSchema) {
      dependenciesSchema = mergeSchema(schema, dependenciesSchema);
      delete dependenciesSchema.dependencies;
      const dependencyData = getTemplate(draft, data, dependenciesSchema, `${pointer}/dependencies`, opts);
      Object.assign(d, dependencyData);
    }
    if (data) {
      if (opts.removeInvalidData === true && (schema.additionalProperties === false || getTypeOf(schema.additionalProperties) === "object")) {
        if (getTypeOf(schema.additionalProperties) === "object") {
          Object.keys(data).forEach((key) => {
            if (d[key] == null) {
              if (draft.isValid(data[key], schema.additionalProperties)) {
                d[key] = data[key];
              }
            }
          });
        }
      } else {
        Object.keys(data).forEach((key) => d[key] == null && (d[key] = data[key]));
      }
    }
    const ifSchema = resolveIfSchema(draft, schema, d);
    if (ifSchema) {
      const additionalData = getTemplate(draft, d, { type: "object", ...ifSchema }, pointer, opts);
      Object.assign(d, additionalData);
    }
    return d;
  },
  // build array type of items, ignores additionalItems
  array: (draft, schema, data, pointer, opts) => {
    var _a2, _b;
    if (schema.items == null) {
      return data || [];
    }
    const template = schema.default === void 0 ? [] : schema.default;
    const d = data || template;
    const minItems = opts.extendDefaults === false && schema.default !== void 0 ? 0 : schema.minItems || 0;
    if (Array.isArray(schema.items)) {
      for (let i = 0, l = Math.max(minItems !== null && minItems !== void 0 ? minItems : 0, (_b = (_a2 = schema.items) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0); i < l; i += 1) {
        d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], schema.items[i], `${pointer}/items/${i}`, opts);
      }
      return d;
    }
    if (getTypeOf(schema.items) !== "object") {
      return d;
    }
    const templateSchema = createTemplateSchema(draft, schema.items, data, pointer, opts);
    if (templateSchema === false) {
      return d;
    }
    pointer = templateSchema.pointer || pointer;
    if (templateSchema.oneOf && d.length === 0) {
      const oneOfSchema = templateSchema.oneOf[0];
      for (let i = 0; i < minItems; i += 1) {
        d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], oneOfSchema, `${pointer}/oneOf/0`, opts);
      }
      return d;
    }
    if (templateSchema.oneOf && d.length > 0) {
      const itemCount = Math.max(minItems, d.length);
      for (let i = 0; i < itemCount; i += 1) {
        let value = d[i] == null ? template[i] : d[i];
        let one = resolveOneOfFuzzy(draft, value, templateSchema);
        if (one == null || isJsonError(one)) {
          if (value != null && opts.removeInvalidData !== true) {
            d[i] = value;
          } else {
            value = void 0;
            one = templateSchema.oneOf[0];
            d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);
          }
        } else {
          d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);
        }
      }
      return d;
    }
    if (templateSchema.type) {
      for (let i = 0, l = Math.max(minItems, d.length); i < l; i += 1) {
        d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], templateSchema, `${pointer}/items`, opts);
      }
      return d;
    }
    return d;
  }
};
function getDefault(schema, templateValue, initValue) {
  if (templateValue != null) {
    return templateValue;
  } else if (schema.const) {
    return schema.const;
  } else if (schema.default === void 0 && Array.isArray(schema.enum)) {
    return schema.enum[0];
  } else if (schema.default === void 0) {
    return initValue;
  }
  return schema.default;
}
var getTemplate_default = (draft, data, schema = draft.rootSchema, opts) => {
  cache2 = {};
  if (opts) {
    return getTemplate(draft, data, schema, "#", { ...defaultOptions, ...opts });
  }
  return getTemplate(draft, data, schema, "#", defaultOptions);
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/isValid.js
function isValid(draft, value, schema = draft.rootSchema, pointer = "#") {
  return draft.validate(value, schema, pointer).length === 0;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/punycode.ucs2decode.js
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/utils/getPrecision.js
function getPrecision(value) {
  const string = `${value}`;
  const index2 = string.indexOf(".");
  return index2 === -1 ? 0 : string.length - (index2 + 1);
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/validation/keyword.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var hasOwnProperty3 = Object.prototype.hasOwnProperty;
var hasProperty = (value, property) => !(value[property] === void 0 || !hasOwnProperty3.call(value, property));
var KeywordValidation = {
  additionalProperties: (draft, schema, value, pointer) => {
    if (schema.additionalProperties === true || schema.additionalProperties == null) {
      return void 0;
    }
    if (getTypeOf(schema.patternProperties) === "object" && schema.additionalProperties === false) {
      return void 0;
    }
    const errors2 = [];
    let receivedProperties = Object.keys(value).filter((prop) => settings_default.propertyBlacklist.includes(prop) === false);
    const expectedProperties = Object.keys(schema.properties || {});
    if (getTypeOf(schema.patternProperties) === "object") {
      const patterns = Object.keys(schema.patternProperties).map((pattern2) => new RegExp(pattern2));
      receivedProperties = receivedProperties.filter((prop) => {
        for (let i = 0; i < patterns.length; i += 1) {
          if (patterns[i].test(prop)) {
            return false;
          }
        }
        return true;
      });
    }
    for (let i = 0, l = receivedProperties.length; i < l; i += 1) {
      const property = receivedProperties[i];
      if (expectedProperties.indexOf(property) === -1) {
        const additionalIsObject = isObject(schema.additionalProperties);
        if (additionalIsObject && Array.isArray(schema.additionalProperties.oneOf)) {
          const result = draft.resolveOneOf(value[property], schema.additionalProperties, `${pointer}/${property}`);
          if (isJsonError(result)) {
            errors2.push(draft.errors.additionalPropertiesError({
              pointer,
              schema: schema.additionalProperties,
              value,
              property: receivedProperties[i],
              properties: expectedProperties,
              // pass all validation errors
              errors: result.data.errors
            }));
          } else {
            errors2.push(...draft.validate(value[property], result, pointer));
          }
        } else if (additionalIsObject) {
          errors2.push(...draft.validate(value[property], schema.additionalProperties, `${pointer}/${property}`));
        } else {
          errors2.push(draft.errors.noAdditionalPropertiesError({
            pointer,
            schema,
            value,
            property: receivedProperties[i],
            properties: expectedProperties
          }));
        }
      }
    }
    return errors2;
  },
  allOf: validateAllOf,
  anyOf: validateAnyOf,
  dependencies: validateDependencies,
  enum: (draft, schema, value, pointer) => {
    const type = getTypeOf(value);
    if (type === "object" || type === "array") {
      const valueStr = JSON.stringify(value);
      for (let i = 0; i < schema.enum.length; i += 1) {
        if (JSON.stringify(schema.enum[i]) === valueStr) {
          return void 0;
        }
      }
    } else if (schema.enum.includes(value)) {
      return void 0;
    }
    return draft.errors.enumError({ pointer, schema, value, values: schema.enum });
  },
  format: (draft, schema, value, pointer) => {
    if (draft.validateFormat[schema.format]) {
      const errors2 = draft.validateFormat[schema.format](draft, schema, value, pointer);
      return errors2;
    }
    return void 0;
  },
  items: (draft, schema, value, pointer) => {
    if (schema.items === false) {
      if (Array.isArray(value) && value.length === 0) {
        return void 0;
      }
      return draft.errors.invalidDataError({ pointer, value, schema });
    }
    const errors2 = [];
    for (let i = 0; i < value.length; i += 1) {
      const itemData = value[i];
      const itemSchema = draft.step(i, schema, value, pointer);
      if (isJsonError(itemSchema)) {
        return [itemSchema];
      }
      const itemErrors = draft.validate(itemData, itemSchema, `${pointer}/${i}`);
      errors2.push(...itemErrors);
    }
    return errors2;
  },
  maximum: (draft, schema, value, pointer) => {
    if (isNaN(schema.maximum)) {
      return void 0;
    }
    if (schema.maximum && schema.maximum < value) {
      return draft.errors.maximumError({
        maximum: schema.maximum,
        length: value,
        value,
        pointer,
        schema
      });
    }
    if (schema.maximum && schema.exclusiveMaximum === true && schema.maximum === value) {
      return draft.errors.maximumError({
        maximum: schema.maximum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  maxItems: (draft, schema, value, pointer) => {
    if (isNaN(schema.maxItems)) {
      return void 0;
    }
    if (schema.maxItems < value.length) {
      return draft.errors.maxItemsError({
        maximum: schema.maxItems,
        length: value.length,
        schema,
        value,
        pointer
      });
    }
    return void 0;
  },
  maxLength: (draft, schema, value, pointer) => {
    if (isNaN(schema.maxLength)) {
      return void 0;
    }
    const lengthOfString = ucs2decode(value).length;
    if (schema.maxLength < lengthOfString) {
      return draft.errors.maxLengthError({
        maxLength: schema.maxLength,
        length: lengthOfString,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  maxProperties: (draft, schema, value, pointer) => {
    const propertyCount = Object.keys(value).length;
    if (isNaN(schema.maxProperties) === false && schema.maxProperties < propertyCount) {
      return draft.errors.maxPropertiesError({
        maxProperties: schema.maxProperties,
        length: propertyCount,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minLength: (draft, schema, value, pointer) => {
    if (isNaN(schema.minLength)) {
      return void 0;
    }
    const lengthOfString = ucs2decode(value).length;
    if (schema.minLength > lengthOfString) {
      if (schema.minLength === 1) {
        return draft.errors.minLengthOneError({
          minLength: schema.minLength,
          length: lengthOfString,
          pointer,
          schema,
          value
        });
      }
      return draft.errors.minLengthError({
        minLength: schema.minLength,
        length: lengthOfString,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minimum: (draft, schema, value, pointer) => {
    if (isNaN(schema.minimum)) {
      return void 0;
    }
    if (schema.minimum > value) {
      return draft.errors.minimumError({
        minimum: schema.minimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    if (schema.exclusiveMinimum === true && schema.minimum === value) {
      return draft.errors.minimumError({
        minimum: schema.minimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minItems: (draft, schema, value, pointer) => {
    if (isNaN(schema.minItems)) {
      return void 0;
    }
    if (schema.minItems > value.length) {
      if (schema.minItems === 1) {
        return draft.errors.minItemsOneError({
          minItems: schema.minItems,
          length: value.length,
          pointer,
          schema,
          value
        });
      }
      return draft.errors.minItemsError({
        minItems: schema.minItems,
        length: value.length,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minProperties: (draft, schema, value, pointer) => {
    if (isNaN(schema.minProperties)) {
      return void 0;
    }
    const propertyCount = Object.keys(value).length;
    if (schema.minProperties > propertyCount) {
      return draft.errors.minPropertiesError({
        minProperties: schema.minProperties,
        length: propertyCount,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  multipleOf: (draft, schema, value, pointer) => {
    if (isNaN(schema.multipleOf) || typeof value !== "number") {
      return void 0;
    }
    const valuePrecision = getPrecision(value);
    const multiplePrecision = getPrecision(schema.multipleOf);
    if (valuePrecision > multiplePrecision) {
      return draft.errors.multipleOfError({
        multipleOf: schema.multipleOf,
        value,
        pointer,
        schema
      });
    }
    const precision = Math.pow(10, multiplePrecision);
    const val = Math.round(value * precision);
    const multiple = Math.round(schema.multipleOf * precision);
    if (val % multiple / precision !== 0) {
      return draft.errors.multipleOfError({
        multipleOf: schema.multipleOf,
        value,
        pointer,
        schema
      });
    }
    return void 0;
  },
  not: (draft, schema, value, pointer) => {
    const errors2 = [];
    if (draft.validate(value, schema.not, pointer).length === 0) {
      errors2.push(draft.errors.notError({ value, not: schema.not, pointer, schema }));
    }
    return errors2;
  },
  oneOf: validateOneOf,
  pattern: (draft, schema, value, pointer) => {
    const pattern2 = new RegExp(schema.pattern, "u");
    if (pattern2.test(value) === false) {
      return draft.errors.patternError({
        pattern: schema.pattern,
        description: schema.patternExample || schema.pattern,
        received: value,
        schema,
        value,
        pointer
      });
    }
    return void 0;
  },
  patternProperties: (draft, schema, value, pointer) => {
    const properties = schema.properties || {};
    const pp = schema.patternProperties;
    if (getTypeOf(pp) !== "object") {
      return void 0;
    }
    const errors2 = [];
    const keys = Object.keys(value);
    const patterns = Object.keys(pp).map((expr) => ({
      regex: new RegExp(expr),
      patternSchema: pp[expr]
    }));
    keys.forEach((key) => {
      let patternFound = false;
      for (let i = 0, l = patterns.length; i < l; i += 1) {
        if (patterns[i].regex.test(key)) {
          patternFound = true;
          const valErrors = draft.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);
          if (valErrors && valErrors.length > 0) {
            errors2.push(...valErrors);
          }
        }
      }
      if (properties[key]) {
        return;
      }
      if (patternFound === false && schema.additionalProperties === false) {
        errors2.push(draft.errors.patternPropertiesError({
          key,
          pointer,
          schema,
          value,
          patterns: Object.keys(pp).join(",")
        }));
      }
    });
    return errors2;
  },
  properties: (draft, schema, value, pointer) => {
    const errors2 = [];
    const keys = Object.keys(schema.properties || {});
    for (let i = 0; i < keys.length; i += 1) {
      const key = keys[i];
      if (hasProperty(value, key)) {
        const itemSchema = draft.step(key, schema, value, pointer);
        const keyErrors = draft.validate(value[key], itemSchema, `${pointer}/${key}`);
        errors2.push(...keyErrors);
      }
    }
    return errors2;
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword
  propertiesRequired: (draft, schema, value, pointer) => {
    const errors2 = [];
    const keys = Object.keys(schema.properties || {});
    for (let i = 0; i < keys.length; i += 1) {
      const key = keys[i];
      if (value[key] === void 0) {
        errors2.push(draft.errors.requiredPropertyError({ key, pointer, schema, value }));
      } else {
        const itemSchema = draft.step(key, schema, value, pointer);
        const keyErrors = draft.validate(value[key], itemSchema, `${pointer}/${key}`);
        errors2.push(...keyErrors);
      }
    }
    return errors2;
  },
  required: (draft, schema, value, pointer) => {
    if (Array.isArray(schema.required) === false) {
      return void 0;
    }
    return schema.required.map((property) => {
      if (!hasProperty(value, property)) {
        return draft.errors.requiredPropertyError({
          key: property,
          pointer,
          schema,
          value
        });
      }
      return void 0;
    });
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword
  requiredNotEmpty: (draft, schema, value, pointer) => {
    if (Array.isArray(schema.required) === false) {
      return void 0;
    }
    return schema.required.map((property) => {
      if (value[property] == null || value[property] === "") {
        return draft.errors.valueNotEmptyError({
          property,
          pointer: `${pointer}/${property}`,
          schema,
          value
        });
      }
      return void 0;
    });
  },
  uniqueItems: (draft, schema, value, pointer) => {
    if ((Array.isArray(value) && schema.uniqueItems) === false) {
      return void 0;
    }
    const duplicates = [];
    const errors2 = [];
    value.forEach((item, index2) => {
      for (let i = index2 + 1; i < value.length; i += 1) {
        if ((0, import_fast_deep_equal.default)(item, value[i]) && !duplicates.includes(i)) {
          errors2.push(draft.errors.uniqueItemsError({
            pointer: `${pointer}/${i}`,
            duplicatePointer: `${pointer}/${index2}`,
            arrayPointer: pointer,
            value: JSON.stringify(item),
            schema
          }));
          duplicates.push(i);
        }
      }
    });
    return errors2;
  }
};
var keyword_default = KeywordValidation;

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/createSchemaOf.js
function createSchemaOf(data) {
  if (data === void 0) {
    return void 0;
  }
  const schema = {
    type: getTypeOf(data)
  };
  if (schema.type === "object" && isObject(data)) {
    schema.properties = {};
    Object.keys(data).forEach((key) => schema.properties[key] = createSchemaOf(data[key]));
  }
  if (schema.type === "array" && Array.isArray(data)) {
    if (data.length === 1) {
      schema.items = createSchemaOf(data[0]);
    } else {
      schema.items = data.map(createSchemaOf);
    }
  }
  return schema;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/step.js
var stepType = {
  array: (draft, key, schema, data, pointer) => {
    const itemValue = data === null || data === void 0 ? void 0 : data[key];
    const itemsType = getTypeOf(schema.items);
    if (itemsType === "object") {
      return reduceSchema(draft, schema.items, itemValue, `${pointer}/${key}`) || draft.resolveRef(schema.items);
    }
    if (itemsType === "array") {
      if (schema.items[key] === true) {
        return createSchemaOf(itemValue);
      }
      if (schema.items[key] === false) {
        return draft.errors.invalidDataError({
          key,
          value: itemValue,
          pointer,
          schema
        });
      }
      if (schema.items[key]) {
        return draft.resolveRef(schema.items[key]);
      }
      if (schema.additionalItems === false) {
        return draft.errors.additionalItemsError({
          key,
          value: itemValue,
          pointer,
          schema
        });
      }
      if (schema.additionalItems === true || schema.additionalItems === void 0) {
        return createSchemaOf(itemValue);
      }
      if (getTypeOf(schema.additionalItems) === "object") {
        return schema.additionalItems;
      }
      throw new Error(`Invalid schema ${JSON.stringify(schema, null, 2)} for ${JSON.stringify(data, null, 2)}`);
    }
    if (schema.additionalItems !== false && itemValue) {
      return createSchemaOf(itemValue);
    }
    return new Error(`Invalid array schema for ${key} at ${pointer}`);
  },
  object: (draft, key, schema, data, pointer) => {
    var _a2;
    schema = reduceSchema(draft, schema, data, pointer);
    const property = (_a2 = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _a2 === void 0 ? void 0 : _a2[key];
    if (property !== void 0) {
      if (property === false) {
        return draft.errors.forbiddenPropertyError({
          property: key,
          value: data,
          pointer,
          schema
        });
      } else if (property === true) {
        return createSchemaOf(data === null || data === void 0 ? void 0 : data[key]);
      }
      const targetSchema = draft.resolveRef(property);
      if (isJsonError(targetSchema)) {
        return targetSchema;
      }
      if (targetSchema && Array.isArray(targetSchema.oneOf)) {
        const resolvedSchema = draft.resolveOneOf(data[key], targetSchema, `${pointer}/${key}`);
        for (const p in targetSchema) {
          if (p !== "oneOf" && resolvedSchema[p] === void 0) {
            resolvedSchema[p] = targetSchema[p];
          }
        }
        return resolvedSchema;
      }
      if (targetSchema) {
        return targetSchema;
      }
    }
    const { patternProperties } = schema;
    if (getTypeOf(patternProperties) === "object") {
      let regex;
      const patterns = Object.keys(patternProperties);
      for (let i = 0, l = patterns.length; i < l; i += 1) {
        regex = new RegExp(patterns[i]);
        if (regex.test(key)) {
          return patternProperties[patterns[i]];
        }
      }
    }
    const { additionalProperties } = schema;
    if (getTypeOf(additionalProperties) === "object") {
      return schema.additionalProperties;
    }
    if (data && (additionalProperties === void 0 || additionalProperties === true)) {
      return createSchemaOf(data[key]);
    }
    return draft.errors.unknownPropertyError({
      property: key,
      value: data,
      pointer: `${pointer}`,
      schema
    });
  }
};
function step(draft, key, schema, data, pointer = "#") {
  var _a2;
  const typeOfData = getTypeOf(data);
  let schemaType = (_a2 = schema.type) !== null && _a2 !== void 0 ? _a2 : typeOfData;
  if (Array.isArray(schemaType)) {
    if (!schemaType.includes(typeOfData)) {
      return draft.errors.typeError({
        value: data,
        pointer,
        expected: schema.type,
        received: typeOfData,
        schema
      });
    }
    schemaType = typeOfData;
  }
  const stepFunction = stepType[schemaType];
  if (stepFunction) {
    const schemaResult = stepFunction(draft, `${key}`, schema, data, pointer);
    if (schemaResult === void 0) {
      return draft.errors.schemaWarning({
        pointer,
        value: data,
        schema,
        key
      });
    }
    return schemaResult;
  }
  return new Error(`Unsupported schema type ${schema.type} for key ${key}`);
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/getChildSchemaSelection.js
function getChildSchemaSelection(draft, property, schema = draft.rootSchema) {
  var _a2;
  if (schema.oneOf) {
    return schema.oneOf.map((item) => draft.resolveRef(item));
  }
  if ((_a2 = schema.items) === null || _a2 === void 0 ? void 0 : _a2.oneOf) {
    return schema.items.oneOf.map((item) => draft.resolveRef(item));
  }
  const result = draft.step(property, schema, {}, "#");
  if (isJsonError(result)) {
    return result;
  }
  return [result];
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/validation/type.js
var typeValidators = {
  array: (draft, schema, value, pointer) => draft.typeKeywords.array.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  object: (draft, schema, value, pointer) => draft.typeKeywords.object.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  string: (draft, schema, value, pointer) => draft.typeKeywords.string.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  integer: (draft, schema, value, pointer) => draft.typeKeywords.number.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  number: (draft, schema, value, pointer) => draft.typeKeywords.number.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  boolean: (draft, schema, value, pointer) => draft.typeKeywords.boolean.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  null: (draft, schema, value, pointer) => draft.typeKeywords.null.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer))
};
var type_default = typeValidators;

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/validate.js
var import_fast_deep_equal2 = __toESM(require_fast_deep_equal());
function getJsonSchemaType(value, expectedType) {
  const jsType = getTypeOf(value);
  if (jsType === "number" && (expectedType === "integer" || Array.isArray(expectedType) && expectedType.includes("integer"))) {
    return Number.isInteger(value) || isNaN(value) ? "integer" : "number";
  }
  return jsType;
}
function validate(draft, value, schema = draft.rootSchema, pointer = "#") {
  schema = draft.resolveRef(schema);
  if (getTypeOf(schema) === "boolean") {
    if (schema) {
      return [];
    }
    return [draft.errors.invalidDataError({ pointer, schema, value })];
  }
  if (isJsonError(schema)) {
    return [schema];
  }
  if (schema.const !== void 0) {
    if ((0, import_fast_deep_equal2.default)(schema.const, value)) {
      return [];
    }
    return [draft.errors.constError({ pointer, schema, value, expected: schema.const })];
  }
  const receivedType = getJsonSchemaType(value, schema.type);
  const expectedType = schema.type || receivedType;
  if (receivedType !== expectedType && (!Array.isArray(expectedType) || !expectedType.includes(receivedType))) {
    return [
      draft.errors.typeError({
        pointer,
        schema,
        value,
        received: receivedType,
        expected: expectedType
      })
    ];
  }
  if (draft.validateType[receivedType] == null) {
    return [draft.errors.invalidTypeError({ pointer, schema, value, receivedType })];
  }
  const errors2 = flattenArray(draft.validateType[receivedType](draft, schema, value, pointer));
  return errors2.filter(errorOrPromise);
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft04/index.js
var draft04Config = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "enum",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["enum", "not", "allOf", "anyOf", "oneOf"],
    object: [
      "additionalProperties",
      "dependencies",
      "enum",
      "format",
      "minProperties",
      "maxProperties",
      "patternProperties",
      "properties",
      "required",
      "not",
      "oneOf",
      "allOf",
      "anyOf"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: keyword_default,
  validateType: type_default,
  validateFormat: format_default,
  errors: errors_default,
  addRemoteSchema,
  compileSchema: compileSchema_default,
  createSchemaOf,
  each,
  eachSchema,
  getChildSchemaSelection,
  getSchema,
  getTemplate: getTemplate_default,
  isValid,
  resolveAllOf,
  resolveAnyOf,
  resolveOneOf,
  resolveRef,
  step,
  validate,
  templateDefaultOptions: settings_default.templateDefaultOptions
};
var Draft04 = class extends Draft {
  constructor(schema, config = {}) {
    super(merge_default(draft04Config, config), schema);
  }
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft06/compile/index.js
var import_json_pointer7 = __toESM(require_jsonPointer());
var COMPILED2 = "__compiled";
var COMPILED_REF2 = "__ref";
var GET_REF2 = "getRef";
var GET_ROOT2 = "getRoot";
var suffixes5 = /(#|\/)+$/g;
function compileSchema2(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {
  if (schemaToCompile === true || schemaToCompile === false || schemaToCompile === void 0) {
    return schemaToCompile;
  }
  if (schemaToCompile[COMPILED2] !== void 0) {
    return schemaToCompile;
  }
  const context = { ids: {}, remotes: draft.remotes };
  const rootSchemaAsString = JSON.stringify(schemaToCompile);
  const compiledSchema = JSON.parse(rootSchemaAsString);
  Object.defineProperty(compiledSchema, COMPILED2, { enumerable: false, value: true });
  Object.defineProperty(compiledSchema, GET_REF2, {
    enumerable: false,
    value: getRef.bind(null, context, compiledSchema)
  });
  if (force === false && rootSchemaAsString.includes("$ref") === false) {
    return compiledSchema;
  }
  if (compiledSchema !== rootSchema) {
    Object.defineProperty(compiledSchema, "$defs", {
      enumerable: true,
      value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, compiledSchema.definitions, compiledSchema.$defs)
    });
  }
  const scopes = {};
  const getRoot = () => compiledSchema;
  eachSchema(compiledSchema, (schema, pointer) => {
    var _a2;
    if (schema.$id) {
      if (schema.$id.startsWith("http") && /(allOf|anyOf|oneOf)\/\d+$/.test(pointer)) {
        const parentPointer2 = pointer.replace(/\/(allOf|anyOf|oneOf)\/\d+$/, "");
        const parentSchema = (0, import_json_pointer7.get)(compiledSchema, parentPointer2);
        schema.$id = (_a2 = parentSchema.$id) !== null && _a2 !== void 0 ? _a2 : schema.$id;
      }
      context.ids[schema.$id.replace(suffixes5, "")] = pointer;
    }
    pointer = `#${pointer}`.replace(/##+/, "#");
    const previousPointer = pointer.replace(/\/[^/]+$/, "");
    const parentPointer = pointer.replace(/\/[^/]+\/[^/]+$/, "");
    const previousScope = scopes[previousPointer] || scopes[parentPointer];
    const scope = joinScope(previousScope, schema.$id);
    scopes[pointer] = scope;
    if (context.ids[scope] == null) {
      context.ids[scope] = pointer;
    }
    if (schema.$ref && !schema[COMPILED_REF2]) {
      Object.defineProperty(schema, COMPILED_REF2, {
        enumerable: false,
        value: joinScope(scope, schema.$ref)
      });
      Object.defineProperty(schema, GET_ROOT2, { enumerable: false, value: getRoot });
    }
  });
  return compiledSchema;
}

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft06/validation/keyword.js
var KeywordValidation2 = {
  ...keyword_default,
  // @draft >= 6
  contains: (draft, schema, value, pointer) => {
    if (schema.contains === false) {
      return draft.errors.containsArrayError({ pointer, value, schema });
    }
    if (schema.contains === true) {
      if (Array.isArray(value) && value.length === 0) {
        return draft.errors.containsAnyError({ pointer, value, schema });
      }
      return void 0;
    }
    if (getTypeOf(schema.contains) !== "object") {
      return void 0;
    }
    for (let i = 0; i < value.length; i += 1) {
      if (draft.isValid(value[i], schema.contains)) {
        return void 0;
      }
    }
    return draft.errors.containsError({ pointer, schema, value });
  },
  exclusiveMaximum: (draft, schema, value, pointer) => {
    if (isNaN(schema.exclusiveMaximum)) {
      return void 0;
    }
    if (schema.exclusiveMaximum <= value) {
      return draft.errors.maximumError({
        maximum: schema.exclusiveMaximum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  exclusiveMinimum: (draft, schema, value, pointer) => {
    if (isNaN(schema.exclusiveMinimum)) {
      return void 0;
    }
    if (schema.exclusiveMinimum >= value) {
      return draft.errors.minimumError({
        minimum: schema.exclusiveMinimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  // @feature if-then-else
  if: validateIf,
  maximum: (draft, schema, value, pointer) => {
    if (isNaN(schema.maximum)) {
      return void 0;
    }
    if (schema.maximum && schema.maximum < value) {
      return draft.errors.maximumError({
        maximum: schema.maximum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minimum: (draft, schema, value, pointer) => {
    if (isNaN(schema.minimum)) {
      return void 0;
    }
    if (schema.minimum > value) {
      return draft.errors.minimumError({
        minimum: schema.minimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  patternProperties: (draft, schema, value, pointer) => {
    const properties = schema.properties || {};
    const pp = schema.patternProperties;
    if (getTypeOf(pp) !== "object") {
      return void 0;
    }
    const errors2 = [];
    const keys = Object.keys(value);
    const patterns = Object.keys(pp).map((expr) => ({
      regex: new RegExp(expr),
      patternSchema: pp[expr]
    }));
    keys.forEach((key) => {
      let patternFound = false;
      for (let i = 0, l = patterns.length; i < l; i += 1) {
        if (patterns[i].regex.test(key)) {
          patternFound = true;
          if (patterns[i].patternSchema === false) {
            errors2.push(draft.errors.patternPropertiesError({
              key,
              pointer,
              patterns: Object.keys(pp).join(","),
              schema,
              value
            }));
            return;
          }
          const valErrors = draft.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);
          if (valErrors && valErrors.length > 0) {
            errors2.push(...valErrors);
          }
        }
      }
      if (properties[key]) {
        return;
      }
      if (patternFound === false && schema.additionalProperties === false) {
        errors2.push(draft.errors.patternPropertiesError({
          key,
          pointer,
          patterns: Object.keys(pp).join(","),
          schema,
          value
        }));
      }
    });
    return errors2;
  },
  // @draft >= 6
  propertyNames: (draft, schema, value, pointer) => {
    if (schema.propertyNames === false) {
      if (Object.keys(value).length === 0) {
        return void 0;
      }
      return draft.errors.invalidPropertyNameError({
        property: Object.keys(value),
        pointer,
        value,
        schema
      });
    }
    if (schema.propertyNames === true) {
      return void 0;
    }
    if (getTypeOf(schema.propertyNames) !== "object") {
      return void 0;
    }
    const errors2 = [];
    const properties = Object.keys(value);
    const propertySchema = { ...schema.propertyNames, type: "string" };
    properties.forEach((prop) => {
      const validationResult = draft.validate(prop, propertySchema, `${pointer}/${prop}`);
      if (validationResult.length > 0) {
        errors2.push(draft.errors.invalidPropertyNameError({
          property: prop,
          pointer,
          validationError: validationResult[0],
          value: value[prop],
          schema
        }));
      }
    });
    return errors2;
  }
};
var keyword_default2 = KeywordValidation2;

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft06/validation/type.js
var validationType = {
  array: (draft, schema, value, pointer) => draft.typeKeywords.array.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  object: (draft, schema, value, pointer) => draft.typeKeywords.object.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  string: (draft, schema, value, pointer) => draft.typeKeywords.string.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  integer: (draft, schema, value, pointer) => draft.typeKeywords.number.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  number: (draft, schema, value, pointer) => draft.typeKeywords.number.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  boolean: (draft, schema, value, pointer) => draft.typeKeywords.boolean.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer)),
  null: (draft, schema, value, pointer) => draft.typeKeywords.null.filter((key) => schema && schema[key] != null).map((key) => draft.validateKeyword[key](draft, schema, value, pointer))
};
var type_default2 = validationType;

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft06/index.js
var draft06Config = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "contains",
      "enum",
      "if",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],
    object: [
      "additionalProperties",
      "allOf",
      "anyOf",
      "dependencies",
      "enum",
      "format",
      "if",
      "maxProperties",
      "minProperties",
      "not",
      "oneOf",
      "patternProperties",
      "properties",
      "propertyNames",
      "required"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "if",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "enum",
      "exclusiveMaximum",
      "exclusiveMinimum",
      "format",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf",
      "allOf",
      "anyOf",
      "if"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: keyword_default2,
  validateType: type_default2,
  validateFormat: format_default,
  errors: errors_default,
  addRemoteSchema,
  compileSchema: compileSchema2,
  createSchemaOf,
  each,
  eachSchema,
  getChildSchemaSelection,
  getSchema,
  getTemplate: getTemplate_default,
  isValid,
  resolveAllOf,
  resolveAnyOf,
  resolveOneOf,
  resolveRef,
  step,
  validate,
  templateDefaultOptions: settings_default.templateDefaultOptions
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/draft07/index.js
var draft07Config = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "contains",
      "enum",
      "if",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],
    object: [
      "additionalProperties",
      "allOf",
      "anyOf",
      "dependencies",
      "enum",
      "format",
      "if",
      "maxProperties",
      "minProperties",
      "not",
      "oneOf",
      "patternProperties",
      "properties",
      "propertyNames",
      "required"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "if",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "exclusiveMaximum",
      "exclusiveMinimum",
      "format",
      "if",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: keyword_default2,
  validateType: type_default2,
  validateFormat: format_default,
  errors: errors_default,
  addRemoteSchema,
  compileSchema: compileSchema2,
  createSchemaOf,
  each,
  eachSchema,
  getChildSchemaSelection,
  getSchema,
  getTemplate: getTemplate_default,
  isValid,
  resolveAllOf,
  resolveAnyOf,
  resolveOneOf,
  resolveRef,
  step,
  validate,
  templateDefaultOptions: settings_default.templateDefaultOptions
};
var Draft07 = class extends Draft {
  constructor(schema, config = {}) {
    super(merge_default(draft07Config, config), schema);
  }
};

// node_modules/.pnpm/json-schema-library@9.3.5/node_modules/json-schema-library/dist/module/lib/jsoneditor/index.js
var draftJsonEditorConfig = {
  ...draft07Config,
  resolveOneOf: resolveOneOfFuzzy,
  resolveRef: resolveRefMerge
};

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/jsonPointers.js
function getJsonPointerAt(docText, node) {
  const path = [];
  for (let n = node; n === null || n === void 0 ? void 0 : n.parent; n = n.parent) {
    switch (n.parent.name) {
      case TOKENS.PROPERTY: {
        const name = n.parent.getChild(TOKENS.PROPERTY_NAME);
        if (name) {
          path.unshift(getWord(docText, name).replace(/[/~]/g, (v) => v === "~" ? "~0" : "~1"));
        }
        break;
      }
      case TOKENS.ARRAY: {
        if (isValueNode(n)) {
          const index2 = findNodeIndexInArrayNode(n.parent, n);
          path.unshift(`${index2}`);
        }
        break;
      }
    }
  }
  path.unshift("");
  return path.join("/");
}
var jsonPointerForPosition = (state, pos, side = -1) => {
  return getJsonPointerAt(state.doc, syntaxTree(state).resolve(pos, side));
};
var getJsonPointers = (state, mode = "json4") => {
  const json2 = syntaxTree(state);
  const pointers = /* @__PURE__ */ new Map();
  json2.iterate({
    enter: (type) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h;
      if (type.name === "PropertyName" || type.name === "Object") {
        const pointer = getJsonPointerAt(state.doc, type.node);
        const { from: keyFrom, to: keyTo } = type.node;
        if (!((_b = (_a2 = type.node) === null || _a2 === void 0 ? void 0 : _a2.nextSibling) === null || _b === void 0 ? void 0 : _b.node)) {
          pointers.set(pointer, { keyFrom, keyTo });
          return true;
        }
        const nextNode = mode === "json4" ? (_d = (_c = type.node) === null || _c === void 0 ? void 0 : _c.nextSibling) === null || _d === void 0 ? void 0 : _d.node : (_h = (_g = (_f = (_e = type.node) === null || _e === void 0 ? void 0 : _e.nextSibling) === null || _f === void 0 ? void 0 : _f.node) === null || _g === void 0 ? void 0 : _g.nextSibling) === null || _h === void 0 ? void 0 : _h.node;
        if (!nextNode) {
          pointers.set(pointer, { keyFrom, keyTo });
          return true;
        }
        const { from: valueFrom, to: valueTo } = nextNode;
        pointers.set(pointer, { keyFrom, keyTo, valueFrom, valueTo });
        return true;
      }
    }
  });
  return pointers;
};

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/json-completion.js
function json5PropertyInsertSnippet(rawWord, value) {
  if (rawWord.startsWith('"')) {
    return `"${value}"`;
  }
  if (rawWord.startsWith("'")) {
    return `'${value}'`;
  }
  return value;
}
var CompletionCollector = class {
  constructor() {
    this.completions = /* @__PURE__ */ new Map();
    this.reservedKeys = /* @__PURE__ */ new Set();
  }
  reserve(key) {
    this.reservedKeys.add(key);
  }
  add(completion) {
    if (this.reservedKeys.has(completion.label)) {
      return;
    }
    this.completions.set(completion.label, completion);
  }
};
var JSONCompletion = class {
  constructor(opts) {
    this.opts = opts;
    this.schema = null;
  }
  doComplete(ctx) {
    var _a2, _b;
    this.schema = getJSONSchema(ctx.state);
    if (!this.schema) {
      return [];
    }
    const result = {
      from: ctx.pos,
      to: ctx.pos,
      options: [],
      filter: false
      // will be handled manually
    };
    const text = ctx.state.doc.sliceString(0);
    let node = getNodeAtPosition(ctx.state, ctx.pos);
    const prefix = ctx.state.sliceDoc(node.from, ctx.pos).replace(/^("|')/, "");
    debug.log("xxx", "node", node, "prefix", prefix, "ctx", ctx);
    if (!(isPrimitiveValueNode(node) || isPropertyNameNode(node)) && !ctx.explicit) {
      return result;
    }
    const currentWord = getWord(ctx.state.doc, node);
    const rawWord = getWord(ctx.state.doc, node, false);
    if (node && (isPrimitiveValueNode(node) || isPropertyNameNode(node))) {
      result.from = node.from;
      result.to = node.to;
    } else {
      const word = ctx.matchBefore(/[A-Za-z0-9._]*/);
      const overwriteStart = ctx.pos - currentWord.length;
      debug.log("xxx", "overwriteStart after", overwriteStart, "ctx.pos", ctx.pos, "word", word, "currentWord", currentWord, "=>", text[overwriteStart - 1], "..", text[overwriteStart], "..", text);
      result.from = node.name === TOKENS.INVALID ? (_a2 = word === null || word === void 0 ? void 0 : word.from) !== null && _a2 !== void 0 ? _a2 : ctx.pos : overwriteStart;
      result.to = ctx.pos;
    }
    const collector = new CompletionCollector();
    let addValue = true;
    if (isPropertyNameNode(node)) {
      const parent = node.parent;
      if (parent) {
        const valueNode = getChildValueNode(parent);
        addValue = !valueNode || valueNode.name === TOKENS.INVALID && valueNode.from - valueNode.to === 0;
        debug.log("xxx", "addValue", addValue, getChildValueNode(parent), node);
        node = (_b = [parent, parent.parent].find((p) => {
          if ((p === null || p === void 0 ? void 0 : p.name) === TOKENS.OBJECT) {
            return true;
          }
          return false;
        })) !== null && _b !== void 0 ? _b : null;
      }
    }
    debug.log("xxx", node, currentWord, ctx);
    if (node && (node.name === TOKENS.OBJECT || node.name === TOKENS.JSON_TEXT) && isPropertyNameNode(getNodeAtPosition(ctx.state, ctx.pos))) {
      if (node.from === ctx.pos) {
        return result;
      }
      this.getPropertyCompletions(this.schema, ctx, node, collector, addValue, rawWord);
    } else {
      const types = {};
      this.getValueCompletions(this.schema, ctx, types, collector);
    }
    result.options = Array.from(collector.completions.values()).filter((v) => stripSurroundingQuotes(v.label).startsWith(prefix));
    debug.log("xxx", "result", result, "prefix", prefix, "collector.completions", collector.completions, "reservedKeys", collector.reservedKeys);
    return result;
  }
  applySnippetCompletion(completion) {
    return snippetCompletion(typeof completion.apply !== "string" ? completion.label : completion.apply, completion);
  }
  getPropertyCompletions(schema, ctx, node, collector, addValue, rawWord) {
    const properties = node.getChildren(TOKENS.PROPERTY);
    debug.log("xxx", "getPropertyCompletions", node, ctx, properties);
    properties.forEach((p) => {
      const key = getWord(ctx.state.doc, p.getChild(TOKENS.PROPERTY_NAME));
      collector.reserve(stripSurroundingQuotes(key));
    });
    const schemas = this.getSchemas(schema, ctx);
    schemas.forEach((s) => {
      if (typeof s !== "object") {
        return;
      }
      const properties2 = s.properties;
      if (properties2) {
        Object.entries(properties2).forEach(([key, value]) => {
          var _a2, _b;
          if (typeof value === "object") {
            const description = (_a2 = value.description) !== null && _a2 !== void 0 ? _a2 : "";
            const type = (_b = value.type) !== null && _b !== void 0 ? _b : "";
            const typeStr = Array.isArray(type) ? type.toString() : type;
            const completion = {
              // label is the unquoted key which will be displayed.
              label: key,
              apply: this.getInsertTextForProperty(key, addValue, rawWord, value),
              type: "property",
              detail: typeStr,
              info: description
            };
            collector.add(this.applySnippetCompletion(completion));
          }
        });
      }
      const propertyNames = s.propertyNames;
      if (typeof propertyNames === "object") {
        if (propertyNames.enum) {
          propertyNames.enum.forEach((v) => {
            const label = v === null || v === void 0 ? void 0 : v.toString();
            if (label) {
              const completion = {
                label,
                apply: this.getInsertTextForProperty(label, addValue, rawWord),
                type: "property"
              };
              collector.add(this.applySnippetCompletion(completion));
            }
          });
        }
        if (propertyNames.const) {
          const label = propertyNames.const.toString();
          const completion = {
            label,
            apply: this.getInsertTextForProperty(label, addValue, rawWord),
            type: "property"
          };
          collector.add(this.applySnippetCompletion(completion));
        }
      }
    });
  }
  // apply is the quoted key which will be applied.
  // Normally the label needs to match the token
  // prefix i.e. if the token begins with `"to`, then the
  // label needs to have the quotes as well for it to match.
  // However we are manually filtering the results so we can
  // just use the unquoted key as the label, which is nicer
  // and gives us more control.
  // If no property value is present, then we add the colon as well.
  // Use snippetCompletion to handle insert value + position cursor e.g. "key": "#{}"
  // doc: https://codemirror.net/docs/ref/#autocomplete.snippetCompletion
  // idea: https://discuss.codemirror.net/t/autocomplete-cursor-position-in-apply-function/4088/3
  getInsertTextForProperty(key, addValue, rawWord, propertySchema) {
    var _a2;
    propertySchema = propertySchema ? this.expandSchemaProperty(propertySchema, this.schema) : propertySchema;
    const isJSON5 = ((_a2 = this.opts) === null || _a2 === void 0 ? void 0 : _a2.mode) === "json5";
    let resultText = isJSON5 ? json5PropertyInsertSnippet(rawWord, key) : `"${key}"`;
    if (!addValue) {
      return resultText;
    }
    resultText += ": ";
    let value;
    let nValueProposals = 0;
    if (typeof propertySchema === "object") {
      if (typeof propertySchema.default !== "undefined") {
        if (!value) {
          value = this.getInsertTextForGuessedValue(propertySchema.default, "");
        }
        nValueProposals++;
      } else {
        if (propertySchema.enum) {
          if (!value && propertySchema.enum.length === 1) {
            value = this.getInsertTextForGuessedValue(propertySchema.enum[0], "");
          }
          nValueProposals += propertySchema.enum.length;
        }
        if (typeof propertySchema.const !== "undefined") {
          if (!value) {
            value = this.getInsertTextForGuessedValue(propertySchema.const, "");
          }
          nValueProposals++;
        }
        if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {
          if (!value) {
            value = this.getInsertTextForGuessedValue(propertySchema.examples[0], "");
          }
          nValueProposals += propertySchema.examples.length;
        }
        if (value === void 0 && nValueProposals === 0) {
          let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;
          if (!type) {
            if (propertySchema.properties) {
              type = "object";
            } else if (propertySchema.items) {
              type = "array";
            }
          }
          switch (type) {
            case "boolean":
              value = "#{}";
              break;
            case "string":
              value = isJSON5 ? "'#{}'" : '"#{}"';
              break;
            case "object":
              value = "{#{}}";
              break;
            case "array":
              value = "[#{}]";
              break;
            case "number":
            case "integer":
              value = "#{0}";
              break;
            case "null":
              value = "#{null}";
              break;
            default:
              value = "#{}";
              break;
          }
        }
      }
    }
    if (!value || nValueProposals > 1) {
      debug.log("xxx", "value", value, "nValueProposals", nValueProposals, propertySchema);
      value = "#{}";
    }
    return resultText + value;
  }
  getInsertTextForGuessedValue(value, separatorAfter = "") {
    switch (typeof value) {
      case "object":
        if (value === null) {
          return "${null}" + separatorAfter;
        }
        return this.getInsertTextForValue(value, separatorAfter);
      case "string": {
        let snippetValue = JSON.stringify(value);
        snippetValue = snippetValue.substr(1, snippetValue.length - 2);
        snippetValue = this.getInsertTextForPlainText(snippetValue);
        return '"${' + snippetValue + '}"' + separatorAfter;
      }
      case "number":
      case "boolean":
        return "${" + JSON.stringify(value) + "}" + separatorAfter;
    }
    return this.getInsertTextForValue(value, separatorAfter);
  }
  getInsertTextForPlainText(text) {
    return text.replace(/[\\$}]/g, "\\$&");
  }
  getInsertTextForValue(value, separatorAfter) {
    const text = JSON.stringify(value, null, "	");
    if (text === "{}") {
      return "{#{}}" + separatorAfter;
    } else if (text === "[]") {
      return "[#{}]" + separatorAfter;
    }
    return this.getInsertTextForPlainText(text + separatorAfter);
  }
  getValueCompletions(schema, ctx, types, collector) {
    let node = syntaxTree(ctx.state).resolveInner(ctx.pos, -1);
    let valueNode = null;
    let parentKey = void 0;
    debug.log("xxx", "getValueCompletions", node, ctx);
    if (node && isPrimitiveValueNode(node)) {
      valueNode = node;
      node = node.parent;
    }
    if (!node) {
      this.addSchemaValueCompletions(schema, types, collector);
      return;
    }
    if (node.name === TOKENS.PROPERTY) {
      const keyNode = node.getChild(TOKENS.PROPERTY_NAME);
      if (keyNode) {
        parentKey = getWord(ctx.state.doc, keyNode);
        node = node.parent;
      }
    }
    debug.log("xxx", "node", node, "parentKey", parentKey);
    if (node && (parentKey !== void 0 || node.name === TOKENS.ARRAY)) {
      const schemas = this.getSchemas(schema, ctx);
      for (const s of schemas) {
        if (typeof s !== "object") {
          return;
        }
        if (node.name === TOKENS.ARRAY && s.items) {
          let c = collector;
          if (s.uniqueItems) {
            c = Object.assign(Object.assign({}, c), {
              add(completion) {
                if (!c.completions.has(completion.label)) {
                  collector.add(completion);
                }
              },
              reserve(key) {
                collector.reserve(key);
              }
            });
          }
          if (Array.isArray(s.items)) {
            let arrayIndex = 0;
            if (valueNode) {
              const foundIdx = findNodeIndexInArrayNode(node, valueNode);
              if (foundIdx >= 0) {
                arrayIndex = foundIdx;
              }
            }
            const itemSchema = s.items[arrayIndex];
            if (itemSchema) {
              this.addSchemaValueCompletions(itemSchema, types, c);
            }
          } else {
            this.addSchemaValueCompletions(s.items, types, c);
          }
        }
        if (parentKey !== void 0) {
          let propertyMatched = false;
          if (s.properties) {
            const propertySchema = s.properties[parentKey];
            if (propertySchema) {
              propertyMatched = true;
              this.addSchemaValueCompletions(propertySchema, types, collector);
            }
          }
          if (s.patternProperties && !propertyMatched) {
            for (const pattern2 of Object.keys(s.patternProperties)) {
              const regex = this.extendedRegExp(pattern2);
              if (regex === null || regex === void 0 ? void 0 : regex.test(parentKey)) {
                propertyMatched = true;
                const propertySchema = s.patternProperties[pattern2];
                if (propertySchema) {
                  this.addSchemaValueCompletions(propertySchema, types, collector);
                }
              }
            }
          }
          if (s.additionalProperties && !propertyMatched) {
            const propertySchema = s.additionalProperties;
            this.addSchemaValueCompletions(propertySchema, types, collector);
          }
        }
        if (types["boolean"]) {
          this.addBooleanValueCompletion(true, collector);
          this.addBooleanValueCompletion(false, collector);
        }
        if (types["null"]) {
          this.addNullValueCompletion(collector);
        }
      }
    }
  }
  addSchemaValueCompletions(schema, types, collector) {
    if (typeof schema === "object") {
      this.addEnumValueCompletions(schema, collector);
      this.addDefaultValueCompletions(schema, collector);
      this.collectTypes(schema, types);
      if (Array.isArray(schema.allOf)) {
        schema.allOf.forEach((s) => this.addSchemaValueCompletions(s, types, collector));
      }
      if (Array.isArray(schema.anyOf)) {
        schema.anyOf.forEach((s) => this.addSchemaValueCompletions(s, types, collector));
      }
      if (Array.isArray(schema.oneOf)) {
        schema.oneOf.forEach((s) => this.addSchemaValueCompletions(s, types, collector));
      }
    }
  }
  addDefaultValueCompletions(schema, collector, arrayDepth = 0) {
    let hasProposals = false;
    if (typeof schema.default !== "undefined") {
      let type = schema.type;
      let value = schema.default;
      for (let i = arrayDepth; i > 0; i--) {
        value = [value];
        type = "array";
      }
      const completionItem = {
        type: type === null || type === void 0 ? void 0 : type.toString(),
        label: this.getLabelForValue(value),
        detail: "Default value"
      };
      collector.add(completionItem);
      hasProposals = true;
    }
    if (Array.isArray(schema.examples)) {
      schema.examples.forEach((example) => {
        let type = schema.type;
        let value = example;
        for (let i = arrayDepth; i > 0; i--) {
          value = [value];
          type = "array";
        }
        collector.add({
          type: type === null || type === void 0 ? void 0 : type.toString(),
          label: this.getLabelForValue(value)
        });
        hasProposals = true;
      });
    }
    if (!hasProposals && typeof schema.items === "object" && !Array.isArray(schema.items) && arrayDepth < 5) {
      this.addDefaultValueCompletions(schema.items, collector, arrayDepth + 1);
    }
  }
  addEnumValueCompletions(schema, collector) {
    var _a2, _b;
    if (typeof schema.const !== "undefined") {
      collector.add({
        type: (_a2 = schema.type) === null || _a2 === void 0 ? void 0 : _a2.toString(),
        label: this.getLabelForValue(schema.const),
        info: schema.description
      });
    }
    if (Array.isArray(schema.enum)) {
      for (let i = 0, length = schema.enum.length; i < length; i++) {
        const enm = schema.enum[i];
        collector.add({
          type: (_b = schema.type) === null || _b === void 0 ? void 0 : _b.toString(),
          label: this.getLabelForValue(enm),
          info: schema.description
        });
      }
    }
  }
  addBooleanValueCompletion(value, collector) {
    collector.add({
      type: "boolean",
      label: value ? "true" : "false"
    });
  }
  addNullValueCompletion(collector) {
    collector.add({
      type: "null",
      label: "null"
    });
  }
  collectTypes(schema, types) {
    if (Array.isArray(schema.enum) || typeof schema.const !== "undefined") {
      return;
    }
    const type = schema.type;
    if (Array.isArray(type)) {
      type.forEach((t) => types[t] = true);
    } else if (type) {
      types[type] = true;
    }
  }
  getSchemas(schema, ctx) {
    var _a2;
    const draft = new Draft07(this.schema);
    let pointer = jsonPointerForPosition(ctx.state, ctx.pos);
    let subSchema = draft.getSchema({ pointer });
    if (isJsonError(subSchema)) {
      subSchema = (_a2 = subSchema.data) === null || _a2 === void 0 ? void 0 : _a2.schema;
    }
    if (!subSchema || subSchema.name === "UnknownPropertyError" || subSchema.enum || subSchema.type === "undefined") {
      pointer = pointer.replace(/\/[^/]*$/, "/");
      subSchema = draft.getSchema({ pointer });
    }
    debug.log("xxx", "pointer..", JSON.stringify(pointer));
    if (!pointer || pointer === "/") {
      return [schema];
    }
    debug.log("xxx", "subSchema..", subSchema);
    if (!subSchema) {
      return [];
    }
    if (Array.isArray(subSchema.allOf)) {
      return [
        subSchema,
        ...subSchema.allOf.map((s) => this.expandSchemaProperty(s, schema))
      ];
    }
    if (Array.isArray(subSchema.oneOf)) {
      return [
        subSchema,
        ...subSchema.oneOf.map((s) => this.expandSchemaProperty(s, schema))
      ];
    }
    if (Array.isArray(subSchema.anyOf)) {
      return [
        subSchema,
        ...subSchema.anyOf.map((s) => this.expandSchemaProperty(s, schema))
      ];
    }
    return [subSchema];
  }
  expandSchemaProperty(property, schema) {
    if (typeof property === "object" && property.$ref) {
      const refSchema = this.getReferenceSchema(schema, property.$ref);
      if (typeof refSchema === "object") {
        const dereferenced = Object.assign(Object.assign({}, property), refSchema);
        Reflect.deleteProperty(dereferenced, "$ref");
        return dereferenced;
      }
    }
    return property;
  }
  getReferenceSchema(schema, ref) {
    const refPath = ref.split("/");
    let curReference = schema;
    refPath.forEach((cur) => {
      if (!cur) {
        return;
      }
      if (cur === "#") {
        curReference = schema;
        return;
      }
      if (typeof curReference === "object") {
        curReference = curReference[cur];
      }
    });
    return curReference;
  }
  getLabelForValue(value) {
    return JSON.stringify(value);
  }
  getValueFromLabel(value) {
    return JSON.parse(value);
  }
  extendedRegExp(pattern2) {
    let flags = "";
    if (pattern2.startsWith("(?i)")) {
      pattern2 = pattern2.substring(4);
      flags = "i";
    }
    try {
      return new RegExp(pattern2, flags + "u");
    } catch (e) {
      try {
        return new RegExp(pattern2, flags);
      } catch (e2) {
        return void 0;
      }
    }
  }
};
function jsonCompletion(opts = {}) {
  const completion = new JSONCompletion(opts);
  return function jsonDoCompletion(ctx) {
    return completion.doComplete(ctx);
  };
}

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/formatting.js
var joinWithOr = (arr, getPath) => {
  const needsComma = arr.length > 2;
  let data = arr.map((err, i) => {
    const result = `<code>` + (getPath ? getPath(err) : err) + `</code>`;
    if (i === arr.length - 1)
      return "or " + result;
    return result;
  });
  if (needsComma) {
    return data.join(", ");
  }
  return data.join(" ");
};

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/parseJSONDocument.js
function parseJSONDocumentState(state) {
  let data = null;
  try {
    data = JSON.parse(state.doc.toString());
  } catch (_a2) {
  }
  const pointers = getJsonPointers(state, "json4");
  return { data, pointers };
}
function parseJSONDocument(jsonString) {
  const state = EditorState.create({ doc: jsonString, extensions: [json()] });
  return parseJSONDocumentState(state);
}

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/utils/dom.js
function el(tagName, attributes, children = []) {
  const e = document.createElement(tagName);
  Object.entries(attributes).forEach(([k, v]) => {
    if (k === "text") {
      e.innerText = v;
      return;
    }
    if (k === "inner") {
      e.innerHTML = v;
      return;
    }
    e.setAttribute(k, v);
  });
  children.forEach((c) => e.appendChild(c));
  return e;
}

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/json-validation.js
var getErrorPath = (error) => {
  var _a2, _b, _c;
  if (((_a2 = error === null || error === void 0 ? void 0 : error.data) === null || _a2 === void 0 ? void 0 : _a2.pointer) && ((_b = error === null || error === void 0 ? void 0 : error.data) === null || _b === void 0 ? void 0 : _b.pointer) !== "#") {
    return error.data.pointer.slice(1);
  }
  if ((_c = error === null || error === void 0 ? void 0 : error.data) === null || _c === void 0 ? void 0 : _c.property) {
    return `/${error.data.property}`;
  }
  return "";
};
var handleRefresh = (vu) => {
  return vu.startState.field(schemaStateField) !== vu.state.field(schemaStateField);
};
function jsonSchemaLinter(options) {
  const validation = new JSONValidation(options);
  return (view) => {
    return validation.doValidation(view);
  };
}
var positionalErrors = [
  "NoAdditionalPropertiesError",
  "RequiredPropertyError",
  "InvalidPropertyNameError",
  "ForbiddenPropertyError",
  "UndefinedValueError"
];
var JSONValidation = class {
  constructor(options) {
    this.schema = null;
    this.rewriteError = (error) => {
      var _a2, _b, _c, _d, _e;
      const errorData = error === null || error === void 0 ? void 0 : error.data;
      const errors2 = errorData === null || errorData === void 0 ? void 0 : errorData.errors;
      if (error.code === "one-of-error" && (errors2 === null || errors2 === void 0 ? void 0 : errors2.length)) {
        return `Expected one of ${joinWithOr(errors2, (data) => data.data.expected)}`;
      }
      if (error.code === "type-error") {
        return `Expected <code>${((_a2 = error === null || error === void 0 ? void 0 : error.data) === null || _a2 === void 0 ? void 0 : _a2.expected) && Array.isArray((_b = error === null || error === void 0 ? void 0 : error.data) === null || _b === void 0 ? void 0 : _b.expected) ? joinWithOr((_c = error === null || error === void 0 ? void 0 : error.data) === null || _c === void 0 ? void 0 : _c.expected) : (_d = error === null || error === void 0 ? void 0 : error.data) === null || _d === void 0 ? void 0 : _d.expected}</code> but received <code>${(_e = error === null || error === void 0 ? void 0 : error.data) === null || _e === void 0 ? void 0 : _e.received}</code>`;
      }
      const message = error.message.replaceAll("in `#` ", "").replaceAll("/", ".").replaceAll("#.", "").replaceAll(/`([^`]*)`/gm, "<code>$1</code>");
      return message;
    };
    this.options = Object.assign({ jsonParser: parseJSONDocumentState }, options);
  }
  get schemaTitle() {
    var _a2, _b, _c;
    return (_c = (_b = (_a2 = this.schema) === null || _a2 === void 0 ? void 0 : _a2.getSchema()) === null || _b === void 0 ? void 0 : _b.title) !== null && _c !== void 0 ? _c : "json-schema";
  }
  // validate using view as the linter extension signature requires
  doValidation(view) {
    const schema = getJSONSchema(view.state);
    if (!schema) {
      return [];
    }
    this.schema = new Draft04(schema);
    if (!this.schema)
      return [];
    const text = view.state.doc.toString();
    if (!text || text.trim().length < 3)
      return [];
    const json2 = this.options.jsonParser(view.state);
    let errors2 = [];
    try {
      errors2 = this.schema.validate(json2.data);
    } catch (_a2) {
    }
    if (!errors2.length)
      return [];
    return errors2.reduce((acc, error) => {
      var _a2;
      const pushRoot = () => {
        const errorString = this.rewriteError(error);
        acc.push({
          from: 0,
          to: 0,
          message: errorString,
          severity: "error",
          source: this.schemaTitle,
          renderMessage: () => {
            const dom = el("div", {});
            dom.innerHTML = errorString;
            return dom;
          }
        });
      };
      const errorPath = getErrorPath(error);
      const pointer = json2.pointers.get(errorPath);
      if ((_a2 = error.name === "MaxPropertiesError") !== null && _a2 !== void 0 ? _a2 : error.name === "MinPropertiesError") {
        pushRoot();
      }
      if (pointer) {
        const isKeyError = positionalErrors.includes(error.name);
        const errorString = this.rewriteError(error);
        const from = isKeyError ? pointer.keyFrom : pointer.valueFrom;
        const to = isKeyError ? pointer.keyTo : pointer.valueTo;
        if (to !== void 0 && from !== void 0) {
          acc.push({
            from,
            to,
            // TODO: create a domnode and replace `` with <code></code>
            // renderMessage: () => error.message,
            message: errorString,
            renderMessage: () => {
              const dom = el("div", {});
              dom.innerHTML = errorString;
              return dom;
            },
            severity: "error",
            source: this.schemaTitle
          });
        }
      }
      return acc;
    }, []);
  }
};

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/json-hover.js
function jsonSchemaHover(options) {
  const hover = new JSONHover(options);
  return async function jsonDoHover(view, pos, side) {
    return hover.doHover(view, pos, side);
  };
}
function formatComplexType(schema, type, draft) {
  return `${type}: ${joinWithOr(schema[type].map((s) => {
    var _a2;
    return (_a2 = s.type) !== null && _a2 !== void 0 ? _a2 : draft.resolveRef(s).type;
  }))}`;
}
var JSONHover = class {
  constructor(opts) {
    this.opts = opts;
    this.schema = null;
    this.opts = Object.assign({ parser: JSON.parse }, this.opts);
  }
  getDataForCursor(view, pos, side) {
    const schema = getJSONSchema(view.state);
    if (!schema) {
      return null;
    }
    this.schema = new Draft04(schema);
    const pointer = jsonPointerForPosition(view.state, pos, side);
    let data = void 0;
    try {
      data = this.opts.parser(view.state.doc.toString());
    } catch (_a2) {
    }
    if (!pointer) {
      return null;
    }
    let subSchema = this.schema.getSchema({
      pointer,
      data,
      withSchemaWarning: true
    });
    if (isJsonError(subSchema)) {
      if (subSchema === null || subSchema === void 0 ? void 0 : subSchema.data.schema["$ref"]) {
        subSchema = this.schema.resolveRef(subSchema);
      } else {
        subSchema = subSchema === null || subSchema === void 0 ? void 0 : subSchema.data.schema;
      }
    }
    return { schema: subSchema, pointer };
  }
  formatMessage(texts) {
    const { message, typeInfo } = texts;
    if (message) {
      return el("div", { class: "cm6-json-schema-hover" }, [
        el("div", {
          class: "cm6-json-schema-hover--description",
          text: message
        }),
        el("div", { class: "cm6-json-schema-hover--code-wrapper" }, [
          typeInfo.includes("<code>") ? el("div", {
            class: "cm6-json-schema-hover--code",
            inner: typeInfo
          }) : el("code", {
            class: "cm6-json-schema-hover--code",
            text: typeInfo
          })
        ])
      ]);
    }
    return el("div", { class: "cm6-json-schema-hover" }, [
      el("div", { class: "cm6-json-schema-hover--code-wrapper" }, [
        el("code", { class: "cm6-json-schema-hover--code", text: typeInfo })
      ])
    ]);
  }
  getHoverTexts(data, draft) {
    let typeInfo = null;
    let message = null;
    const { schema } = data;
    if (schema.oneOf) {
      typeInfo = formatComplexType(schema, "oneOf", draft);
    }
    if (schema.anyOf) {
      typeInfo = formatComplexType(schema, "anyOf", draft);
    }
    if (schema.allOf) {
      typeInfo = formatComplexType(schema, "allOf", draft);
    }
    if (schema.type) {
      typeInfo = Array.isArray(schema.type) ? joinWithOr(schema.type) : schema.type;
    }
    if (schema.enum) {
      typeInfo = `<code>enum</code>: ${joinWithOr(schema.enum)}`;
    }
    if (schema.format) {
      typeInfo += ` <code>format</code>: ${schema.format}`;
    }
    if (schema.pattern) {
      typeInfo += ` <code>pattern</code>: ${schema.pattern}`;
    }
    if (schema.description) {
      message = schema.description;
    }
    return { message, typeInfo };
  }
  // return hover state for the current json schema property
  async doHover(view, pos, side) {
    var _a2, _b, _c, _d;
    const start = pos, end = pos;
    try {
      const cursorData = this.getDataForCursor(view, pos, side);
      if (!(cursorData === null || cursorData === void 0 ? void 0 : cursorData.schema))
        return null;
      const getHoverTexts = (_b = (_a2 = this.opts) === null || _a2 === void 0 ? void 0 : _a2.getHoverTexts) !== null && _b !== void 0 ? _b : this.getHoverTexts;
      const hoverTexts = getHoverTexts(cursorData, this.schema);
      const formatter = (_d = (_c = this.opts) === null || _c === void 0 ? void 0 : _c.formatHover) !== null && _d !== void 0 ? _d : this.formatMessage;
      const formattedDom = formatter(hoverTexts);
      return {
        pos: start,
        end,
        arrow: true,
        // to mimic similar modes for other editors
        // otherwise, it gets into a z-index battle with completion/etc
        above: true,
        create: (view2) => {
          return {
            dom: formattedDom
          };
        }
      };
    } catch (err) {
      debug.log(err);
      return null;
    }
  }
};

// node_modules/.pnpm/codemirror-json-schema@0.6.1_@codemirror+language@6.10.3_@codemirror+lint@6.8.2_@codemirror+s_uckmiptip6l2retxycqzmic7hy/node_modules/codemirror-json-schema/dist/bundled.js
function jsonSchema(schema) {
  return [
    json(),
    linter(jsonParseLinter()),
    linter(jsonSchemaLinter(), {
      needsRefresh: handleRefresh
    }),
    jsonLanguage.data.of({
      autocomplete: jsonCompletion()
    }),
    hoverTooltip(jsonSchemaHover()),
    stateExtensions(schema)
  ];
}
export {
  getJSONSchema,
  getJsonPointerAt,
  getJsonPointers,
  handleRefresh,
  jsonCompletion,
  jsonPointerForPosition,
  jsonSchema,
  jsonSchemaHover,
  jsonSchemaLinter,
  parseJSONDocument,
  parseJSONDocumentState,
  schemaStateField,
  stateExtensions,
  updateSchema
};
//# sourceMappingURL=codemirror-json-schema.js.map
