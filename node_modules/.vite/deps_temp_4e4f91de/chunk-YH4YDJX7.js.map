{
  "version": 3,
  "sources": ["../../.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/src/pbkdf2.ts", "../../.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/src/scrypt.ts", "../../.pnpm/nostr-tools@2.7.2_typescript@5.6.2/node_modules/nostr-tools/lib/esm/nip49.js"],
  "sourcesContent": ["import assert from './_assert.js';\nimport { hmac } from './hmac.js';\nimport { Hash, CHash, Input, createView, toBytes, checkOpts, asyncLoop } from './utils.js';\n\n// PBKDF (RFC 2898)\nexport type Pbkdf2Opt = {\n  c: number; // Iterations\n  dkLen?: number; // Desired key length in bytes (Intended output length in octets of the derived key\n  asyncTick?: number; // Maximum time in ms for which async function can block execution\n};\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash: CHash, _password: Input, _salt: Input, _opts: Pbkdf2Opt) {\n  assert.hash(hash);\n  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);\n  const { c, dkLen, asyncTick } = opts;\n  assert.number(c);\n  assert.number(dkLen);\n  assert.number(asyncTick);\n  if (c < 1) throw new Error('PBKDF2: iterations (c) should be >= 1');\n  const password = toBytes(_password);\n  const salt = toBytes(_salt);\n  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n  const DK = new Uint8Array(dkLen);\n  // U1 = PRF(Password, Salt + INT_32_BE(i))\n  const PRF = hmac.create(hash, password);\n  const PRFSalt = PRF._cloneInto().update(salt);\n  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\n\nfunction pbkdf2Output<T extends Hash<T>>(\n  PRF: Hash<T>,\n  PRFSalt: Hash<T>,\n  DK: Uint8Array,\n  prfW: Hash<T>,\n  u: Uint8Array\n) {\n  PRF.destroy();\n  PRFSalt.destroy();\n  if (prfW) prfW.destroy();\n  u.fill(0);\n  return DK;\n}\n\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nexport function pbkdf2(hash: CHash, password: Input, salt: Input, opts: Pbkdf2Opt) {\n  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + ⋯ + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    for (let ui = 1; ui < c; ui++) {\n      // Uc = PRF(Password, Uc−1)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    }\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n\nexport async function pbkdf2Async(hash: CHash, password: Input, salt: Input, opts: Pbkdf2Opt) {\n  const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n  let prfW: any; // Working copy\n  const arr = new Uint8Array(4);\n  const view = createView(arr);\n  const u = new Uint8Array(PRF.outputLen);\n  // DK = T1 + T2 + ⋯ + Tdklen/hlen\n  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n    // Ti = F(Password, Salt, c, i)\n    const Ti = DK.subarray(pos, pos + PRF.outputLen);\n    view.setInt32(0, ti, false);\n    // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n    Ti.set(u.subarray(0, Ti.length));\n    await asyncLoop(c - 1, asyncTick, (i) => {\n      // Uc = PRF(Password, Uc−1)\n      PRF._cloneInto(prfW).update(u).digestInto(u);\n      for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];\n    });\n  }\n  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n", "import assert from './_assert.js';\nimport { sha256 } from './sha256.js';\nimport { pbkdf2 } from './pbkdf2.js';\nimport { asyncLoop, checkOpts, Input, u32 } from './utils.js';\n\n// RFC 7914 Scrypt KDF\n\n// Left rotate for uint32\nconst rotl = (a: number, b: number) => (a << b) | (a >>> (32 - b));\n\n// The main Scrypt loop: uses Salsa extensively.\n// Six versions of the function were tried, this is the fastest one.\n// prettier-ignore\nfunction XorAndSalsa(\n  prev: Uint32Array,\n  pi: number,\n  input: Uint32Array,\n  ii: number,\n  out: Uint32Array,\n  oi: number\n) {\n  // Based on https://cr.yp.to/salsa20.html\n  // Xor blocks\n  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n  // Save state to temporary variables (salsa)\n  let x00 = y00, x01 = y01, x02 = y02, x03 = y03,\n      x04 = y04, x05 = y05, x06 = y06, x07 = y07,\n      x08 = y08, x09 = y09, x10 = y10, x11 = y11,\n      x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n  // Main loop (salsa)\n  for (let i = 0; i < 8; i += 2) {\n    x04 ^= rotl(x00 + x12 | 0,  7); x08 ^= rotl(x04 + x00 | 0,  9);\n    x12 ^= rotl(x08 + x04 | 0, 13); x00 ^= rotl(x12 + x08 | 0, 18);\n    x09 ^= rotl(x05 + x01 | 0,  7); x13 ^= rotl(x09 + x05 | 0,  9);\n    x01 ^= rotl(x13 + x09 | 0, 13); x05 ^= rotl(x01 + x13 | 0, 18);\n    x14 ^= rotl(x10 + x06 | 0,  7); x02 ^= rotl(x14 + x10 | 0,  9);\n    x06 ^= rotl(x02 + x14 | 0, 13); x10 ^= rotl(x06 + x02 | 0, 18);\n    x03 ^= rotl(x15 + x11 | 0,  7); x07 ^= rotl(x03 + x15 | 0,  9);\n    x11 ^= rotl(x07 + x03 | 0, 13); x15 ^= rotl(x11 + x07 | 0, 18);\n    x01 ^= rotl(x00 + x03 | 0,  7); x02 ^= rotl(x01 + x00 | 0,  9);\n    x03 ^= rotl(x02 + x01 | 0, 13); x00 ^= rotl(x03 + x02 | 0, 18);\n    x06 ^= rotl(x05 + x04 | 0,  7); x07 ^= rotl(x06 + x05 | 0,  9);\n    x04 ^= rotl(x07 + x06 | 0, 13); x05 ^= rotl(x04 + x07 | 0, 18);\n    x11 ^= rotl(x10 + x09 | 0,  7); x08 ^= rotl(x11 + x10 | 0,  9);\n    x09 ^= rotl(x08 + x11 | 0, 13); x10 ^= rotl(x09 + x08 | 0, 18);\n    x12 ^= rotl(x15 + x14 | 0,  7); x13 ^= rotl(x12 + x15 | 0,  9);\n    x14 ^= rotl(x13 + x12 | 0, 13); x15 ^= rotl(x14 + x13 | 0, 18);\n  }\n  // Write output (salsa)\n  out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;\n  out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;\n  out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;\n  out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;\n  out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;\n  out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;\n  out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;\n  out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0;\n}\n\nfunction BlockMix(input: Uint32Array, ii: number, out: Uint32Array, oi: number, r: number) {\n  // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n  let head = oi + 0;\n  let tail = oi + 16 * r;\n  for (let i = 0; i < 16; i++) out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X ← B[2r−1]\n  for (let i = 0; i < r; i++, head += 16, ii += 16) {\n    // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n    XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n    if (i > 0) tail += 16; // First iteration overwrites tmp value in tail\n    XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n  }\n}\n\nexport type ScryptOpts = {\n  N: number; // cost factor\n  r: number; // block size\n  p: number; // parallelization\n  dkLen?: number; // key length\n  asyncTick?: number; // block execution max time\n  maxmem?: number;\n  onProgress?: (progress: number) => void;\n};\n\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password: Input, salt: Input, _opts?: ScryptOpts) {\n  // Maxmem - 1GB+1KB by default\n  const opts = checkOpts(\n    {\n      dkLen: 32,\n      asyncTick: 10,\n      maxmem: 1024 ** 3 + 1024,\n    },\n    _opts\n  );\n  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\n  assert.number(N);\n  assert.number(r);\n  assert.number(p);\n  assert.number(dkLen);\n  assert.number(asyncTick);\n  assert.number(maxmem);\n  if (onProgress !== undefined && typeof onProgress !== 'function')\n    throw new Error('progressCb should be function');\n  const blockSize = 128 * r;\n  const blockSize32 = blockSize / 4;\n  if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {\n    // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function\n    // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.\n    throw new Error(\n      'Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32'\n    );\n  }\n  if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {\n    throw new Error(\n      'Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)'\n    );\n  }\n  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\n    throw new Error(\n      'Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32'\n    );\n  }\n  const memUsed = blockSize * (N + p);\n  if (memUsed > maxmem) {\n    throw new Error(\n      `Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`\n    );\n  }\n  // [B0...Bp−1] ← PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n  // Since it has only one iteration there is no reason to use async variant\n  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });\n  const B32 = u32(B);\n  // Re-used between parallel iterations. Array(iterations) of B\n  const V = u32(new Uint8Array(blockSize * N));\n  const tmp = u32(new Uint8Array(blockSize));\n  let blockMixCb = () => {};\n  if (onProgress) {\n    const totalBlockMix = 2 * N * p;\n    // Invoke callback if progress changes from 10.01 to 10.02\n    // Allows to draw smooth progress bar on up to 8K screen\n    const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n    let blockMixCnt = 0;\n    blockMixCb = () => {\n      blockMixCnt++;\n      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\n        onProgress(blockMixCnt / totalBlockMix);\n    };\n  }\n  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\n}\n\nfunction scryptOutput(\n  password: Input,\n  dkLen: number,\n  B: Uint8Array,\n  V: Uint32Array,\n  tmp: Uint32Array\n) {\n  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });\n  B.fill(0);\n  V.fill(0);\n  tmp.fill(0);\n  return res;\n}\n\n/**\n * Scrypt KDF from RFC 7914.\n * @param password - pass\n * @param salt - salt\n * @param opts - parameters\n * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)\n * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance\n * - `p` is parallelization factor (1 is common)\n * - `dkLen` is output key length in bytes e.g. 32.\n * - `asyncTick` - (default: 10) max time in ms for which async function can block execution\n * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt\n * - `onProgress` - callback function that would be executed for progress report\n * @returns Derived key\n */\nexport function scrypt(password: Input, salt: Input, opts: ScryptOpts) {\n  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(\n    password,\n    salt,\n    opts\n  );\n  for (let pi = 0; pi < p; pi++) {\n    const Pi = blockSize32 * pi;\n    for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]\n    for (let i = 0, pos = 0; i < N - 1; i++) {\n      BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n      blockMixCb();\n    }\n    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n    blockMixCb();\n    for (let i = 0; i < N; i++) {\n      // First u32 of the last 64-byte block (u32 is LE)\n      const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n      for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n      BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n      blockMixCb();\n    }\n  }\n  return scryptOutput(password, dkLen, B, V, tmp);\n}\n\n/**\n * Scrypt KDF from RFC 7914.\n */\nexport async function scryptAsync(password: Input, salt: Input, opts: ScryptOpts) {\n  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(\n    password,\n    salt,\n    opts\n  );\n  for (let pi = 0; pi < p; pi++) {\n    const Pi = blockSize32 * pi;\n    for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]\n    let pos = 0;\n    await asyncLoop(N - 1, asyncTick, (i) => {\n      BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n      blockMixCb();\n    });\n    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n    blockMixCb();\n    await asyncLoop(N, asyncTick, (i) => {\n      // First u32 of the last 64-byte block (u32 is LE)\n      const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n      for (let k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n      BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n      blockMixCb();\n    });\n  }\n  return scryptOutput(password, dkLen, B, V, tmp);\n}\n", "// nip49.ts\nimport { scrypt } from \"@noble/hashes/scrypt\";\nimport { xchacha20poly1305 } from \"@noble/ciphers/chacha\";\nimport { concatBytes as concatBytes2, randomBytes } from \"@noble/hashes/utils\";\n\n// nip19.ts\nimport { bytesToHex, concatBytes, hexToBytes } from \"@noble/hashes/utils\";\nimport { bech32 } from \"@scure/base\";\nvar Bech32MaxSize = 5e3;\nfunction encodeBech32(prefix, data) {\n  let words = bech32.toWords(data);\n  return bech32.encode(prefix, words, Bech32MaxSize);\n}\nfunction encodeBytes(prefix, bytes) {\n  return encodeBech32(prefix, bytes);\n}\n\n// nip49.ts\nimport { bech32 as bech322 } from \"@scure/base\";\nfunction encrypt(sec, password, logn = 16, ksb = 2) {\n  let salt = randomBytes(16);\n  let n = 2 ** logn;\n  let key = scrypt(password.normalize(\"NFKC\"), salt, { N: n, r: 8, p: 1, dkLen: 32 });\n  let nonce = randomBytes(24);\n  let aad = Uint8Array.from([ksb]);\n  let xc2p1 = xchacha20poly1305(key, nonce, aad);\n  let ciphertext = xc2p1.encrypt(sec);\n  let b = concatBytes2(Uint8Array.from([2]), Uint8Array.from([logn]), salt, nonce, aad, ciphertext);\n  return encodeBytes(\"ncryptsec\", b);\n}\nfunction decrypt(ncryptsec, password) {\n  let { prefix, words } = bech322.decode(ncryptsec, Bech32MaxSize);\n  if (prefix !== \"ncryptsec\") {\n    throw new Error(`invalid prefix ${prefix}, expected 'ncryptsec'`);\n  }\n  let b = new Uint8Array(bech322.fromWords(words));\n  let version = b[0];\n  if (version !== 2) {\n    throw new Error(`invalid version ${version}, expected 0x02`);\n  }\n  let logn = b[1];\n  let n = 2 ** logn;\n  let salt = b.slice(2, 2 + 16);\n  let nonce = b.slice(2 + 16, 2 + 16 + 24);\n  let ksb = b[2 + 16 + 24];\n  let aad = Uint8Array.from([ksb]);\n  let ciphertext = b.slice(2 + 16 + 24 + 1);\n  let key = scrypt(password.normalize(\"NFKC\"), salt, { N: n, r: 8, p: 1, dkLen: 32 });\n  let xc2p1 = xchacha20poly1305(key, nonce, aad);\n  let sec = xc2p1.decrypt(ciphertext);\n  return sec;\n}\nexport {\n  decrypt,\n  encrypt\n};\n"],
  "mappings": "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",
  "names": []
}
