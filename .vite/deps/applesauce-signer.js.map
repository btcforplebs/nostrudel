{
  "version": 3,
  "sources": ["browser-external:crypto", "../../node_modules/.pnpm/applesauce-core@0.7.0_typescript@5.6.2/node_modules/applesauce-core/dist/promise/deferred.js", "../../node_modules/.pnpm/applesauce-signer@0.7.0_typescript@5.6.2/node_modules/applesauce-signer/dist/signers/amber-clipboard-signer.js", "../../node_modules/.pnpm/applesauce-signer@0.7.0_typescript@5.6.2/node_modules/applesauce-signer/dist/signers/password-signer.js", "../../node_modules/.pnpm/applesauce-signer@0.7.0_typescript@5.6.2/node_modules/applesauce-signer/dist/signers/simple-signer.js", "../../node_modules/.pnpm/@noble+secp256k1@1.7.1/node_modules/@noble/secp256k1/lib/esm/index.js", "../../node_modules/.pnpm/applesauce-signer@0.7.0_typescript@5.6.2/node_modules/applesauce-signer/dist/logger.js", "../../node_modules/.pnpm/applesauce-signer@0.7.0_typescript@5.6.2/node_modules/applesauce-signer/dist/signers/serial-port-signer.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"crypto\" has been externalized for browser compatibility. Cannot access \"crypto.${key}\" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "export function createDefer() {\n    let _resolve;\n    let _reject;\n    const promise = new Promise((resolve, reject) => {\n        // @ts-ignore\n        _resolve = resolve;\n        _reject = reject;\n    });\n    // @ts-ignore\n    promise.resolve = _resolve;\n    // @ts-ignore\n    promise.reject = _reject;\n    return promise;\n}\n", "import { getEventHash, nip19, verifyEvent } from \"nostr-tools\";\nimport { getPubkeyFromDecodeResult, isHexKey, isHex } from \"applesauce-core/helpers\";\nimport { createDefer } from \"applesauce-core/promise\";\n/**\n * A Signer for [amber](https://github.com/greenart7c3/Amber) clipboard API\n * @see https://github.com/greenart7c3/Amber/blob/master/docs/web-apps.md\n */\nexport class AmberClipboardSigner {\n    /** If the signer is supported on this platform */\n    static SUPPORTED = navigator.userAgent.includes(\"Android\") && navigator.clipboard && navigator.clipboard.readText;\n    pendingRequest = null;\n    pubkey;\n    verifyEvent = verifyEvent;\n    nip04;\n    nip44;\n    constructor() {\n        document.addEventListener(\"visibilitychange\", this.onVisibilityChange);\n        this.nip04 = {\n            encrypt: this.nip04Encrypt.bind(this),\n            decrypt: this.nip04Decrypt.bind(this),\n        };\n        this.nip44 = {\n            encrypt: this.nip44Encrypt.bind(this),\n            decrypt: this.nip44Decrypt.bind(this),\n        };\n    }\n    onVisibilityChange = () => {\n        if (document.visibilityState === \"visible\") {\n            if (!this.pendingRequest || !navigator.clipboard)\n                return;\n            // read the result from the clipboard\n            setTimeout(() => {\n                navigator.clipboard\n                    .readText()\n                    .then((result) => this.pendingRequest?.resolve(result))\n                    .catch((e) => this.pendingRequest?.reject(e));\n            }, 200);\n        }\n    };\n    async intentRequest(intent) {\n        this.rejectPending();\n        const request = createDefer();\n        window.open(intent, \"_blank\");\n        // NOTE: wait 500ms before setting the pending request since the visibilitychange event fires as soon as window.open is called\n        setTimeout(() => {\n            this.pendingRequest = request;\n        }, 500);\n        const result = await request;\n        if (result.length === 0)\n            throw new Error(\"Empty clipboard\");\n        return result;\n    }\n    /** Reject the currently pending request */\n    rejectPending() {\n        if (this.pendingRequest) {\n            this.pendingRequest.reject(\"Canceled\");\n            this.pendingRequest = null;\n        }\n    }\n    /** Removes any event listeners created */\n    destroy() {\n        document.removeEventListener(\"visibilitychange\", this.onVisibilityChange);\n    }\n    checkSupport() {\n        if (!AmberClipboardSigner.SUPPORTED)\n            throw new Error(\"Cant use Amber on non-Android device\");\n    }\n    async getPublicKey() {\n        this.checkSupport();\n        if (this.pubkey)\n            return this.pubkey;\n        const result = await this.intentRequest(AmberClipboardSigner.createGetPublicKeyIntent());\n        if (isHexKey(result)) {\n            this.pubkey = result;\n            return result;\n        }\n        else if (result.startsWith(\"npub\") || result.startsWith(\"nprofile\")) {\n            const decode = nip19.decode(result);\n            const pubkey = getPubkeyFromDecodeResult(decode);\n            if (!pubkey)\n                throw new Error(\"Expected npub from clipboard\");\n            this.pubkey = pubkey;\n            return pubkey;\n        }\n        throw new Error(\"Expected clipboard to have pubkey\");\n    }\n    async signEvent(draft) {\n        this.checkSupport();\n        const pubkey = draft.pubkey || this.pubkey;\n        if (!pubkey)\n            throw new Error(\"Unknown signer pubkey\");\n        const draftWithId = { ...draft, id: getEventHash({ ...draft, pubkey }) };\n        const sig = await this.intentRequest(AmberClipboardSigner.createSignEventIntent(draftWithId));\n        if (!isHex(sig))\n            throw new Error(\"Expected hex signature\");\n        const event = { ...draftWithId, sig, pubkey };\n        if (!this.verifyEvent(event))\n            throw new Error(\"Invalid signature\");\n        return event;\n    }\n    // NIP-04\n    async nip04Encrypt(pubkey, plaintext) {\n        this.checkSupport();\n        const data = await this.intentRequest(AmberClipboardSigner.createNip04EncryptIntent(pubkey, plaintext));\n        return data;\n    }\n    async nip04Decrypt(pubkey, data) {\n        this.checkSupport();\n        const plaintext = await this.intentRequest(AmberClipboardSigner.createNip04DecryptIntent(pubkey, data));\n        return plaintext;\n    }\n    // NIP-44\n    async nip44Encrypt(pubkey, plaintext) {\n        this.checkSupport();\n        const data = await this.intentRequest(AmberClipboardSigner.createNip44EncryptIntent(pubkey, plaintext));\n        return data;\n    }\n    async nip44Decrypt(pubkey, data) {\n        this.checkSupport();\n        const plaintext = await this.intentRequest(AmberClipboardSigner.createNip44DecryptIntent(pubkey, data));\n        return plaintext;\n    }\n    // static methods\n    static createGetPublicKeyIntent() {\n        return `intent:#Intent;scheme=nostrsigner;S.compressionType=none;S.returnType=signature;S.type=get_public_key;end`;\n    }\n    static createSignEventIntent(draft) {\n        return `intent:${encodeURIComponent(JSON.stringify(draft))}#Intent;scheme=nostrsigner;S.compressionType=none;S.returnType=signature;S.type=sign_event;end`;\n    }\n    static createNip04EncryptIntent(pubkey, plainText) {\n        return `intent:${encodeURIComponent(plainText)}#Intent;scheme=nostrsigner;S.pubKey=${pubkey};S.compressionType=none;S.returnType=signature;S.type=nip04_encrypt;end`;\n    }\n    static createNip04DecryptIntent(pubkey, ciphertext) {\n        return `intent:${encodeURIComponent(ciphertext)}#Intent;scheme=nostrsigner;S.pubKey=${pubkey};S.compressionType=none;S.returnType=signature;S.type=nip04_decrypt;end`;\n    }\n    static createNip44EncryptIntent(pubkey, plainText) {\n        return `intent:${encodeURIComponent(plainText)}#Intent;scheme=nostrsigner;S.pubKey=${pubkey};S.compressionType=none;S.returnType=signature;S.type=nip44_encrypt;end`;\n    }\n    static createNip44DecryptIntent(pubkey, ciphertext) {\n        return `intent:${encodeURIComponent(ciphertext)}#Intent;scheme=nostrsigner;S.pubKey=${pubkey};S.compressionType=none;S.returnType=signature;S.type=nip44_decrypt;end`;\n    }\n}\n", "import { finalizeEvent, getPublicKey, nip04, nip44 } from \"nostr-tools\";\nimport { encrypt, decrypt } from \"nostr-tools/nip49\";\nimport { createDefer } from \"applesauce-core/promise\";\n/** A NIP-49 (Private Key Encryption) signer */\nexport class PasswordSigner {\n    key = null;\n    ncryptsec;\n    nip04;\n    nip44;\n    get unlocked() {\n        return !!this.key;\n    }\n    constructor() {\n        this.nip04 = {\n            encrypt: this.nip04Encrypt.bind(this),\n            decrypt: this.nip04Decrypt.bind(this),\n        };\n        this.nip44 = {\n            encrypt: this.nip44Encrypt.bind(this),\n            decrypt: this.nip44Decrypt.bind(this),\n        };\n    }\n    unlockPromise;\n    requestUnlock() {\n        if (this.key)\n            return;\n        if (this.unlockPromise)\n            return this.unlockPromise;\n        const p = createDefer();\n        this.unlockPromise = p;\n        return p;\n    }\n    async setPassword(password) {\n        if (!this.key)\n            throw new Error(\"Cant set password until unlocked\");\n        this.ncryptsec = encrypt(this.key, password);\n    }\n    async testPassword(password) {\n        if (this.ncryptsec) {\n            const key = decrypt(this.ncryptsec, password);\n            if (!key)\n                throw new Error(\"Failed to decrypt key\");\n        }\n        else\n            throw new Error(\"Missing ncryptsec\");\n    }\n    async unlock(password) {\n        if (this.key)\n            return;\n        if (this.ncryptsec) {\n            this.key = decrypt(this.ncryptsec, password);\n            if (!this.key)\n                throw new Error(\"Failed to decrypt key\");\n        }\n        else\n            throw new Error(\"Missing ncryptsec\");\n    }\n    // public methods\n    async getPublicKey() {\n        await this.requestUnlock();\n        return getPublicKey(this.key);\n    }\n    async signEvent(event) {\n        await this.requestUnlock();\n        return finalizeEvent(event, this.key);\n    }\n    // NIP-04\n    async nip04Encrypt(pubkey, plaintext) {\n        await this.requestUnlock();\n        return nip04.encrypt(this.key, pubkey, plaintext);\n    }\n    async nip04Decrypt(pubkey, ciphertext) {\n        await this.requestUnlock();\n        return nip04.decrypt(this.key, pubkey, ciphertext);\n    }\n    // NIP-44\n    async nip44Encrypt(pubkey, plaintext) {\n        await this.requestUnlock();\n        return nip44.v2.encrypt(plaintext, nip44.v2.utils.getConversationKey(this.key, pubkey));\n    }\n    async nip44Decrypt(pubkey, ciphertext) {\n        await this.requestUnlock();\n        return nip44.v2.decrypt(ciphertext, nip44.v2.utils.getConversationKey(this.key, pubkey));\n    }\n}\n", "import { finalizeEvent, generateSecretKey, getPublicKey, nip04, nip44 } from \"nostr-tools\";\n/** A Simple NIP-07 signer class */\nexport class SimpleSigner {\n    key;\n    constructor(key) {\n        this.key = key || generateSecretKey();\n    }\n    async getPublicKey() {\n        return getPublicKey(this.key);\n    }\n    async signEvent(event) {\n        return finalizeEvent(event, this.key);\n    }\n    nip04 = {\n        encrypt: async (pubkey, plaintext) => nip04.encrypt(this.key, pubkey, plaintext),\n        decrypt: async (pubkey, ciphertext) => nip04.decrypt(this.key, pubkey, ciphertext),\n    };\n    nip44 = {\n        encrypt: async (pubkey, plaintext) => nip44.v2.encrypt(plaintext, nip44.v2.utils.getConversationKey(this.key, pubkey)),\n        decrypt: async (pubkey, ciphertext) => nip44.v2.decrypt(ciphertext, nip44.v2.utils.getConversationKey(this.key, pubkey)),\n    };\n}\n", "/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    splitScalar(k) {\n        const { n } = CURVE;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg)\n            k1 = n - k1;\n        if (k2neg)\n            k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n    },\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\nexport { CURVE };\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint))\n        throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nexport class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen)\n            return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![0, 1, 2, 3].includes(recovery))\n            throw new Error('Cannot recover: invalid recovery bit');\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nexport class Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number 0 <= n < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    const rt = pow2(t2, _2n);\n    const xc = (rt * rt) % P;\n    if (xc !== x)\n        throw new Error('Cannot find square root');\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly)\n        return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen) {\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== 'number' || hashLen < 2)\n            throw new Error('hashLen must be a number');\n        if (typeof qByteLen !== 'number' || qByteLen < 2)\n            throw new Error('qByteLen must be a number');\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k))\n        return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 2 * groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nexport function getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexport function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === compressedLen || len === uncompressedLen;\n    if (str)\n        return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nexport function getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen)\n            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexport { sign, signSync };\nconst vopts = { strict: true };\nexport function verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nexport const schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint,\n};\nObject.defineProperties(utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n", "import debug from \"debug\";\nexport const logger = debug(\"applesauce:signer\");\n", "/// <reference types=\"@types/dom-serial\" />\nimport { getEventHash, verifyEvent } from \"nostr-tools\";\nimport { base64 } from \"@scure/base\";\nimport { randomBytes, hexToBytes } from \"@noble/hashes/utils\";\nimport { Point } from \"@noble/secp256k1\";\nimport { createDefer } from \"applesauce-core/promise\";\nimport { logger } from \"../logger.js\";\nconst sleep = (ms) => new Promise((r) => setTimeout(r, ms));\nfunction xOnlyToXY(p) {\n    return Point.fromHex(p).toHex().substring(2);\n}\nconst utf8Decoder = new TextDecoder(\"utf-8\");\nconst utf8Encoder = new TextEncoder();\n/** A signer that works with [nostr-signing-device](https://github.com/lnbits/nostr-signing-device) */\nexport class SerialPortSigner {\n    log = logger.extend(\"SerialPortSigner\");\n    writer = null;\n    pubkey;\n    get isConnected() {\n        return !!this.writer;\n    }\n    verifyEvent = verifyEvent;\n    nip04;\n    constructor() {\n        this.nip04 = {\n            encrypt: this.nip04Encrypt.bind(this),\n            decrypt: this.nip04Decrypt.bind(this),\n        };\n    }\n    lastCommand = null;\n    async callMethodOnDevice(method, params, opts = {}) {\n        if (!SerialPortSigner.SUPPORTED)\n            throw new Error(\"Serial devices are not supported\");\n        if (!this.writer)\n            await this.connectToDevice(opts);\n        // only one command can be pending at any time\n        // but each will only wait 6 seconds\n        if (this.lastCommand)\n            throw new Error(\"Previous command to device still pending!\");\n        const command = createDefer();\n        this.lastCommand = command;\n        // send actual command\n        this.sendCommand(method, params);\n        setTimeout(() => {\n            command.reject(new Error(\"Device timeout\"));\n            if (this.lastCommand === command)\n                this.lastCommand = null;\n        }, 6000);\n        return this.lastCommand;\n    }\n    async connectToDevice({ onConnect, onDisconnect, onError, onDone }) {\n        let port = await navigator.serial.requestPort();\n        let reader;\n        const startSerialPortReading = async () => {\n            // reading responses\n            while (port && port.readable) {\n                const textDecoder = new window.TextDecoderStream();\n                port.readable.pipeTo(textDecoder.writable);\n                reader = textDecoder.readable.getReader();\n                const readStringUntil = this.readFromSerialPort(reader);\n                try {\n                    while (true) {\n                        const { value, done } = await readStringUntil(\"\\n\");\n                        if (value) {\n                            const { method, data } = this.parseResponse(value);\n                            // if (method === \"/log\") deviceLog(data);\n                            if (method === \"/ping\")\n                                this.log(\"Pong\");\n                            if (SerialPortSigner.PUBLIC_METHODS.indexOf(method) === -1) {\n                                // ignore /ping, /log responses\n                                continue;\n                            }\n                            this.log(\"Received: \", method, data);\n                            if (this.lastCommand) {\n                                this.lastCommand.resolve(data);\n                                this.lastCommand = null;\n                            }\n                        }\n                        if (done) {\n                            this.lastCommand = null;\n                            this.writer = null;\n                            if (onDone)\n                                onDone();\n                            return;\n                        }\n                    }\n                }\n                catch (error) {\n                    if (error instanceof Error) {\n                        this.writer = null;\n                        if (onError)\n                            onError(error);\n                        if (this.lastCommand) {\n                            this.lastCommand.reject(error);\n                            this.lastCommand = null;\n                        }\n                        throw error;\n                    }\n                }\n            }\n        };\n        await port.open({ baudRate: 9600 });\n        // this `sleep()` is a hack, I know!\n        // but `port.onconnect` is never called. I don't know why!\n        await sleep(1000);\n        startSerialPortReading();\n        const textEncoder = new window.TextEncoderStream();\n        textEncoder.readable.pipeTo(port.writable);\n        this.writer = textEncoder.writable.getWriter();\n        // send ping first\n        await this.sendCommand(SerialPortSigner.METHOD_PING);\n        await this.sendCommand(SerialPortSigner.METHOD_PING, [window.location.host]);\n        if (onConnect)\n            onConnect();\n        port.addEventListener(\"disconnect\", () => {\n            this.log(\"Disconnected\");\n            this.lastCommand = null;\n            this.writer = null;\n            if (onDisconnect)\n                onDisconnect();\n        });\n    }\n    async sendCommand(method, params = []) {\n        if (!this.writer)\n            return;\n        this.log(\"Send command\", method, params);\n        const message = [method].concat(params).join(\" \");\n        await this.writer.write(message + \"\\n\");\n    }\n    readFromSerialPort(reader) {\n        let partialChunk;\n        let fulliness = [];\n        const readStringUntil = async (separator = \"\\n\") => {\n            if (fulliness.length)\n                return { value: fulliness.shift().trim(), done: false };\n            const chunks = [];\n            if (partialChunk) {\n                // leftovers from previous read\n                chunks.push(partialChunk);\n                partialChunk = undefined;\n            }\n            while (true) {\n                const { value, done } = await reader.read();\n                if (value) {\n                    const values = value.split(separator);\n                    // found one or more separators\n                    if (values.length > 1) {\n                        chunks.push(values.shift()); // first element\n                        partialChunk = values.pop(); // last element\n                        fulliness = values; // full lines\n                        return { value: chunks.join(\"\").trim(), done: false };\n                    }\n                    chunks.push(value);\n                }\n                if (done)\n                    return { value: chunks.join(\"\").trim(), done: true };\n            }\n        };\n        return readStringUntil;\n    }\n    parseResponse(value) {\n        const method = value.split(\" \")[0];\n        const data = value.substring(method.length).trim();\n        return { method, data };\n    }\n    // NIP-04\n    async nip04Encrypt(pubkey, text) {\n        const sharedSecretStr = await this.callMethodOnDevice(SerialPortSigner.METHOD_SHARED_SECRET, [xOnlyToXY(pubkey)]);\n        const sharedSecret = hexToBytes(sharedSecretStr);\n        let iv = Uint8Array.from(randomBytes(16));\n        let plaintext = utf8Encoder.encode(text);\n        let cryptoKey = await crypto.subtle.importKey(\"raw\", sharedSecret, { name: \"AES-CBC\" }, false, [\"encrypt\"]);\n        let ciphertext = await crypto.subtle.encrypt({ name: \"AES-CBC\", iv }, cryptoKey, plaintext);\n        let ctb64 = base64.encode(new Uint8Array(ciphertext));\n        let ivb64 = base64.encode(new Uint8Array(iv.buffer));\n        return `${ctb64}?iv=${ivb64}`;\n    }\n    async nip04Decrypt(pubkey, data) {\n        let [ctb64, ivb64] = data.split(\"?iv=\");\n        const sharedSecretStr = await this.callMethodOnDevice(SerialPortSigner.METHOD_SHARED_SECRET, [xOnlyToXY(pubkey)]);\n        const sharedSecret = hexToBytes(sharedSecretStr);\n        let cryptoKey = await crypto.subtle.importKey(\"raw\", sharedSecret, { name: \"AES-CBC\" }, false, [\"decrypt\"]);\n        let ciphertext = base64.decode(ctb64);\n        let iv = base64.decode(ivb64);\n        let plaintext = await crypto.subtle.decrypt({ name: \"AES-CBC\", iv }, cryptoKey, ciphertext);\n        let text = utf8Decoder.decode(plaintext);\n        return text;\n    }\n    async getPublicKey() {\n        const pubkey = await this.callMethodOnDevice(SerialPortSigner.METHOD_PUBLIC_KEY, []);\n        this.pubkey = pubkey;\n        return pubkey;\n    }\n    async signEvent(draft) {\n        const pubkey = draft.pubkey || this.pubkey;\n        if (!pubkey)\n            throw new Error(\"Unknown signer pubkey\");\n        const draftWithId = { ...draft, id: getEventHash({ ...draft, pubkey }) };\n        const sig = await this.callMethodOnDevice(SerialPortSigner.METHOD_SIGN_MESSAGE, [draftWithId.id]);\n        const event = { ...draftWithId, sig, pubkey };\n        if (!this.verifyEvent(event))\n            throw new Error(\"Invalid signature\");\n        return event;\n    }\n    ping() {\n        this.sendCommand(SerialPortSigner.METHOD_PING, [window.location.host]);\n    }\n    // static const\n    static SUPPORTED = !!navigator.serial;\n    static METHOD_PING = \"/ping\";\n    static METHOD_LOG = \"/log\";\n    static METHOD_SIGN_MESSAGE = \"/sign-message\";\n    static METHOD_SHARED_SECRET = \"/shared-secret\";\n    static METHOD_PUBLIC_KEY = \"/public-key\";\n    static PUBLIC_METHODS = [\n        SerialPortSigner.METHOD_PUBLIC_KEY,\n        SerialPortSigner.METHOD_SIGN_MESSAGE,\n        SerialPortSigner.METHOD_SHARED_SECRET,\n    ];\n}\n"],
  "mappings": "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",
  "names": ["d", "window", "hexToBytes", "crypto", "hexToBytes", "crypto", "randomBytes", "debug"]
}
