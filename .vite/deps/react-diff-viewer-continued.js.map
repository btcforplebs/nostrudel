{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/classnames@2.5.1/node_modules/classnames/index.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/diff/base.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/diff/character.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/util/params.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/diff/word.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/diff/line.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/diff/sentence.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/diff/css.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/diff/json.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/diff/array.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/patch/parse.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/util/distance-iterator.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/patch/apply.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/patch/create.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/util/array.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/patch/merge.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/patch/reverse.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/convert/dmp.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/convert/xml.js", "../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/src/index.js", "../../node_modules/.pnpm/react-diff-viewer-continued@3.4.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-diff-viewer-continued/lib/src/compute-lines.js", "../../node_modules/.pnpm/react-diff-viewer-continued@3.4.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-diff-viewer-continued/lib/src/compute-hidden-blocks.js", "../../node_modules/.pnpm/memoize-one@6.0.0/node_modules/memoize-one/dist/memoize-one.esm.js", "../../node_modules/.pnpm/react-diff-viewer-continued@3.4.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/react-diff-viewer-continued/lib/src/index.js"],
  "sourcesContent": ["/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (arg) {\n\t\t\t\tclasses = appendClass(classes, parseValue(arg));\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction parseValue (arg) {\n\t\tif (typeof arg === 'string' || typeof arg === 'number') {\n\t\t\treturn arg;\n\t\t}\n\n\t\tif (typeof arg !== 'object') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (Array.isArray(arg)) {\n\t\t\treturn classNames.apply(null, arg);\n\t\t}\n\n\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\treturn arg.toString();\n\t\t}\n\n\t\tvar classes = '';\n\n\t\tfor (var key in arg) {\n\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\tclasses = appendClass(classes, key);\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction appendClass (value, newClass) {\n\t\tif (!newClass) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (value) {\n\t\t\treturn value + ' ' + newClass;\n\t\t}\n\t\n\t\treturn value + newClass;\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n", "export default function Diff() {}\n\nDiff.prototype = {\n  diff(oldString, newString, options = {}) {\n    let callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n\n    let self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function() { callback(undefined, value); }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n\n    let newLen = newString.length, oldLen = oldString.length;\n    let editLength = 1;\n    let maxEditLength = newLen + oldLen;\n    if(options.maxEditLength) {\n      maxEditLength = Math.min(maxEditLength, options.maxEditLength);\n    }\n    const maxExecutionTime = options.timeout ?? Infinity;\n    const abortAfterTimestamp = Date.now() + maxExecutionTime;\n\n    let bestPath = [{ oldPos: -1, lastComponent: undefined }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let newPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n      // Identity per the equality and tokenizer\n      return done([{value: this.join(newString), count: newString.length}]);\n    }\n\n    // Once we hit the right edge of the edit graph on some diagonal k, we can\n    // definitely reach the end of the edit graph in no more than k edits, so\n    // there's no point in considering any moves to diagonal k+1 any more (from\n    // which we're guaranteed to need at least k+1 more edits).\n    // Similarly, once we've reached the bottom of the edit graph, there's no\n    // point considering moves to lower diagonals.\n    // We record this fact by setting minDiagonalToConsider and\n    // maxDiagonalToConsider to some finite value once we've hit the edge of\n    // the edit graph.\n    // This optimization is not faithful to the original algorithm presented in\n    // Myers's paper, which instead pointlessly extends D-paths off the end of\n    // the edit graph - see page 7 of Myers's paper which notes this point\n    // explicitly and illustrates it with a diagram. This has major performance\n    // implications for some common scenarios. For instance, to compute a diff\n    // where the new text simply appends d characters on the end of the\n    // original text of length n, the true Myers algorithm will take O(n+d^2)\n    // time while this optimization needs only O(n+d) time.\n    let minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (\n        let diagonalPath = Math.max(minDiagonalToConsider, -editLength);\n        diagonalPath <= Math.min(maxDiagonalToConsider, editLength);\n        diagonalPath += 2\n      ) {\n        let basePath;\n        let removePath = bestPath[diagonalPath - 1],\n            addPath = bestPath[diagonalPath + 1];\n        if (removePath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        let canAdd = false;\n        if (addPath) {\n          // what newPos will be after we do an insertion:\n          const addPathNewPos = addPath.oldPos - diagonalPath;\n          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;\n        }\n\n        let canRemove = removePath && removePath.oldPos + 1 < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the old string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        // TODO: Remove the `+ 1` here to make behavior match Myers algorithm\n        //       and prefer to order removals before insertions.\n        if (!canRemove || (canAdd && removePath.oldPos + 1 < addPath.oldPos)) {\n          basePath = self.addToPath(addPath, true, undefined, 0);\n        } else {\n          basePath = self.addToPath(removePath, undefined, true, 1);\n        }\n\n        newPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {\n          // If we have hit the end of both strings, then we are done\n          return done(buildValues(self, basePath.lastComponent, newString, oldString, self.useLongestToken));\n        } else {\n          bestPath[diagonalPath] = basePath;\n          if (basePath.oldPos + 1 >= oldLen) {\n            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);\n          }\n          if (newPos + 1 >= newLen) {\n            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);\n          }\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n    if (callback) {\n      (function exec() {\n        setTimeout(function() {\n          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      }());\n    } else {\n      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {\n        let ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  addToPath(path, added, removed, oldPosInc) {\n    let last = path.lastComponent;\n    if (last && last.added === added && last.removed === removed) {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {count: last.count + 1, added: added, removed: removed, previousComponent: last.previousComponent }\n      };\n    } else {\n      return {\n        oldPos: path.oldPos + oldPosInc,\n        lastComponent: {count: 1, added: added, removed: removed, previousComponent: last }\n      };\n    }\n  },\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n        oldLen = oldString.length,\n        oldPos = basePath.oldPos,\n        newPos = oldPos - diagonalPath,\n\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.lastComponent = {count: commonCount, previousComponent: basePath.lastComponent};\n    }\n\n    basePath.oldPos = oldPos;\n    return newPos;\n  },\n\n  equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right\n        || (this.options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n    }\n  },\n  removeEmpty(array) {\n    let ret = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput(value) {\n    return value;\n  },\n  tokenize(value) {\n    return value.split('');\n  },\n  join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, lastComponent, newString, oldString, useLongestToken) {\n  // First we convert our linked list of components in reverse order to an\n  // array in the right order:\n  const components = [];\n  let nextComponent;\n  while (lastComponent) {\n    components.push(lastComponent);\n    nextComponent = lastComponent.previousComponent;\n    delete lastComponent.previousComponent;\n    lastComponent = nextComponent;\n  }\n  components.reverse();\n\n  let componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        let value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function(value, i) {\n          let oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let finalComponent = components[componentLen - 1];\n  if (componentLen > 1\n      && typeof finalComponent.value === 'string'\n      && (finalComponent.added || finalComponent.removed)\n      && diff.equals('', finalComponent.value)) {\n    components[componentLen - 2].value += finalComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n", "import Diff from './base';\n\nexport const characterDiff = new Diff();\nexport function diffChars(oldStr, newStr, options) { return characterDiff.diff(oldStr, newStr, options); }\n", "export function generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (let name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n  return defaults;\n}\n", "import Diff from './base';\nimport {generateOptions} from '../util/params';\n\n// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nconst extendedWordChars = /^[a-zA-Z\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}]+$/u;\n\nconst reWhitespace = /\\S/;\n\nexport const wordDiff = new Diff();\nwordDiff.equals = function(left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n  return left === right || (this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));\n};\nwordDiff.tokenize = function(value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  let tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/);\n\n  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n  for (let i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2]\n          && extendedWordChars.test(tokens[i])\n          && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nexport function diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {ignoreWhitespace: true});\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nexport function diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n", "import Diff from './base';\nimport {generateOptions} from '../util/params';\n\nexport const lineDiff = new Diff();\nlineDiff.tokenize = function(value) {\n  if(this.options.stripTrailingCr) {\n    // remove one \\r before \\n to match GNU diff's --strip-trailing-cr behavior\n    value = value.replace(/\\r\\n/g, '\\n');\n  }\n\n  let retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n  // Ignore the final empty token that occurs if the string ends with a new line\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  }\n\n  // Merge the content and line separators into single tokens\n  for (let i = 0; i < linesAndNewlines.length; i++) {\n    let line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nexport function diffLines(oldStr, newStr, callback) { return lineDiff.diff(oldStr, newStr, callback); }\nexport function diffTrimmedLines(oldStr, newStr, callback) {\n  let options = generateOptions(callback, {ignoreWhitespace: true});\n  return lineDiff.diff(oldStr, newStr, options);\n}\n", "import Diff from './base';\n\n\nexport const sentenceDiff = new Diff();\nsentenceDiff.tokenize = function(value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nexport function diffSentences(oldStr, newStr, callback) { return sentenceDiff.diff(oldStr, newStr, callback); }\n", "import Diff from './base';\n\nexport const cssDiff = new Diff();\ncssDiff.tokenize = function(value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nexport function diffCss(oldStr, newStr, callback) { return cssDiff.diff(oldStr, newStr, callback); }\n", "import Diff from './base';\nimport {lineDiff} from './line';\n\nconst objectPrototypeToString = Object.prototype.toString;\n\n\nexport const jsonDiff = new Diff();\n// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken = true;\n\njsonDiff.tokenize = lineDiff.tokenize;\njsonDiff.castInput = function(value) {\n  const {undefinedReplacement, stringifyReplacer = (k, v) => typeof v === 'undefined' ? undefinedReplacement : v} = this.options;\n\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\njsonDiff.equals = function(left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nexport function diffJson(oldObj, newObj, options) { return jsonDiff.diff(oldObj, newObj, options); }\n\n// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nexport function canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  let i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  let canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (typeof obj === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n    let sortedKeys = [],\n        key;\n    for (key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(key)) {\n        sortedKeys.push(key);\n      }\n    }\n    sortedKeys.sort();\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      key = sortedKeys[i];\n      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack, replacer, key);\n    }\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n  return canonicalizedObj;\n}\n", "import Diff from './base';\n\nexport const arrayDiff = new Diff();\narrayDiff.tokenize = function(value) {\n  return value.slice();\n};\narrayDiff.join = arrayDiff.removeEmpty = function(value) {\n  return value;\n};\n\nexport function diffArrays(oldArr, newArr, callback) { return arrayDiff.diff(oldArr, newArr, callback); }\n", "export function parsePatch(uniDiff, options = {}) {\n  let diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    let index = {};\n    list.push(index);\n\n    // Parse diff metadata\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      // File header found, end parsing diff metadata\n      if ((/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/).test(line)) {\n        break;\n      }\n\n      // Diff index\n      let header = (/^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/).exec(line);\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    }\n\n    // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n    parseFileHeader(index);\n    parseFileHeader(index);\n\n    // Parse hunks\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      let line = diffstr[i];\n\n      if ((/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/).test(line)) {\n        break;\n      } else if ((/^@@/).test(line)) {\n        index.hunks.push(parseHunk());\n      } else if (line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(line));\n      } else {\n        i++;\n      }\n    }\n  }\n\n  // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n  function parseFileHeader(index) {\n    const fileHeader = (/^(---|\\+\\+\\+)\\s+(.*)$/).exec(diffstr[i]);\n    if (fileHeader) {\n      let keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      const data = fileHeader[2].split('\\t', 2);\n      let fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n      if ((/^\".*\"$/).test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n      i++;\n    }\n  }\n\n  // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n  function parseHunk() {\n    let chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n    let hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    };\n\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    let addCount = 0,\n        removeCount = 0;\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0\n            && (i + 2 < diffstr.length)\n            && diffstr[i + 1].indexOf('+++ ') === 0\n            && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n      }\n      let operation = (diffstr[i].length == 0 && i != (diffstr.length - 1)) ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Handle the empty block count case\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    }\n\n    // Perform optional sanity checking\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n", "// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nexport default function(start, minLine, maxLine) {\n  let wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      }\n\n      // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      }\n\n      // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    }\n\n    // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n  };\n}\n", "import {parsePatch} from './parse';\nimport distanceIterator from '../util/distance-iterator';\n\nexport function applyPatch(source, uniDiff, options = {}) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  }\n\n  // Apply the diff to the input\n  let lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n\n      compareLine = options.compareLine || ((lineNumber, line, operation, patchContent) => line === patchContent),\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n\n      removeEOFNL,\n      addEOFNL;\n\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n  function hunkFits(hunk, toPos) {\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line);\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n        toPos++;\n      }\n    }\n\n    return true;\n  }\n\n  // Search best fit offsets for each hunk based on the previous ones\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n\n    let iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    }\n\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  }\n\n  // Apply patch hunks\n  let diffOffset = 0;\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        toPos = hunk.oldStart + hunk.offset + diffOffset - 1;\n    diffOffset += hunk.newLines - hunk.oldLines;\n\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line),\n          delimiter = hunk.linedelimiters && hunk.linedelimiters[j] || '\\n';\n\n      if (operation === ' ') {\n        toPos++;\n      } else if (operation === '-') {\n        lines.splice(toPos, 1);\n        delimiters.splice(toPos, 1);\n      /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(toPos, 0, content);\n        delimiters.splice(toPos, 0, delimiter);\n        toPos++;\n      } else if (operation === '\\\\') {\n        let previousOperation = hunk.lines[j - 1] ? hunk.lines[j - 1][0] : null;\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  }\n\n  // Handle EOFNL insertion/removal\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n  for (let _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n  return lines.join('');\n}\n\n// Wrapper that supports multiple file patches via callbacks.\nexport function applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  let currentIndex = 0;\n  function processIndex() {\n    let index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function(err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      let updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function(err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}\n", "import {diffLines} from '../diff/line';\n\nexport function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  const diff = diffLines(oldStr, newStr, options);\n  if(!diff) {\n    return;\n  }\n\n  diff.push({value: '', lines: []}); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function(entry) { return ' ' + entry; });\n  }\n\n  let hunks = [];\n  let oldRangeStart = 0, newRangeStart = 0, curRange = [],\n      oldLine = 1, newLine = 1;\n  for (let i = 0; i < diff.length; i++) {\n    const current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        const prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      }\n\n      // Output our changes\n      curRange.push(... lines.map(function(entry) {\n        return (current.added ? '+' : '-') + entry;\n      }));\n\n      // Track the updated file position\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          // Overlapping\n          curRange.push(... contextLines(lines));\n        } else {\n          // end the range and output\n          let contextSize = Math.min(lines.length, options.context);\n          curRange.push(... contextLines(lines.slice(0, contextSize)));\n\n          let hunk = {\n            oldStart: oldRangeStart,\n            oldLines: (oldLine - oldRangeStart + contextSize),\n            newStart: newRangeStart,\n            newLines: (newLine - newRangeStart + contextSize),\n            lines: curRange\n          };\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            let oldEOFNewline = ((/\\n$/).test(oldStr));\n            let newEOFNewline = ((/\\n$/).test(newStr));\n            let noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n            if ((!oldEOFNewline && !noNlBeforeAdds) || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n          hunks.push(hunk);\n\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  }\n\n  return {\n    oldFileName: oldFileName, newFileName: newFileName,\n    oldHeader: oldHeader, newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nexport function formatPatch(diff) {\n  if (Array.isArray(diff)) {\n    return diff.map(formatPatch).join('\\n');\n  }\n\n  const ret = [];\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (let i = 0; i < diff.hunks.length; i++) {\n    const hunk = diff.hunks[i];\n    // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n    ret.push(\n      '@@ -' + hunk.oldStart + ',' + hunk.oldLines\n      + ' +' + hunk.newStart + ',' + hunk.newLines\n      + ' @@'\n    );\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nexport function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\n\nexport function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n", "export function arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\n\nexport function arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n", "import {structuredPatch} from './create';\nimport {parsePatch} from './parse';\n\nimport {arrayEqual, arrayStartsWith} from '../util/array';\n\nexport function calcLineCount(hunk) {\n  const {oldLines, newLines} = calcOldNewLineCount(hunk.lines);\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nexport function merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n\n  let ret = {};\n\n  // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n\n  let mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    let mineCurrent = mine.hunks[mineIndex] || {oldStart: Infinity},\n        theirsCurrent = theirs.hunks[theirsIndex] || {oldStart: Infinity};\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      let mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if ((/^@@/m).test(param) || ((/^Index:/m).test(param))) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {mine, theirs};\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart\n    && (test.oldStart + test.oldLines) < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  let mine = {offset: mineOffset, lines: mineLines, index: 0},\n      their = {offset: theirOffset, lines: theirLines, index: 0};\n\n  // Handle any leading content\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine);\n\n  // Now in the overlap content. Scan through and select the best changes from each.\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    let mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+')\n        && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      // Mine inserted\n      hunk.lines.push(... collectChange(mine));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      // Theirs inserted\n      hunk.lines.push(... collectChange(their));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  }\n\n  // Now push anything that may be remaining\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges)\n        && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      hunk.lines.push(... myChanges);\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges)\n        && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      hunk.lines.push(... theirChanges);\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    hunk.lines.push(... myChanges);\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    hunk.lines.push(... theirChanges.merged);\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  let ret = [],\n      operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    let line = state.lines[state.index];\n\n    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  let changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n  while (matchIndex < matchChanges.length\n        && state.index < state.lines.length) {\n    let change = state.lines[state.index],\n        match = matchChanges[matchIndex];\n\n    // Once we've hit our add, then we are done\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n\n    merged.push(match);\n    matchIndex++;\n\n    // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+'\n      && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged,\n    changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function(prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (let i = 0; i < delta; i++) {\n    let changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  let oldLines = 0;\n  let newLines = 0;\n\n  lines.forEach(function(line) {\n    if (typeof line !== 'string') {\n      let myCount = calcOldNewLineCount(line.mine);\n      let theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n\n  return {oldLines, newLines};\n}\n", "export function reversePatch(structuredPatch) {\n  if (Array.isArray(structuredPatch)) {\n    return structuredPatch.map(reversePatch).reverse();\n  }\n\n  return {\n    ...structuredPatch,\n    oldFileName: structuredPatch.newFileName,\n    oldHeader: structuredPatch.newHeader,\n    newFileName: structuredPatch.oldFileName,\n    newHeader: structuredPatch.oldHeader,\n    hunks: structuredPatch.hunks.map(hunk => {\n      return {\n        oldLines: hunk.newLines,\n        oldStart: hunk.newStart,\n        newLines: hunk.oldLines,\n        newStart: hunk.oldStart,\n        linedelimiters: hunk.linedelimiters,\n        lines: hunk.lines.map(l => {\n          if (l.startsWith('-')) { return `+${l.slice(1)}`; }\n          if (l.startsWith('+')) { return `-${l.slice(1)}`; }\n          return l;\n        })\n      };\n    })\n  };\n}\n", "// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nexport function convertChangesToDMP(changes) {\n  let ret = [],\n      change,\n      operation;\n  for (let i = 0; i < changes.length; i++) {\n    change = changes[i];\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n  return ret;\n}\n", "export function convertChangesToXML(changes) {\n  let ret = [];\n  for (let i = 0; i < changes.length; i++) {\n    let change = changes[i];\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  let n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n\n  return n;\n}\n", "/* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIs:\n * Diff.diffChars: Character by character diff\n * Diff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * Diff.diffLines: Line based diff\n *\n * Diff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\nimport Diff from './diff/base';\nimport {diffChars} from './diff/character';\nimport {diffWords, diffWordsWithSpace} from './diff/word';\nimport {diffLines, diffTrimmedLines} from './diff/line';\nimport {diffSentences} from './diff/sentence';\n\nimport {diffCss} from './diff/css';\nimport {diffJson, canonicalize} from './diff/json';\n\nimport {diffArrays} from './diff/array';\n\nimport {applyPatch, applyPatches} from './patch/apply';\nimport {parsePatch} from './patch/parse';\nimport {merge} from './patch/merge';\nimport {reversePatch} from './patch/reverse';\nimport {structuredPatch, createTwoFilesPatch, createPatch, formatPatch} from './patch/create';\n\nimport {convertChangesToDMP} from './convert/dmp';\nimport {convertChangesToXML} from './convert/xml';\n\nexport {\n  Diff,\n\n  diffChars,\n  diffWords,\n  diffWordsWithSpace,\n  diffLines,\n  diffTrimmedLines,\n  diffSentences,\n\n  diffCss,\n  diffJson,\n\n  diffArrays,\n\n  structuredPatch,\n  createTwoFilesPatch,\n  createPatch,\n  formatPatch,\n  applyPatch,\n  applyPatches,\n  parsePatch,\n  merge,\n  reversePatch,\n  convertChangesToDMP,\n  convertChangesToXML,\n  canonicalize\n};\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeLineInformation = exports.DiffMethod = exports.DiffType = void 0;\nconst diff = __importStar(require(\"diff\"));\nconst jsDiff = diff;\nvar DiffType;\n(function (DiffType) {\n    DiffType[DiffType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    DiffType[DiffType[\"ADDED\"] = 1] = \"ADDED\";\n    DiffType[DiffType[\"REMOVED\"] = 2] = \"REMOVED\";\n    DiffType[DiffType[\"CHANGED\"] = 3] = \"CHANGED\";\n})(DiffType || (exports.DiffType = DiffType = {}));\n// See https://github.com/kpdecker/jsdiff/tree/v4.0.1#api for more info on the below JsDiff methods\nvar DiffMethod;\n(function (DiffMethod) {\n    DiffMethod[\"CHARS\"] = \"diffChars\";\n    DiffMethod[\"WORDS\"] = \"diffWords\";\n    DiffMethod[\"WORDS_WITH_SPACE\"] = \"diffWordsWithSpace\";\n    DiffMethod[\"LINES\"] = \"diffLines\";\n    DiffMethod[\"TRIMMED_LINES\"] = \"diffTrimmedLines\";\n    DiffMethod[\"SENTENCES\"] = \"diffSentences\";\n    DiffMethod[\"CSS\"] = \"diffCss\";\n    DiffMethod[\"JSON\"] = \"diffJson\";\n})(DiffMethod || (exports.DiffMethod = DiffMethod = {}));\n/**\n * Splits diff text by new line and computes final list of diff lines based on\n * conditions.\n *\n * @param value Diff text from the js diff module.\n */\nconst constructLines = (value) => {\n    if (value === '')\n        return [];\n    const lines = value.replace(/\\n$/, '').split('\\n');\n    return lines;\n};\n/**\n * Computes word diff information in the line.\n * [TODO]: Consider adding options argument for JsDiff text block comparison\n *\n * @param oldValue Old word in the line.\n * @param newValue New word in the line.\n * @param compareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n */\nconst computeDiff = (oldValue, newValue, compareMethod = DiffMethod.CHARS) => {\n    const diffArray = jsDiff[compareMethod](oldValue, newValue);\n    const computedDiff = {\n        left: [],\n        right: [],\n    };\n    diffArray.forEach(({ added, removed, value }) => {\n        const diffInformation = {};\n        if (added) {\n            diffInformation.type = DiffType.ADDED;\n            diffInformation.value = value;\n            computedDiff.right.push(diffInformation);\n        }\n        if (removed) {\n            diffInformation.type = DiffType.REMOVED;\n            diffInformation.value = value;\n            computedDiff.left.push(diffInformation);\n        }\n        if (!removed && !added) {\n            diffInformation.type = DiffType.DEFAULT;\n            diffInformation.value = value;\n            computedDiff.right.push(diffInformation);\n            computedDiff.left.push(diffInformation);\n        }\n        return diffInformation;\n    });\n    return computedDiff;\n};\n/**\n * [TODO]: Think about moving common left and right value assignment to a\n * common place. Better readability?\n *\n * Computes line wise information based in the js diff information passed. Each\n * line contains information about left and right section. Left side denotes\n * deletion and right side denotes addition.\n *\n * @param oldString Old string to compare.\n * @param newString New string to compare with old string.\n * @param disableWordDiff Flag to enable/disable word diff.\n * @param lineCompareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n * @param linesOffset line number to start counting from\n * @param showLines lines that are always shown, regardless of diff\n */\nconst computeLineInformation = (oldString, newString, disableWordDiff = false, lineCompareMethod = DiffMethod.CHARS, linesOffset = 0, showLines = []) => {\n    let diffArray = [];\n    // Use diffLines for strings, and diffJson for objects...\n    if (typeof oldString === 'string' && typeof newString === 'string') {\n        diffArray = diff.diffLines(oldString.trimRight(), newString.trimRight(), {\n            newlineIsToken: false,\n            ignoreWhitespace: false,\n            ignoreCase: false,\n        });\n    }\n    else {\n        diffArray = diff.diffJson(oldString, newString);\n    }\n    let rightLineNumber = linesOffset;\n    let leftLineNumber = linesOffset;\n    let lineInformation = [];\n    let counter = 0;\n    const diffLines = [];\n    const ignoreDiffIndexes = [];\n    const getLineInformation = (value, diffIndex, added, removed, evaluateOnlyFirstLine) => {\n        const lines = constructLines(value);\n        return lines\n            .map((line, lineIndex) => {\n            const left = {};\n            const right = {};\n            if (ignoreDiffIndexes.includes(`${diffIndex}-${lineIndex}`) ||\n                (evaluateOnlyFirstLine && lineIndex !== 0)) {\n                return undefined;\n            }\n            if (added || removed) {\n                let countAsChange = true;\n                if (removed) {\n                    leftLineNumber += 1;\n                    left.lineNumber = leftLineNumber;\n                    left.type = DiffType.REMOVED;\n                    left.value = line || ' ';\n                    // When the current line is of type REMOVED, check the next item in\n                    // the diff array whether it is of type ADDED. If true, the current\n                    // diff will be marked as both REMOVED and ADDED. Meaning, the\n                    // current line is a modification.\n                    const nextDiff = diffArray[diffIndex + 1];\n                    if (nextDiff && nextDiff.added) {\n                        const nextDiffLines = constructLines(nextDiff.value)[lineIndex];\n                        if (nextDiffLines) {\n                            const nextDiffLineInfo = getLineInformation(nextDiffLines, diffIndex, true, false, true);\n                            const { value: rightValue, lineNumber, type, } = nextDiffLineInfo[0].right;\n                            // When identified as modification, push the next diff to ignore\n                            // list as the next value will be added in this line computation as\n                            // right and left values.\n                            ignoreDiffIndexes.push(`${diffIndex + 1}-${lineIndex}`);\n                            right.lineNumber = lineNumber;\n                            if (left.value === rightValue) {\n                                // The new value is exactly the same as the old\n                                countAsChange = false;\n                                right.type = 0;\n                                left.type = 0;\n                                right.value = rightValue;\n                            }\n                            else {\n                                right.type = type;\n                                // Do char level diff and assign the corresponding values to the\n                                // left and right diff information object.\n                                if (disableWordDiff) {\n                                    right.value = rightValue;\n                                }\n                                else {\n                                    const computedDiff = computeDiff(line, rightValue, lineCompareMethod);\n                                    right.value = computedDiff.right;\n                                    left.value = computedDiff.left;\n                                }\n                            }\n                        }\n                    }\n                }\n                else {\n                    rightLineNumber += 1;\n                    right.lineNumber = rightLineNumber;\n                    right.type = DiffType.ADDED;\n                    right.value = line;\n                }\n                if (countAsChange && !evaluateOnlyFirstLine) {\n                    if (!diffLines.includes(counter)) {\n                        diffLines.push(counter);\n                    }\n                }\n            }\n            else {\n                leftLineNumber += 1;\n                rightLineNumber += 1;\n                left.lineNumber = leftLineNumber;\n                left.type = DiffType.DEFAULT;\n                left.value = line;\n                right.lineNumber = rightLineNumber;\n                right.type = DiffType.DEFAULT;\n                right.value = line;\n            }\n            if ((showLines === null || showLines === void 0 ? void 0 : showLines.includes(`L-${left.lineNumber}`)) || (showLines === null || showLines === void 0 ? void 0 : showLines.includes(`R-${right.lineNumber}`)) && !diffLines.includes(counter)) {\n                diffLines.push(counter);\n            }\n            if (!evaluateOnlyFirstLine) {\n                counter += 1;\n            }\n            return { right, left };\n        })\n            .filter(Boolean);\n    };\n    diffArray.forEach(({ added, removed, value }, index) => {\n        lineInformation = [\n            ...lineInformation,\n            ...getLineInformation(value, index, added, removed),\n        ];\n    });\n    return {\n        lineInformation,\n        diffLines,\n    };\n};\nexports.computeLineInformation = computeLineInformation;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeHiddenBlocks = void 0;\nfunction computeHiddenBlocks(lineInformation, diffLines, extraLines) {\n    let newBlockIndex = 0;\n    let currentBlock;\n    let lineBlocks = {};\n    let blocks = [];\n    lineInformation.forEach((line, lineIndex) => {\n        const isDiffLine = diffLines.some(diffLine => diffLine >= lineIndex - extraLines && diffLine <= lineIndex + extraLines);\n        if (!isDiffLine && currentBlock == undefined) {\n            // block begins\n            currentBlock = {\n                index: newBlockIndex,\n                startLine: lineIndex,\n                endLine: lineIndex,\n                lines: 1\n            };\n            blocks.push(currentBlock);\n            lineBlocks[lineIndex] = currentBlock.index;\n            newBlockIndex++;\n        }\n        else if (!isDiffLine) {\n            // block continues\n            currentBlock.endLine = lineIndex;\n            currentBlock.lines++;\n            lineBlocks[lineIndex] = currentBlock.index;\n        }\n        else {\n            // not a block anymore\n            currentBlock = undefined;\n        }\n    });\n    return {\n        lineBlocks,\n        blocks: blocks\n    };\n}\nexports.computeHiddenBlocks = computeHiddenBlocks;\n", "var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var cache = null;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {\n            return cache.lastResult;\n        }\n        var lastResult = resultFn.apply(this, newArgs);\n        cache = {\n            lastResult: lastResult,\n            lastArgs: newArgs,\n            lastThis: this,\n        };\n        return lastResult;\n    }\n    memoized.clear = function clear() {\n        cache = null;\n    };\n    return memoized;\n}\n\nexport { memoizeOne as default };\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiffMethod = exports.LineNumberPrefix = void 0;\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst React = __importStar(require(\"react\"));\nconst classnames_1 = __importDefault(require(\"classnames\"));\nconst compute_lines_1 = require(\"./compute-lines\");\nObject.defineProperty(exports, \"DiffMethod\", { enumerable: true, get: function () { return compute_lines_1.DiffMethod; } });\nconst styles_1 = __importDefault(require(\"./styles\"));\nconst compute_hidden_blocks_1 = require(\"./compute-hidden-blocks\");\nconst m = require('memoize-one');\nconst memoize = m.default || m;\nvar LineNumberPrefix;\n(function (LineNumberPrefix) {\n    LineNumberPrefix[\"LEFT\"] = \"L\";\n    LineNumberPrefix[\"RIGHT\"] = \"R\";\n})(LineNumberPrefix || (exports.LineNumberPrefix = LineNumberPrefix = {}));\nclass DiffViewer extends React.Component {\n    constructor(props) {\n        super(props);\n        /**\n         * Resets code block expand to the initial stage. Will be exposed to the parent component via\n         * refs.\n         */\n        this.resetCodeBlocks = () => {\n            if (this.state.expandedBlocks.length > 0) {\n                this.setState({\n                    expandedBlocks: [],\n                });\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Pushes the target expanded code block to the state. During the re-render,\n         * this value is used to expand/fold unmodified code.\n         */\n        this.onBlockExpand = (id) => {\n            const prevState = this.state.expandedBlocks.slice();\n            prevState.push(id);\n            this.setState({\n                expandedBlocks: prevState,\n            });\n        };\n        /**\n         * Computes final styles for the diff viewer. It combines the default styles with the user\n         * supplied overrides. The computed styles are cached with performance in mind.\n         *\n         * @param styles User supplied style overrides.\n         */\n        this.computeStyles = memoize(styles_1.default);\n        /**\n         * Returns a function with clicked line number in the closure. Returns an no-op function when no\n         * onLineNumberClick handler is supplied.\n         *\n         * @param id Line id of a line.\n         */\n        this.onLineNumberClickProxy = (id) => {\n            if (this.props.onLineNumberClick) {\n                return (e) => this.props.onLineNumberClick(id, e);\n            }\n            return () => { };\n        };\n        /**\n         * Maps over the word diff and constructs the required React elements to show word diff.\n         *\n         * @param diffArray Word diff information derived from line information.\n         * @param renderer Optional renderer to format diff words. Useful for syntax highlighting.\n         */\n        this.renderWordDiff = (diffArray, renderer) => {\n            return diffArray.map((wordDiff, i) => {\n                return ((0, jsx_runtime_1.jsx)(\"span\", { className: (0, classnames_1.default)(this.styles.wordDiff, {\n                        [this.styles.wordAdded]: wordDiff.type === compute_lines_1.DiffType.ADDED,\n                        [this.styles.wordRemoved]: wordDiff.type === compute_lines_1.DiffType.REMOVED,\n                    }), children: renderer ? renderer(wordDiff.value) : wordDiff.value }, i));\n            });\n        };\n        /**\n         * Maps over the line diff and constructs the required react elements to show line diff. It calls\n         * renderWordDiff when encountering word diff. This takes care of both inline and split view line\n         * renders.\n         *\n         * @param lineNumber Line number of the current line.\n         * @param type Type of diff of the current line.\n         * @param prefix Unique id to prefix with the line numbers.\n         * @param value Content of the line. It can be a string or a word diff array.\n         * @param additionalLineNumber Additional line number to be shown. Useful for rendering inline\n         *  diff view. Right line number will be passed as additionalLineNumber.\n         * @param additionalPrefix Similar to prefix but for additional line number.\n         */\n        this.renderLine = (lineNumber, type, prefix, value, additionalLineNumber, additionalPrefix) => {\n            const lineNumberTemplate = `${prefix}-${lineNumber}`;\n            const additionalLineNumberTemplate = `${additionalPrefix}-${additionalLineNumber}`;\n            const highlightLine = this.props.highlightLines.includes(lineNumberTemplate) ||\n                this.props.highlightLines.includes(additionalLineNumberTemplate);\n            const added = type === compute_lines_1.DiffType.ADDED;\n            const removed = type === compute_lines_1.DiffType.REMOVED;\n            const changed = type === compute_lines_1.DiffType.CHANGED;\n            let content;\n            if (Array.isArray(value)) {\n                content = this.renderWordDiff(value, this.props.renderContent);\n            }\n            else if (this.props.renderContent) {\n                content = this.props.renderContent(value);\n            }\n            else {\n                content = value;\n            }\n            return ((0, jsx_runtime_1.jsxs)(React.Fragment, { children: [!this.props.hideLineNumbers && ((0, jsx_runtime_1.jsx)(\"td\", { onClick: lineNumber && this.onLineNumberClickProxy(lineNumberTemplate), className: (0, classnames_1.default)(this.styles.gutter, {\n                            [this.styles.emptyGutter]: !lineNumber,\n                            [this.styles.diffAdded]: added,\n                            [this.styles.diffRemoved]: removed,\n                            [this.styles.diffChanged]: changed,\n                            [this.styles.highlightedGutter]: highlightLine,\n                        }), children: (0, jsx_runtime_1.jsx)(\"pre\", { className: this.styles.lineNumber, children: lineNumber }) })), !this.props.splitView && !this.props.hideLineNumbers && ((0, jsx_runtime_1.jsx)(\"td\", { onClick: additionalLineNumber &&\n                            this.onLineNumberClickProxy(additionalLineNumberTemplate), className: (0, classnames_1.default)(this.styles.gutter, {\n                            [this.styles.emptyGutter]: !additionalLineNumber,\n                            [this.styles.diffAdded]: added,\n                            [this.styles.diffRemoved]: removed,\n                            [this.styles.diffChanged]: changed,\n                            [this.styles.highlightedGutter]: highlightLine,\n                        }), children: (0, jsx_runtime_1.jsx)(\"pre\", { className: this.styles.lineNumber, children: additionalLineNumber }) })), this.props.renderGutter\n                        ? this.props.renderGutter({\n                            lineNumber,\n                            type,\n                            prefix,\n                            value,\n                            additionalLineNumber,\n                            additionalPrefix,\n                            styles: this.styles,\n                        })\n                        : null, !this.props.hideMarkers && ((0, jsx_runtime_1.jsx)(\"td\", { className: (0, classnames_1.default)(this.styles.marker, {\n                            [this.styles.emptyLine]: !content,\n                            [this.styles.diffAdded]: added,\n                            [this.styles.diffRemoved]: removed,\n                            [this.styles.diffChanged]: changed,\n                            [this.styles.highlightedLine]: highlightLine,\n                        }), children: (0, jsx_runtime_1.jsxs)(\"pre\", { children: [added && '+', removed && '-'] }) })), (0, jsx_runtime_1.jsx)(\"td\", { className: (0, classnames_1.default)(this.styles.content, {\n                            [this.styles.emptyLine]: !content,\n                            [this.styles.diffAdded]: added,\n                            [this.styles.diffRemoved]: removed,\n                            [this.styles.diffChanged]: changed,\n                            [this.styles.highlightedLine]: highlightLine,\n                        }), children: (0, jsx_runtime_1.jsx)(\"pre\", { className: this.styles.contentText, children: content }) })] }));\n        };\n        /**\n         * Generates lines for split view.\n         *\n         * @param obj Line diff information.\n         * @param obj.left Life diff information for the left pane of the split view.\n         * @param obj.right Life diff information for the right pane of the split view.\n         * @param index React key for the lines.\n         */\n        this.renderSplitView = ({ left, right }, index) => {\n            return ((0, jsx_runtime_1.jsxs)(\"tr\", { className: this.styles.line, children: [this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value), this.renderLine(right.lineNumber, right.type, LineNumberPrefix.RIGHT, right.value)] }, index));\n        };\n        /**\n         * Generates lines for inline view.\n         *\n         * @param obj Line diff information.\n         * @param obj.left Life diff information for the added section of the inline view.\n         * @param obj.right Life diff information for the removed section of the inline view.\n         * @param index React key for the lines.\n         */\n        this.renderInlineView = ({ left, right }, index) => {\n            let content;\n            if (left.type === compute_lines_1.DiffType.REMOVED && right.type === compute_lines_1.DiffType.ADDED) {\n                return ((0, jsx_runtime_1.jsxs)(React.Fragment, { children: [(0, jsx_runtime_1.jsx)(\"tr\", { className: this.styles.line, children: this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, null) }), (0, jsx_runtime_1.jsx)(\"tr\", { className: this.styles.line, children: this.renderLine(null, right.type, LineNumberPrefix.RIGHT, right.value, right.lineNumber) })] }, index));\n            }\n            if (left.type === compute_lines_1.DiffType.REMOVED) {\n                content = this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, null);\n            }\n            if (left.type === compute_lines_1.DiffType.DEFAULT) {\n                content = this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, right.lineNumber, LineNumberPrefix.RIGHT);\n            }\n            if (right.type === compute_lines_1.DiffType.ADDED) {\n                content = this.renderLine(null, right.type, LineNumberPrefix.RIGHT, right.value, right.lineNumber);\n            }\n            return ((0, jsx_runtime_1.jsx)(\"tr\", { className: this.styles.line, children: content }, index));\n        };\n        /**\n         * Returns a function with clicked block number in the closure.\n         *\n         * @param id Cold fold block id.\n         */\n        this.onBlockClickProxy = (id) => () => this.onBlockExpand(id);\n        /**\n         * Generates cold fold block. It also uses the custom message renderer when available to show\n         * cold fold messages.\n         *\n         * @param num Number of skipped lines between two blocks.\n         * @param blockNumber Code fold block id.\n         * @param leftBlockLineNumber First left line number after the current code fold block.\n         * @param rightBlockLineNumber First right line number after the current code fold block.\n         */\n        this.renderSkippedLineIndicator = (num, blockNumber, leftBlockLineNumber, rightBlockLineNumber) => {\n            const { hideLineNumbers, splitView } = this.props;\n            const message = this.props.codeFoldMessageRenderer ? (this.props.codeFoldMessageRenderer(num, leftBlockLineNumber, rightBlockLineNumber)) : ((0, jsx_runtime_1.jsxs)(\"pre\", { className: this.styles.codeFoldContent, children: [\"Expand \", num, \" lines ...\"] }));\n            const content = ((0, jsx_runtime_1.jsx)(\"td\", { children: (0, jsx_runtime_1.jsx)(\"a\", { onClick: this.onBlockClickProxy(blockNumber), tabIndex: 0, children: message }) }));\n            const isUnifiedViewWithoutLineNumbers = !splitView && !hideLineNumbers;\n            return ((0, jsx_runtime_1.jsxs)(\"tr\", { className: this.styles.codeFold, children: [!hideLineNumbers && (0, jsx_runtime_1.jsx)(\"td\", { className: this.styles.codeFoldGutter }), this.props.renderGutter ? ((0, jsx_runtime_1.jsx)(\"td\", { className: this.styles.codeFoldGutter })) : null, (0, jsx_runtime_1.jsx)(\"td\", { className: (0, classnames_1.default)({\n                            [this.styles.codeFoldGutter]: isUnifiedViewWithoutLineNumbers,\n                        }) }), isUnifiedViewWithoutLineNumbers ? ((0, jsx_runtime_1.jsxs)(React.Fragment, { children: [(0, jsx_runtime_1.jsx)(\"td\", {}), content] })) : ((0, jsx_runtime_1.jsxs)(React.Fragment, { children: [content, this.props.renderGutter ? (0, jsx_runtime_1.jsx)(\"td\", {}) : null, (0, jsx_runtime_1.jsx)(\"td\", {})] })), (0, jsx_runtime_1.jsx)(\"td\", {}), (0, jsx_runtime_1.jsx)(\"td\", {})] }, `${leftBlockLineNumber}-${rightBlockLineNumber}`));\n        };\n        /**\n         * Generates the entire diff view.\n         */\n        this.renderDiff = () => {\n            const { oldValue, newValue, splitView, disableWordDiff, compareMethod, linesOffset, } = this.props;\n            const { lineInformation, diffLines } = (0, compute_lines_1.computeLineInformation)(oldValue, newValue, disableWordDiff, compareMethod, linesOffset, this.props.alwaysShowLines);\n            const extraLines = this.props.extraLinesSurroundingDiff < 0\n                ? 0\n                : Math.round(this.props.extraLinesSurroundingDiff);\n            const { lineBlocks, blocks } = (0, compute_hidden_blocks_1.computeHiddenBlocks)(lineInformation, diffLines, extraLines);\n            return lineInformation.map((line, lineIndex) => {\n                if (this.props.showDiffOnly) {\n                    const blockIndex = lineBlocks[lineIndex];\n                    if (blockIndex !== undefined) {\n                        const lastLineOfBlock = blocks[blockIndex].endLine === lineIndex;\n                        if (!this.state.expandedBlocks.includes(blockIndex) && lastLineOfBlock) {\n                            return ((0, jsx_runtime_1.jsx)(React.Fragment, { children: this.renderSkippedLineIndicator(blocks[blockIndex].lines, blockIndex, line.left.lineNumber, line.right.lineNumber) }, lineIndex));\n                        }\n                        else if (!this.state.expandedBlocks.includes(blockIndex)) {\n                            return null;\n                        }\n                    }\n                }\n                const diffNodes = splitView\n                    ? this.renderSplitView(line, lineIndex)\n                    : this.renderInlineView(line, lineIndex);\n                return diffNodes;\n            });\n        };\n        this.render = () => {\n            const { oldValue, newValue, useDarkTheme, leftTitle, rightTitle, splitView, hideLineNumbers, hideMarkers, nonce, } = this.props;\n            if (this.props.compareMethod !== compute_lines_1.DiffMethod.JSON) {\n                if (typeof oldValue !== 'string' || typeof newValue !== 'string') {\n                    throw Error('\"oldValue\" and \"newValue\" should be strings');\n                }\n            }\n            this.styles = this.computeStyles(this.props.styles, useDarkTheme, nonce);\n            const nodes = this.renderDiff();\n            let colSpanOnSplitView = hideLineNumbers ? 2 : 3;\n            let colSpanOnInlineView = hideLineNumbers ? 2 : 4;\n            if (hideMarkers) {\n                colSpanOnSplitView -= 1;\n                colSpanOnInlineView -= 1;\n            }\n            const columnExtension = this.props.renderGutter ? 1 : 0;\n            const title = (leftTitle || rightTitle) && ((0, jsx_runtime_1.jsxs)(\"tr\", { children: [(0, jsx_runtime_1.jsx)(\"td\", { colSpan: (splitView ? colSpanOnSplitView : colSpanOnInlineView) +\n                            columnExtension, className: this.styles.titleBlock, children: (0, jsx_runtime_1.jsx)(\"pre\", { className: this.styles.contentText, children: leftTitle }) }), splitView && ((0, jsx_runtime_1.jsx)(\"td\", { colSpan: colSpanOnSplitView + columnExtension, className: this.styles.titleBlock, children: (0, jsx_runtime_1.jsx)(\"pre\", { className: this.styles.contentText, children: rightTitle }) }))] }));\n            return ((0, jsx_runtime_1.jsx)(\"table\", { className: (0, classnames_1.default)(this.styles.diffContainer, {\n                    [this.styles.splitView]: splitView,\n                }), children: (0, jsx_runtime_1.jsxs)(\"tbody\", { children: [title, nodes] }) }));\n        };\n        this.state = {\n            expandedBlocks: [],\n        };\n    }\n}\nDiffViewer.defaultProps = {\n    oldValue: '',\n    newValue: '',\n    splitView: true,\n    highlightLines: [],\n    disableWordDiff: false,\n    compareMethod: compute_lines_1.DiffMethod.CHARS,\n    styles: {},\n    hideLineNumbers: false,\n    hideMarkers: false,\n    extraLinesSurroundingDiff: 3,\n    showDiffOnly: true,\n    useDarkTheme: false,\n    linesOffset: 0,\n    nonce: '',\n};\nexports.default = DiffViewer;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAOA,KAAC,WAAY;AACZ;AAEA,UAAI,SAAS,CAAC,EAAE;AAEhB,eAAS,aAAc;AACtB,YAAI,UAAU;AAEd,iBAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AAC1C,cAAI,MAAM,UAAU,CAAC;AACrB,cAAI,KAAK;AACR,sBAAU,YAAY,SAAS,WAAW,GAAG,CAAC;AAAA,UAC/C;AAAA,QACD;AAEA,eAAO;AAAA,MACR;AAEA,eAAS,WAAY,KAAK;AACzB,YAAI,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAU;AACvD,iBAAO;AAAA,QACR;AAEA,YAAI,OAAO,QAAQ,UAAU;AAC5B,iBAAO;AAAA,QACR;AAEA,YAAI,MAAM,QAAQ,GAAG,GAAG;AACvB,iBAAO,WAAW,MAAM,MAAM,GAAG;AAAA,QAClC;AAEA,YAAI,IAAI,aAAa,OAAO,UAAU,YAAY,CAAC,IAAI,SAAS,SAAS,EAAE,SAAS,eAAe,GAAG;AACrG,iBAAO,IAAI,SAAS;AAAA,QACrB;AAEA,YAAI,UAAU;AAEd,iBAAS,OAAO,KAAK;AACpB,cAAI,OAAO,KAAK,KAAK,GAAG,KAAK,IAAI,GAAG,GAAG;AACtC,sBAAU,YAAY,SAAS,GAAG;AAAA,UACnC;AAAA,QACD;AAEA,eAAO;AAAA,MACR;AAEA,eAAS,YAAa,OAAO,UAAU;AACtC,YAAI,CAAC,UAAU;AACd,iBAAO;AAAA,QACR;AAEA,YAAI,OAAO;AACV,iBAAO,QAAQ,MAAM;AAAA,QACtB;AAEA,eAAO,QAAQ;AAAA,MAChB;AAEA,UAAI,OAAO,WAAW,eAAe,OAAO,SAAS;AACpD,mBAAW,UAAU;AACrB,eAAO,UAAU;AAAA,MAClB,WAAW,OAAO,WAAW,cAAc,OAAO,OAAO,QAAQ,YAAY,OAAO,KAAK;AAExF,eAAO,cAAc,CAAC,GAAG,WAAY;AACpC,iBAAO;AAAA,QACR,CAAC;AAAA,MACF,OAAO;AACN,eAAO,aAAa;AAAA,MACrB;AAAA,IACD,GAAE;AAAA;AAAA;;;;;;;;;;AC5Ea,aAASA,OAAO;IAAE;AAEjCA,SAAKC,YAAY;;;MACfC,MADe,SAAA,KACVC,WAAWC,WAAyB;AAAA,YAAA;AAAA,YAAdC,UAAc,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAAJ,CAAA;AACnC,YAAIC,WAAWD,QAAQC;AACvB,YAAI,OAAOD,YAAY,YAAY;AACjCC,qBAAWD;AACXA,oBAAU,CAAA;QACX;AACD,aAAKA,UAAUA;AAEf,YAAIE,OAAO;AAEX,iBAASC,KAAKC,OAAO;AACnB,cAAIH,UAAU;AACZI,uBAAW,WAAW;AAAEJ,uBAASK,QAAWF,KAAZ;YAAqB,GAAE,CAA7C;AACV,mBAAO;UACR,OAAM;AACL,mBAAOA;UACR;QACF;AAGDN,oBAAY,KAAKS,UAAUT,SAAf;AACZC,oBAAY,KAAKQ,UAAUR,SAAf;AAEZD,oBAAY,KAAKU,YAAY,KAAKC,SAASX,SAAd,CAAjB;AACZC,oBAAY,KAAKS,YAAY,KAAKC,SAASV,SAAd,CAAjB;AAEZ,YAAIW,SAASX,UAAUY,QAAQC,SAASd,UAAUa;AAClD,YAAIE,aAAa;AACjB,YAAIC,gBAAgBJ,SAASE;AAC7B,YAAGZ,QAAQc,eAAe;AACxBA,0BAAgBC,KAAKC,IAAIF,eAAed,QAAQc,aAAhC;QACjB;AACD,YAAMG;;WAAgB;UAAGjB,QAAQkB,aAAX,QAAA,qBAAA,SAAA,mBAAsBC;;AAC5C,YAAMC,sBAAsBC,KAAKC,IAAL,IAAaL;AAEzC,YAAIM,WAAW,CAAC;UAAEC,QAAQ;UAAIC,eAAenB;QAA7B,CAAD;AAGf,YAAIoB,SAAS,KAAKC,cAAcJ,SAAS,CAAD,GAAKxB,WAAWD,WAAW,CAAtD;AACb,YAAIyB,SAAS,CAAD,EAAIC,SAAS,KAAKZ,UAAUc,SAAS,KAAKhB,QAAQ;AAE5D,iBAAOP,KAAK,CAAC;YAACC,OAAO,KAAKwB,KAAK7B,SAAV;YAAsB8B,OAAO9B,UAAUY;UAA/C,CAAD,CAAD;QACZ;AAmBD,YAAImB,wBAAwB,WAAWC,wBAAwBZ;AAG/D,iBAASa,iBAAiB;AACxB,mBACMC,eAAelB,KAAKmB,IAAIJ,uBAAuB,CAACjB,UAAjC,GACnBoB,gBAAgBlB,KAAKC,IAAIe,uBAAuBlB,UAAhC,GAChBoB,gBAAgB,GAChB;AACA,gBAAIE;;cAAQ;;AACZ,gBAAIC,aAAab,SAASU,eAAe,CAAhB,GACrBI,UAAUd,SAASU,eAAe,CAAhB;AACtB,gBAAIG,YAAY;AAEdb,uBAASU,eAAe,CAAhB,IAAqB3B;YAC9B;AAED,gBAAIgC,SAAS;AACb,gBAAID,SAAS;AAEX,kBAAME,gBAAgBF,QAAQb,SAASS;AACvCK,uBAASD,WAAW,KAAKE,iBAAiBA,gBAAgB7B;YAC3D;AAED,gBAAI8B,YAAYJ,cAAcA,WAAWZ,SAAS,IAAIZ;AACtD,gBAAI,CAAC0B,UAAU,CAACE,WAAW;AAEzBjB,uBAASU,YAAD,IAAiB3B;AACzB;YACD;AAOD,gBAAI,CAACkC,aAAcF,UAAUF,WAAWZ,SAAS,IAAIa,QAAQb,QAAS;AACpEW,yBAAWjC,KAAKuC,UAAUJ,SAAS,MAAM/B,QAAW,CAAzC;YACZ,OAAM;AACL6B,yBAAWjC,KAAKuC,UAAUL,YAAY9B,QAAW,MAAM,CAA5C;YACZ;AAEDoB,qBAASxB,KAAKyB,cAAcQ,UAAUpC,WAAWD,WAAWmC,YAAnD;AAET,gBAAIE,SAASX,SAAS,KAAKZ,UAAUc,SAAS,KAAKhB,QAAQ;AAEzD,qBAAOP,KAAKuC,YAAYxC,MAAMiC,SAASV,eAAe1B,WAAWD,WAAWI,KAAKyC,eAA1D,CAAZ;YACZ,OAAM;AACLpB,uBAASU,YAAD,IAAiBE;AACzB,kBAAIA,SAASX,SAAS,KAAKZ,QAAQ;AACjCmB,wCAAwBhB,KAAKC,IAAIe,uBAAuBE,eAAe,CAA/C;cACzB;AACD,kBAAIP,SAAS,KAAKhB,QAAQ;AACxBoB,wCAAwBf,KAAKmB,IAAIJ,uBAAuBG,eAAe,CAA/C;cACzB;YACF;UACF;AAEDpB;QACD;AAMD,YAAIZ,UAAU;AACX,WAAA,SAAS2C,OAAO;AACfvC,uBAAW,WAAW;AACpB,kBAAIQ,aAAaC,iBAAiBO,KAAKC,IAAL,IAAaF,qBAAqB;AAClE,uBAAOnB,SAAQ;cAChB;AAED,kBAAI,CAAC+B,eAAc,GAAI;AACrBY,qBAAI;cACL;YACF,GAAE,CARO;UASX,GAVA;QAWF,OAAM;AACL,iBAAO/B,cAAcC,iBAAiBO,KAAKC,IAAL,KAAcF,qBAAqB;AACvE,gBAAIyB,MAAMb,eAAc;AACxB,gBAAIa,KAAK;AACP,qBAAOA;YACR;UACF;QACF;MACF;;;MAEDJ,WArJe,SAAA,UAqJLK,MAAMC,OAAOC,SAASC,WAAW;AACzC,YAAIC,OAAOJ,KAAKrB;AAChB,YAAIyB,QAAQA,KAAKH,UAAUA,SAASG,KAAKF,YAAYA,SAAS;AAC5D,iBAAO;YACLxB,QAAQsB,KAAKtB,SAASyB;YACtBxB,eAAe;cAACI,OAAOqB,KAAKrB,QAAQ;cAAGkB;cAAcC;cAAkBG,mBAAmBD,KAAKC;YAAhF;UAFV;QAIR,OAAM;AACL,iBAAO;YACL3B,QAAQsB,KAAKtB,SAASyB;YACtBxB,eAAe;cAACI,OAAO;cAAGkB;cAAcC;cAAkBG,mBAAmBD;YAA9D;UAFV;QAIR;MACF;;;MACDvB,eAnKe,SAAA,cAmKDQ,UAAUpC,WAAWD,WAAWmC,cAAc;AAC1D,YAAIvB,SAASX,UAAUY,QACnBC,SAASd,UAAUa,QACnBa,SAASW,SAASX,QAClBE,SAASF,SAASS,cAElBmB,cAAc;AAClB,eAAO1B,SAAS,IAAIhB,UAAUc,SAAS,IAAIZ,UAAU,KAAKyC,OAAOtD,UAAU2B,SAAS,CAAV,GAAc5B,UAAU0B,SAAS,CAAV,CAA5C,GAA2D;AAC9GE;AACAF;AACA4B;QACD;AAED,YAAIA,aAAa;AACfjB,mBAASV,gBAAgB;YAACI,OAAOuB;YAAaD,mBAAmBhB,SAASV;UAAjD;QAC1B;AAEDU,iBAASX,SAASA;AAClB,eAAOE;MACR;;;MAED2B,QAxLe,SAAA,OAwLRC,MAAMC,OAAO;AAClB,YAAI,KAAKvD,QAAQwD,YAAY;AAC3B,iBAAO,KAAKxD,QAAQwD,WAAWF,MAAMC,KAA9B;QACR,OAAM;AACL,iBAAOD,SAASC,SACV,KAAKvD,QAAQyD,cAAcH,KAAKI,YAAL,MAAuBH,MAAMG,YAAN;QACzD;MACF;;;MACDlD,aAhMe,SAAA,YAgMHmD,OAAO;AACjB,YAAId,MAAM,CAAA;AACV,iBAASe,IAAI,GAAGA,IAAID,MAAMhD,QAAQiD,KAAK;AACrC,cAAID,MAAMC,CAAD,GAAK;AACZf,gBAAIgB,KAAKF,MAAMC,CAAD,CAAd;UACD;QACF;AACD,eAAOf;MACR;;;MACDtC,WAzMe,SAAA,UAyMLH,OAAO;AACf,eAAOA;MACR;;;MACDK,UA5Me,SAAA,SA4MNL,OAAO;AACd,eAAOA,MAAM0D,MAAM,EAAZ;MACR;;;MACDlC,MA/Me,SAAA,KA+MVmC,OAAO;AACV,eAAOA,MAAMnC,KAAK,EAAX;MACR;IAjNc;AAoNjB,aAASc,YAAY7C,MAAM4B,eAAe1B,WAAWD,WAAW6C,iBAAiB;AAG/E,UAAMqB,aAAa,CAAA;AACnB,UAAIC;AACJ,aAAOxC,eAAe;AACpBuC,mBAAWH,KAAKpC,aAAhB;AACAwC,wBAAgBxC,cAAc0B;AAC9B,eAAO1B,cAAc0B;AACrB1B,wBAAgBwC;MACjB;AACDD,iBAAWE,QAAX;AAEA,UAAIC,eAAe,GACfC,eAAeJ,WAAWrD,QAC1Be,SAAS,GACTF,SAAS;AAEb,aAAO2C,eAAeC,cAAcD,gBAAgB;AAClD,YAAIE,YAAYL,WAAWG,YAAD;AAC1B,YAAI,CAACE,UAAUrB,SAAS;AACtB,cAAI,CAACqB,UAAUtB,SAASJ,iBAAiB;AACvC,gBAAIvC,QAAQL,UAAUuE,MAAM5C,QAAQA,SAAS2C,UAAUxC,KAA3C;AACZzB,oBAAQA,MAAMmE,IAAI,SAASnE,QAAOwD,GAAG;AACnC,kBAAIY,WAAW1E,UAAU0B,SAASoC,CAAV;AACxB,qBAAOY,SAAS7D,SAASP,OAAMO,SAAS6D,WAAWpE;YACpD,CAHO;AAKRiE,sBAAUjE,QAAQP,KAAK+B,KAAKxB,KAAV;UACnB,OAAM;AACLiE,sBAAUjE,QAAQP,KAAK+B,KAAK7B,UAAUuE,MAAM5C,QAAQA,SAAS2C,UAAUxC,KAA3C,CAAV;UACnB;AACDH,oBAAU2C,UAAUxC;AAGpB,cAAI,CAACwC,UAAUtB,OAAO;AACpBvB,sBAAU6C,UAAUxC;UACrB;QACF,OAAM;AACLwC,oBAAUjE,QAAQP,KAAK+B,KAAK9B,UAAUwE,MAAM9C,QAAQA,SAAS6C,UAAUxC,KAA3C,CAAV;AAClBL,oBAAU6C,UAAUxC;AAKpB,cAAIsC,gBAAgBH,WAAWG,eAAe,CAAhB,EAAmBpB,OAAO;AACtD,gBAAI0B,MAAMT,WAAWG,eAAe,CAAhB;AACpBH,uBAAWG,eAAe,CAAhB,IAAqBH,WAAWG,YAAD;AACzCH,uBAAWG,YAAD,IAAiBM;UAC5B;QACF;MACF;AAKD,UAAIC,iBAAiBV,WAAWI,eAAe,CAAhB;AAC/B,UAAIA,eAAe,KACZ,OAAOM,eAAetE,UAAU,aAC/BsE,eAAe3B,SAAS2B,eAAe1B,YACxCnD,KAAKwD,OAAO,IAAIqB,eAAetE,KAA/B,GAAuC;AAC5C4D,mBAAWI,eAAe,CAAhB,EAAmBhE,SAASsE,eAAetE;AACrD4D,mBAAWW,IAAX;MACD;AAED,aAAOX;IACR;;;;;;;;;;;;;ACxRD,QAAA,QAAA,uBAAA,cAAA;;;;AAEO,QAAMY,gBAAgB;IAAIC;;MAAAA;;IAAAA,EAAJ;;AACtB,aAASC,UAAUC,QAAQC,QAAQC,SAAS;AAAE,aAAOL,cAAcM,KAAKH,QAAQC,QAAQC,OAAnC;IAA8C;;;;;;;;;;;;ACHnG,aAASE,gBAAgBC,SAASC,UAAU;AACjD,UAAI,OAAOD,YAAY,YAAY;AACjCC,iBAASC,WAAWF;MACrB,WAAUA,SAAS;AAClB,iBAASG,QAAQH,SAAS;AAExB,cAAIA,QAAQI,eAAeD,IAAvB,GAA8B;AAChCF,qBAASE,IAAD,IAASH,QAAQG,IAAD;UACzB;QACF;MACF;AACD,aAAOF;IACR;;;;;;;;;;;;;;ACZD,QAAA,QAAA,uBAAA,cAAA;AACA,QAAA,UAAA;;;;AAoBA,QAAMI,oBAAoB;AAE1B,QAAMC,eAAe;AAEd,QAAMC,WAAW;IAAIC;;MAAAA;;IAAAA,EAAJ;;AACxBD,aAASE,SAAS,SAASC,MAAMC,OAAO;AACtC,UAAI,KAAKC,QAAQC,YAAY;AAC3BH,eAAOA,KAAKI,YAAL;AACPH,gBAAQA,MAAMG,YAAN;MACT;AACD,aAAOJ,SAASC,SAAU,KAAKC,QAAQG,oBAAoB,CAACT,aAAaU,KAAKN,IAAlB,KAA2B,CAACJ,aAAaU,KAAKL,KAAlB;IACzF;AACDJ,aAASU,WAAW,SAASC,OAAO;AAElC,UAAIC,SAASD,MAAME,MAAM,iCAAZ;AAGb,eAASC,IAAI,GAAGA,IAAIF,OAAOG,SAAS,GAAGD,KAAK;AAE1C,YAAI,CAACF,OAAOE,IAAI,CAAL,KAAWF,OAAOE,IAAI,CAAL,KACnBhB,kBAAkBW,KAAKG,OAAOE,CAAD,CAA7B,KACAhB,kBAAkBW,KAAKG,OAAOE,IAAI,CAAL,CAA7B,GAAuC;AAC9CF,iBAAOE,CAAD,KAAOF,OAAOE,IAAI,CAAL;AACnBF,iBAAOI,OAAOF,IAAI,GAAG,CAArB;AACAA;QACD;MACF;AAED,aAAOF;IACR;AAEM,aAASK,UAAUC,QAAQC,QAAQd,SAAS;AACjDA;OAAU;;MAAAe,QAAAA,iBAAgBf,SAAS;QAACG,kBAAkB;MAAnB,CAAzB;AACV,aAAOR,SAASqB,KAAKH,QAAQC,QAAQd,OAA9B;IACR;AAEM,aAASiB,mBAAmBJ,QAAQC,QAAQd,SAAS;AAC1D,aAAOL,SAASqB,KAAKH,QAAQC,QAAQd,OAA9B;IACR;;;;;;;;;;;;;;AC3DD,QAAA,QAAA,uBAAA,cAAA;AACA,QAAA,UAAA;;;;AAEO,QAAMkB,WAAW;IAAIC;;MAAAA;;IAAAA,EAAJ;;AACxBD,aAASE,WAAW,SAASC,OAAO;AAClC,UAAG,KAAKC,QAAQC,iBAAiB;AAE/BF,gBAAQA,MAAMG,QAAQ,SAAS,IAAvB;MACT;AAED,UAAIC,WAAW,CAAA,GACXC,mBAAmBL,MAAMM,MAAM,WAAZ;AAGvB,UAAI,CAACD,iBAAiBA,iBAAiBE,SAAS,CAA3B,GAA+B;AAClDF,yBAAiBG,IAAjB;MACD;AAGD,eAASC,IAAI,GAAGA,IAAIJ,iBAAiBE,QAAQE,KAAK;AAChD,YAAIC,OAAOL,iBAAiBI,CAAD;AAE3B,YAAIA,IAAI,KAAK,CAAC,KAAKR,QAAQU,gBAAgB;AACzCP,mBAASA,SAASG,SAAS,CAAnB,KAAyBG;QAClC,OAAM;AACL,cAAI,KAAKT,QAAQW,kBAAkB;AACjCF,mBAAOA,KAAKG,KAAL;UACR;AACDT,mBAASU,KAAKJ,IAAd;QACD;MACF;AAED,aAAON;IACR;AAEM,aAASW,UAAUC,QAAQC,QAAQC,UAAU;AAAE,aAAOrB,SAASsB,KAAKH,QAAQC,QAAQC,QAA9B;IAA0C;AAChG,aAASE,iBAAiBJ,QAAQC,QAAQC,UAAU;AACzD,UAAIjB;;SAAU;;QAAAoB,QAAAA,iBAAgBH,UAAU;UAACN,kBAAkB;QAAnB,CAA1B;;AACd,aAAOf,SAASsB,KAAKH,QAAQC,QAAQhB,OAA9B;IACR;;;;;;;;;;;;;ACvCD,QAAA,QAAA,uBAAA,cAAA;;;;AAGO,QAAMqB,eAAe;IAAIC;;MAAAA;;IAAAA,EAAJ;;AAC5BD,iBAAaE,WAAW,SAASC,OAAO;AACtC,aAAOA,MAAMC,MAAM,uBAAZ;IACR;AAEM,aAASC,cAAcC,QAAQC,QAAQC,UAAU;AAAE,aAAOR,aAAaS,KAAKH,QAAQC,QAAQC,QAAlC;IAA8C;;;;;;;;;;;;;ACR/G,QAAA,QAAA,uBAAA,cAAA;;;;AAEO,QAAME,UAAU;IAAIC;;MAAAA;;IAAAA,EAAJ;;AACvBD,YAAQE,WAAW,SAASC,OAAO;AACjC,aAAOA,MAAMC,MAAM,eAAZ;IACR;AAEM,aAASC,QAAQC,QAAQC,QAAQC,UAAU;AAAE,aAAOR,QAAQS,KAAKH,QAAQC,QAAQC,QAA7B;IAAyC;;;;;;;;;;;;;;ACPpG,QAAA,QAAA,uBAAA,cAAA;AACA,QAAA,QAAA;;;;;;;;;;;;;;;;;AAEA,QAAME,0BAA0BC,OAAOC,UAAUC;AAG1C,QAAMC,WAAW;IAAIC;;MAAAA;;IAAAA,EAAJ;;AAGxBD,aAASE,kBAAkB;AAE3BF,aAASG;IAAWC,MAAAA,SAASD;AAC7BH,aAASK,YAAY,SAASC,OAAO;AAAA,UAAA;;QAC+E,KAAKC;SAAhHC,uBAD4B,cAC5BA,sBAD4B,wBAAA,cACNC,mBAAAA,oBADM,0BAAA,SACc,SAACC,GAAGC,GAAJ;AAAA;;UAAU,OAAOA,MAAM,cAAcH,uBAAuBG;;MAA5D,IADd;AAGnC,aAAO,OAAOL,UAAU,WAAWA,QAAQM,KAAKC,UAAUC,aAAaR,OAAO,MAAM,MAAMG,iBAApB,GAAwCA,mBAAmB,IAAtF;IAC5C;AACDT,aAASe,SAAS,SAASC,MAAMC,OAAO;AACtC;;QAAOhB;;UAAAA;;QAAAA,EAAKH,UAAUiB,OAAOG,KAAKlB,UAAUgB,KAAKG,QAAQ,cAAc,IAA3B,GAAkCF,MAAME,QAAQ,cAAc,IAA5B,CAAvE;;IACR;AAEM,aAASC,SAASC,QAAQC,QAAQf,SAAS;AAAE,aAAOP,SAASuB,KAAKF,QAAQC,QAAQf,OAA9B;IAAyC;AAI7F,aAASO,aAAaU,KAAKC,OAAOC,kBAAkBC,UAAUC,KAAK;AACxEH,cAAQA,SAAS,CAAA;AACjBC,yBAAmBA,oBAAoB,CAAA;AAEvC,UAAIC,UAAU;AACZH,cAAMG,SAASC,KAAKJ,GAAN;MACf;AAED,UAAIK;AAEJ,WAAKA,IAAI,GAAGA,IAAIJ,MAAMK,QAAQD,KAAK,GAAG;AACpC,YAAIJ,MAAMI,CAAD,MAAQL,KAAK;AACpB,iBAAOE,iBAAiBG,CAAD;QACxB;MACF;AAED,UAAIE;AAEJ,UAAI,qBAAqBnC,wBAAwBsB,KAAKM,GAA7B,GAAmC;AAC1DC,cAAMO,KAAKR,GAAX;AACAO,2BAAmB,IAAIE,MAAMT,IAAIM,MAAd;AACnBJ,yBAAiBM,KAAKD,gBAAtB;AACA,aAAKF,IAAI,GAAGA,IAAIL,IAAIM,QAAQD,KAAK,GAAG;AAClCE,2BAAiBF,CAAD,IAAMf,aAAaU,IAAIK,CAAD,GAAKJ,OAAOC,kBAAkBC,UAAUC,GAA5C;QACnC;AACDH,cAAMS,IAAN;AACAR,yBAAiBQ,IAAjB;AACA,eAAOH;MACR;AAED,UAAIP,OAAOA,IAAIW,QAAQ;AACrBX,cAAMA,IAAIW,OAAJ;MACP;AAED;;QAAI;;UAAOX;QAAP,MAAe,YAAYA,QAAQ;QAAM;AAC3CC,cAAMO,KAAKR,GAAX;AACAO,2BAAmB,CAAA;AACnBL,yBAAiBM,KAAKD,gBAAtB;AACA,YAAIK,aAAa,CAAA,GACbR;AACJ,aAAKA,QAAOJ,KAAK;AAEf,cAAIA,IAAIa,eAAeT,IAAnB,GAAyB;AAC3BQ,uBAAWJ,KAAKJ,IAAhB;UACD;QACF;AACDQ,mBAAWE,KAAX;AACA,aAAKT,IAAI,GAAGA,IAAIO,WAAWN,QAAQD,KAAK,GAAG;AACzCD,iBAAMQ,WAAWP,CAAD;AAChBE,2BAAiBH,IAAD,IAAQd,aAAaU,IAAII,IAAD,GAAOH,OAAOC,kBAAkBC,UAAUC,IAA9C;QACrC;AACDH,cAAMS,IAAN;AACAR,yBAAiBQ,IAAjB;MACD,OAAM;AACLH,2BAAmBP;MACpB;AACD,aAAOO;IACR;;;;;;;;;;;;;AClFD,QAAA,QAAA,uBAAA,cAAA;;;;AAEO,QAAMQ,YAAY;IAAIC;;MAAAA;;IAAAA,EAAJ;;AACzBD,cAAUE,WAAW,SAASC,OAAO;AACnC,aAAOA,MAAMC,MAAN;IACR;AACDJ,cAAUK,OAAOL,UAAUM,cAAc,SAASH,OAAO;AACvD,aAAOA;IACR;AAEM,aAASI,WAAWC,QAAQC,QAAQC,UAAU;AAAE,aAAOV,UAAUW,KAAKH,QAAQC,QAAQC,QAA/B;IAA2C;;;;;;;;;;;;ACVlG,aAASE,WAAWC,SAAuB;AAAA,UAAdC,UAAc,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAAJ,CAAA;AAC5C,UAAIC,UAAUF,QAAQG,MAAM,qBAAd,GACVC,aAAaJ,QAAQK,MAAM,sBAAd,KAAyC,CAAA,GACtDC,OAAO,CAAA,GACPC,IAAI;AAER,eAASC,aAAa;AACpB,YAAIC,QAAQ,CAAA;AACZH,aAAKI,KAAKD,KAAV;AAGA,eAAOF,IAAIL,QAAQS,QAAQ;AACzB,cAAIC,OAAOV,QAAQK,CAAD;AAGlB,cAAK,wBAAyBM,KAAKD,IAA/B,GAAsC;AACxC;UACD;AAGD,cAAIE,SAAU,2CAA4CC,KAAKH,IAAlD;AACb,cAAIE,QAAQ;AACVL,kBAAMA,QAAQK,OAAO,CAAD;UACrB;AAEDP;QACD;AAIDS,wBAAgBP,KAAD;AACfO,wBAAgBP,KAAD;AAGfA,cAAMQ,QAAQ,CAAA;AAEd,eAAOV,IAAIL,QAAQS,QAAQ;AACzB,cAAIC,QAAOV,QAAQK,CAAD;AAElB,cAAK,iCAAkCM,KAAKD,KAAxC,GAA+C;AACjD;UACD,WAAW,MAAOC,KAAKD,KAAb,GAAoB;AAC7BH,kBAAMQ,MAAMP,KAAKQ,UAAS,CAA1B;UACD,WAAUN,SAAQX,QAAQkB,QAAQ;AAEjC,kBAAM,IAAIC,MAAM,mBAAmBb,IAAI,KAAK,MAAMc,KAAKC,UAAUV,KAAf,CAA5C;UACP,OAAM;AACLL;UACD;QACF;MACF;AAID,eAASS,gBAAgBP,OAAO;AAC9B,YAAMc,aAAc,wBAAyBR,KAAKb,QAAQK,CAAD,CAAtC;AACnB,YAAIgB,YAAY;AACd,cAAIC,YAAYD,WAAW,CAAD,MAAQ,QAAQ,QAAQ;AAClD,cAAME,OAAOF,WAAW,CAAD,EAAIpB,MAAM,KAAM,CAA1B;AACb,cAAIuB,WAAWD,KAAK,CAAD,EAAIE,QAAQ,SAAS,IAAzB;AACf,cAAK,SAAUd,KAAKa,QAAhB,GAA2B;AAC7BA,uBAAWA,SAASE,OAAO,GAAGF,SAASf,SAAS,CAArC;UACZ;AACDF,gBAAMe,YAAY,UAAb,IAA2BE;AAChCjB,gBAAMe,YAAY,QAAb,KAA0BC,KAAK,CAAD,KAAO,IAAII,KAAhB;AAE9BtB;QACD;MACF;AAID,eAASW,YAAY;AACnB,YAAIY,mBAAmBvB,GACnBwB,kBAAkB7B,QAAQK,GAAD,GACzByB,cAAcD,gBAAgB5B,MAAM,4CAAtB;AAElB,YAAI8B,OAAO;UACTC,UAAU,CAACF,YAAY,CAAD;UACtBG,UAAU,OAAOH,YAAY,CAAD,MAAQ,cAAc,IAAI,CAACA,YAAY,CAAD;UAClEI,UAAU,CAACJ,YAAY,CAAD;UACtBK,UAAU,OAAOL,YAAY,CAAD,MAAQ,cAAc,IAAI,CAACA,YAAY,CAAD;UAClEM,OAAO,CAAA;UACPC,gBAAgB,CAAA;QANP;AAYX,YAAIN,KAAKE,aAAa,GAAG;AACvBF,eAAKC,YAAY;QAClB;AACD,YAAID,KAAKI,aAAa,GAAG;AACvBJ,eAAKG,YAAY;QAClB;AAED,YAAII,WAAW,GACXC,cAAc;AAClB,eAAOlC,IAAIL,QAAQS,QAAQJ,KAAK;AAG9B,cAAIL,QAAQK,CAAD,EAAImC,QAAQ,MAAnB,MAA+B,KACzBnC,IAAI,IAAIL,QAAQS,UACjBT,QAAQK,IAAI,CAAL,EAAQmC,QAAQ,MAAvB,MAAmC,KACnCxC,QAAQK,IAAI,CAAL,EAAQmC,QAAQ,IAAvB,MAAiC,GAAG;AACzC;UACH;AACD,cAAIC,YAAazC,QAAQK,CAAD,EAAII,UAAU,KAAKJ,KAAML,QAAQS,SAAS,IAAM,MAAMT,QAAQK,CAAD,EAAI,CAAX;AAE9E,cAAIoC,cAAc,OAAOA,cAAc,OAAOA,cAAc,OAAOA,cAAc,MAAM;AACrFV,iBAAKK,MAAM5B,KAAKR,QAAQK,CAAD,CAAvB;AACA0B,iBAAKM,eAAe7B,KAAKN,WAAWG,CAAD,KAAO,IAA1C;AAEA,gBAAIoC,cAAc,KAAK;AACrBH;YACD,WAAUG,cAAc,KAAK;AAC5BF;YACD,WAAUE,cAAc,KAAK;AAC5BH;AACAC;YACD;UACF,OAAM;AACL;UACD;QACF;AAGD,YAAI,CAACD,YAAYP,KAAKI,aAAa,GAAG;AACpCJ,eAAKI,WAAW;QACjB;AACD,YAAI,CAACI,eAAeR,KAAKE,aAAa,GAAG;AACvCF,eAAKE,WAAW;QACjB;AAGD,YAAIlC,QAAQkB,QAAQ;AAClB,cAAIqB,aAAaP,KAAKI,UAAU;AAC9B,kBAAM,IAAIjB,MAAM,sDAAsDU,mBAAmB,EAAnF;UACP;AACD,cAAIW,gBAAgBR,KAAKE,UAAU;AACjC,kBAAM,IAAIf,MAAM,wDAAwDU,mBAAmB,EAArF;UACP;QACF;AAED,eAAOG;MACR;AAED,aAAO1B,IAAIL,QAAQS,QAAQ;AACzBH,mBAAU;MACX;AAED,aAAOF;IACR;;;;;;;;;;;;ACrJc,aAAA,SAASsC,OAAOC,SAASC,SAAS;AAC/C,UAAIC,cAAc,MACdC,oBAAoB,OACpBC,mBAAmB,OACnBC,cAAc;AAElB,aAAO,SAASC,WAAW;AACzB,YAAIJ,eAAe,CAACE,kBAAkB;AACpC,cAAID,mBAAmB;AACrBE;UACD,OAAM;AACLH,0BAAc;UACf;AAID,cAAIH,QAAQM,eAAeJ,SAAS;AAClC,mBAAOI;UACR;AAEDD,6BAAmB;QACpB;AAED,YAAI,CAACD,mBAAmB;AACtB,cAAI,CAACC,kBAAkB;AACrBF,0BAAc;UACf;AAID,cAAIF,WAAWD,QAAQM,aAAa;AAClC,mBAAO,CAACA;UACT;AAEDF,8BAAoB;AACpB,iBAAOG,SAAQ;QAChB;MAIF;IACF;;;;;;;;;;;;;AC5CD,QAAA,SAAA;AACA,QAAA,oBAAA,uBAAA,2BAAA;;;;AAEO,aAASC,WAAWC,QAAQC,SAAuB;AAAA,UAAdC,UAAc,UAAA,SAAA,KAAA,UAAA,CAAA,MAAA,SAAA,UAAA,CAAA,IAAJ,CAAA;AACpD,UAAI,OAAOD,YAAY,UAAU;AAC/BA;SAAU;;QAAAE,OAAAA,YAAWF,OAAX;MACX;AAED,UAAIG,MAAMC,QAAQJ,OAAd,GAAwB;AAC1B,YAAIA,QAAQK,SAAS,GAAG;AACtB,gBAAM,IAAIC,MAAM,4CAAV;QACP;AAEDN,kBAAUA,QAAQ,CAAD;MAClB;AAGD,UAAIO,QAAQR,OAAOS,MAAM,qBAAb,GACRC,aAAaV,OAAOW,MAAM,sBAAb,KAAwC,CAAA,GACrDC,QAAQX,QAAQW,OAEhBC,cAAcX,QAAQW,eAAgB,SAACC,YAAYC,OAAMC,YAAWC,cAA9B;AAAA;;UAA+CF,UAASE;;MAAxD,GACtCC,aAAa,GACbC,aAAajB,QAAQiB,cAAc,GACnCC,UAAU,GACVC,SAAS,GAETC,aACAC;AAKJ,eAASC,SAASC,OAAMC,QAAO;AAC7B,iBAASC,KAAI,GAAGA,KAAIF,MAAKjB,MAAMF,QAAQqB,MAAK;AAC1C,cAAIZ,QAAOU,MAAKjB,MAAMmB,EAAX,GACPX,aAAaD,MAAKT,SAAS,IAAIS,MAAK,CAAD,IAAM,KACzCa,WAAWb,MAAKT,SAAS,IAAIS,MAAKc,OAAO,CAAZ,IAAiBd;AAElD,cAAIC,eAAc,OAAOA,eAAc,KAAK;AAE1C,gBAAI,CAACH,YAAYa,SAAQ,GAAGlB,MAAMkB,MAAD,GAASV,YAAWY,QAArC,GAA+C;AAC7DV;AAEA,kBAAIA,aAAaC,YAAY;AAC3B,uBAAO;cACR;YACF;AACDO,YAAAA;UACD;QACF;AAED,eAAO;MACR;AAGD,eAASI,IAAI,GAAGA,IAAIlB,MAAMN,QAAQwB,KAAK;AACrC,YAAIL,OAAOb,MAAMkB,CAAD,GACZC,UAAUvB,MAAMF,SAASmB,KAAKO,UAC9BC,cAAc,GACdP,QAAQL,SAASI,KAAKS,WAAW;AAErC,YAAIC;;WAAW;;UAAAC;;YAAAA;;UAAAA,GAAiBV,OAAON,SAASW,OAAjC;;AAEf,eAAOE,gBAAgBI,QAAWJ,cAAcE,SAAQ,GAAI;AAC1D,cAAIX,SAASC,MAAMC,QAAQO,WAAf,GAA6B;AACvCR,iBAAKJ,SAASA,UAAUY;AACxB;UACD;QACF;AAED,YAAIA,gBAAgBI,QAAW;AAC7B,iBAAO;QACR;AAIDjB,kBAAUK,KAAKJ,SAASI,KAAKS,WAAWT,KAAKO;MAC9C;AAGD,UAAIM,aAAa;AACjB,eAASR,KAAI,GAAGA,KAAIlB,MAAMN,QAAQwB,MAAK;AACrC,YAAIL,QAAOb,MAAMkB,EAAD,GACZJ,SAAQD,MAAKS,WAAWT,MAAKJ,SAASiB,aAAa;AACvDA,sBAAcb,MAAKc,WAAWd,MAAKO;AAEnC,iBAASL,IAAI,GAAGA,IAAIF,MAAKjB,MAAMF,QAAQqB,KAAK;AAC1C,cAAIZ,OAAOU,MAAKjB,MAAMmB,CAAX,GACPX,YAAaD,KAAKT,SAAS,IAAIS,KAAK,CAAD,IAAM,KACzCa,UAAWb,KAAKT,SAAS,IAAIS,KAAKc,OAAO,CAAZ,IAAiBd,MAC9CyB,YAAYf,MAAKgB,kBAAkBhB,MAAKgB,eAAed,CAApB,KAA0B;AAEjE,cAAIX,cAAc,KAAK;AACrBU;UACD,WAAUV,cAAc,KAAK;AAC5BR,kBAAMkC,OAAOhB,QAAO,CAApB;AACAhB,uBAAWgC,OAAOhB,QAAO,CAAzB;UAED,WAAUV,cAAc,KAAK;AAC5BR,kBAAMkC,OAAOhB,QAAO,GAAGE,OAAvB;AACAlB,uBAAWgC,OAAOhB,QAAO,GAAGc,SAA5B;AACAd;UACD,WAAUV,cAAc,MAAM;AAC7B,gBAAI2B,oBAAoBlB,MAAKjB,MAAMmB,IAAI,CAAf,IAAoBF,MAAKjB,MAAMmB,IAAI,CAAf,EAAkB,CAAlB,IAAuB;AACnE,gBAAIgB,sBAAsB,KAAK;AAC7BrB,4BAAc;YACf,WAAUqB,sBAAsB,KAAK;AACpCpB,yBAAW;YACZ;UACF;QACF;MACF;AAGD,UAAID,aAAa;AACf,eAAO,CAACd,MAAMA,MAAMF,SAAS,CAAhB,GAAoB;AAC/BE,gBAAMoC,IAAN;AACAlC,qBAAWkC,IAAX;QACD;MACF,WAAUrB,UAAU;AACnBf,cAAMqC,KAAK,EAAX;AACAnC,mBAAWmC,KAAK,IAAhB;MACD;AACD,eAASC,KAAK,GAAGA,KAAKtC,MAAMF,SAAS,GAAGwC,MAAM;AAC5CtC,cAAMsC,EAAD,IAAOtC,MAAMsC,EAAD,IAAOpC,WAAWoC,EAAD;MACnC;AACD,aAAOtC,MAAMuC,KAAK,EAAX;IACR;AAGM,aAASC,aAAa/C,SAASC,SAAS;AAC7C,UAAI,OAAOD,YAAY,UAAU;AAC/BA;SAAU;;QAAAE,OAAAA,YAAWF,OAAX;MACX;AAED,UAAIgD,eAAe;AACnB,eAASC,eAAe;AACtB,YAAIC,QAAQlD,QAAQgD,cAAD;AACnB,YAAI,CAACE,OAAO;AACV,iBAAOjD,QAAQkD,SAAR;QACR;AAEDlD,gBAAQmD,SAASF,OAAO,SAASG,KAAKC,MAAM;AAC1C,cAAID,KAAK;AACP,mBAAOpD,QAAQkD,SAASE,GAAjB;UACR;AAED,cAAIE,iBAAiBzD,WAAWwD,MAAMJ,OAAOjD,OAAd;AAC/BA,kBAAQuD,QAAQN,OAAOK,gBAAgB,SAASF,MAAK;AACnD,gBAAIA,MAAK;AACP,qBAAOpD,QAAQkD,SAASE,IAAjB;YACR;AAEDJ,yBAAY;UACb,CAND;QAOD,CAbD;MAcD;AACDA,mBAAY;IACb;;;;;;;;;;;;;;;AC/JD,QAAA,QAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEO,aAASQ,gBAAgBC,aAAaC,aAAaC,QAAQC,QAAQC,WAAWC,WAAWC,SAAS;AACvG,UAAI,CAACA,SAAS;AACZA,kBAAU,CAAA;MACX;AACD,UAAI,OAAOA,QAAQC,YAAY,aAAa;AAC1CD,gBAAQC,UAAU;MACnB;AAED,UAAMC;;SAAO;;QAAAC,MAAAA,WAAUP,QAAQC,QAAQG,OAA1B;;AACb,UAAG,CAACE,MAAM;AACR;MACD;AAEDA,WAAKE,KAAK;QAACC,OAAO;QAAIC,OAAO,CAAA;MAAnB,CAAV;AAEA,eAASC,aAAaD,OAAO;AAC3B,eAAOA,MAAME,IAAI,SAASC,OAAO;AAAE,iBAAO,MAAMA;QAAQ,CAAjD;MACR;AAED,UAAIC,QAAQ,CAAA;AACZ,UAAIC,gBAAgB,GAAGC,gBAAgB,GAAGC,WAAW,CAAA,GACjDC,UAAU,GAAGC,UAAU;AArB4E,UAAA,QAAA,SAAAC,OAsB9FC,IAtB8F;AAuBrG,YAAMC,UAAUhB,KAAKe,EAAD,GACdX,QAAQY,QAAQZ,SAASY,QAAQb,MAAMc,QAAQ,OAAO,EAA7B,EAAiCC,MAAM,IAAvC;AAC/BF,gBAAQZ,QAAQA;AAEhB,YAAIY,QAAQG,SAASH,QAAQI,SAAS;AAAA,cAAA;AAEpC,cAAI,CAACX,eAAe;AAClB,gBAAMY,OAAOrB,KAAKe,KAAI,CAAL;AACjBN,4BAAgBG;AAChBF,4BAAgBG;AAEhB,gBAAIQ,MAAM;AACRV,yBAAWb,QAAQC,UAAU,IAAIM,aAAagB,KAAKjB,MAAMkB,MAAM,CAACxB,QAAQC,OAA1B,CAAD,IAAuC,CAAA;AACpFU,+BAAiBE,SAASY;AAC1Bb,+BAAiBC,SAASY;YAC3B;UACF;AAGD,WAAA;UAAAZ,UAAST,KAAT;;YAAA;;YAAA;;cAAkBE,MAAME,IAAI,SAASC,OAAO;AAC1C,wBAAQS,QAAQG,QAAQ,MAAM,OAAOZ;cACtC,CAFiB;YAAlB;UAAA;AAKA,cAAIS,QAAQG,OAAO;AACjBN,uBAAWT,MAAMmB;UAClB,OAAM;AACLX,uBAAWR,MAAMmB;UAClB;QACF,OAAM;AAEL,cAAId,eAAe;AAEjB,gBAAIL,MAAMmB,UAAUzB,QAAQC,UAAU,KAAKgB,KAAIf,KAAKuB,SAAS,GAAG;AAAA,kBAAA;AAE9D,eAAA;cAAAZ,UAAST,KAAT;;gBAAA;;gBAAA;;kBAAkBG,aAAaD,KAAD;gBAA9B;cAAA;YACD,OAAM;AAAA,kBAAA;AAEL,kBAAIoB,cAAcC,KAAKC,IAAItB,MAAMmB,QAAQzB,QAAQC,OAA/B;AAClB,eAAA;cAAAY,UAAST,KAAT;;gBAAA;;gBAAA;;kBAAkBG,aAAaD,MAAMkB,MAAM,GAAGE,WAAf,CAAD;gBAA9B;cAAA;AAEA,kBAAIG,OAAO;gBACTC,UAAUnB;gBACVoB,UAAWjB,UAAUH,gBAAgBe;gBACrCM,UAAUpB;gBACVqB,UAAWlB,UAAUH,gBAAgBc;gBACrCpB,OAAOO;cALE;AAOX,kBAAII,MAAKf,KAAKuB,SAAS,KAAKnB,MAAMmB,UAAUzB,QAAQC,SAAS;AAE3D,oBAAIiC,gBAAkB,MAAOC,KAAKvC,MAAb;AACrB,oBAAIwC,gBAAkB,MAAOD,KAAKtC,MAAb;AACrB,oBAAIwC,iBAAiB/B,MAAMmB,UAAU,KAAKZ,SAASY,SAASI,KAAKE;AACjE,oBAAI,CAACG,iBAAiBG,kBAAkBzC,OAAO6B,SAAS,GAAG;AAGzDZ,2BAASyB,OAAOT,KAAKE,UAAU,GAAG,8BAAlC;gBACD;AACD,oBAAK,CAACG,iBAAiB,CAACG,kBAAmB,CAACD,eAAe;AACzDvB,2BAAST,KAAK,8BAAd;gBACD;cACF;AACDM,oBAAMN,KAAKyB,IAAX;AAEAlB,8BAAgB;AAChBC,8BAAgB;AAChBC,yBAAW,CAAA;YACZ;UACF;AACDC,qBAAWR,MAAMmB;AACjBV,qBAAWT,MAAMmB;QAClB;MA9FoG;AAsBvG,eAASR,IAAI,GAAGA,IAAIf,KAAKuB,QAAQR,KAAK;AAAA;;UAA7BA;QAA6B;MAyErC;AAED,aAAO;QACLvB;QAA0BC;QAC1BG;QAAsBC;QACtBW;MAHK;IAKR;AAEM,aAAS6B,YAAYrC,MAAM;AAChC,UAAIsC,MAAMC,QAAQvC,IAAd,GAAqB;AACvB,eAAOA,KAAKM,IAAI+B,WAAT,EAAsBG,KAAK,IAA3B;MACR;AAED,UAAMC,MAAM,CAAA;AACZ,UAAIzC,KAAKR,eAAeQ,KAAKP,aAAa;AACxCgD,YAAIvC,KAAK,YAAYF,KAAKR,WAA1B;MACD;AACDiD,UAAIvC,KAAK,qEAAT;AACAuC,UAAIvC,KAAK,SAASF,KAAKR,eAAe,OAAOQ,KAAKJ,cAAc,cAAc,KAAK,MAAOI,KAAKJ,UAA/F;AACA6C,UAAIvC,KAAK,SAASF,KAAKP,eAAe,OAAOO,KAAKH,cAAc,cAAc,KAAK,MAAOG,KAAKH,UAA/F;AAEA,eAASkB,IAAI,GAAGA,IAAIf,KAAKQ,MAAMe,QAAQR,KAAK;AAC1C,YAAMY,OAAO3B,KAAKQ,MAAMO,CAAX;AAIb,YAAIY,KAAKE,aAAa,GAAG;AACvBF,eAAKC,YAAY;QAClB;AACD,YAAID,KAAKI,aAAa,GAAG;AACvBJ,eAAKG,YAAY;QAClB;AACDW,YAAIvC,KACF,SAASyB,KAAKC,WAAW,MAAMD,KAAKE,WAClC,OAAOF,KAAKG,WAAW,MAAMH,KAAKI,WAClC,KAHJ;AAKAU,YAAIvC,KAAKwC,MAAMD,KAAKd,KAAKvB,KAAzB;MACD;AAED,aAAOqC,IAAID,KAAK,IAAT,IAAiB;IACzB;AAEM,aAASG,oBAAoBnD,aAAaC,aAAaC,QAAQC,QAAQC,WAAWC,WAAWC,SAAS;AAC3G,aAAOuC,YAAY9C,gBAAgBC,aAAaC,aAAaC,QAAQC,QAAQC,WAAWC,WAAWC,OAAjE,CAAhB;IACnB;AAEM,aAAS8C,YAAYC,UAAUnD,QAAQC,QAAQC,WAAWC,WAAWC,SAAS;AACnF,aAAO6C,oBAAoBE,UAAUA,UAAUnD,QAAQC,QAAQC,WAAWC,WAAWC,OAA3D;IAC3B;;;;;;;;;;;;;ACnJM,aAASgD,WAAWC,GAAGC,GAAG;AAC/B,UAAID,EAAEE,WAAWD,EAAEC,QAAQ;AACzB,eAAO;MACR;AAED,aAAOC,gBAAgBH,GAAGC,CAAJ;IACvB;AAEM,aAASE,gBAAgBC,OAAOC,OAAO;AAC5C,UAAIA,MAAMH,SAASE,MAAMF,QAAQ;AAC/B,eAAO;MACR;AAED,eAASI,IAAI,GAAGA,IAAID,MAAMH,QAAQI,KAAK;AACrC,YAAID,MAAMC,CAAD,MAAQF,MAAME,CAAD,GAAK;AACzB,iBAAO;QACR;MACF;AAED,aAAO;IACR;;;;;;;;;;;;;ACpBD,QAAA,UAAA;AACA,QAAA,SAAA;AAEA,QAAA,SAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEO,aAASC,cAAcC,MAAM;AAAA,UAAA;;QACLC,oBAAoBD,KAAKE,KAAN;SAAzCC,WAD2B,qBAC3BA,UAAUC,WADiB,qBACjBA;AAEjB,UAAID,aAAaE,QAAW;AAC1BL,aAAKG,WAAWA;MACjB,OAAM;AACL,eAAOH,KAAKG;MACb;AAED,UAAIC,aAAaC,QAAW;AAC1BL,aAAKI,WAAWA;MACjB,OAAM;AACL,eAAOJ,KAAKI;MACb;IACF;AAEM,aAASE,MAAMC,MAAMC,QAAQC,MAAM;AACxCF,aAAOG,UAAUH,MAAME,IAAP;AAChBD,eAASE,UAAUF,QAAQC,IAAT;AAElB,UAAIE,MAAM,CAAA;AAKV,UAAIJ,KAAKK,SAASJ,OAAOI,OAAO;AAC9BD,YAAIC,QAAQL,KAAKK,SAASJ,OAAOI;MAClC;AAED,UAAIL,KAAKM,eAAeL,OAAOK,aAAa;AAC1C,YAAI,CAACC,gBAAgBP,IAAD,GAAQ;AAE1BI,cAAII,cAAcP,OAAOO,eAAeR,KAAKQ;AAC7CJ,cAAIE,cAAcL,OAAOK,eAAeN,KAAKM;AAC7CF,cAAIK,YAAYR,OAAOQ,aAAaT,KAAKS;AACzCL,cAAIM,YAAYT,OAAOS,aAAaV,KAAKU;QAC1C,WAAU,CAACH,gBAAgBN,MAAD,GAAU;AAEnCG,cAAII,cAAcR,KAAKQ;AACvBJ,cAAIE,cAAcN,KAAKM;AACvBF,cAAIK,YAAYT,KAAKS;AACrBL,cAAIM,YAAYV,KAAKU;QACtB,OAAM;AAELN,cAAII,cAAcG,YAAYP,KAAKJ,KAAKQ,aAAaP,OAAOO,WAA/B;AAC7BJ,cAAIE,cAAcK,YAAYP,KAAKJ,KAAKM,aAAaL,OAAOK,WAA/B;AAC7BF,cAAIK,YAAYE,YAAYP,KAAKJ,KAAKS,WAAWR,OAAOQ,SAA7B;AAC3BL,cAAIM,YAAYC,YAAYP,KAAKJ,KAAKU,WAAWT,OAAOS,SAA7B;QAC5B;MACF;AAEDN,UAAIQ,QAAQ,CAAA;AAEZ,UAAIC,YAAY,GACZC,cAAc,GACdC,aAAa,GACbC,eAAe;AAEnB,aAAOH,YAAYb,KAAKY,MAAMK,UAAUH,cAAcb,OAAOW,MAAMK,QAAQ;AACzE,YAAIC,cAAclB,KAAKY,MAAMC,SAAX,KAAyB;UAACM,UAAUC;QAAX,GACvCC,gBAAgBpB,OAAOW,MAAME,WAAb,KAA6B;UAACK,UAAUC;QAAX;AAEjD,YAAIE,WAAWJ,aAAaG,aAAd,GAA8B;AAE1CjB,cAAIQ,MAAMW,KAAKC,UAAUN,aAAaH,UAAd,CAAxB;AACAF;AACAG,0BAAgBE,YAAYrB,WAAWqB,YAAYtB;QACpD,WAAU0B,WAAWD,eAAeH,WAAhB,GAA8B;AAEjDd,cAAIQ,MAAMW,KAAKC,UAAUH,eAAeL,YAAhB,CAAxB;AACAF;AACAC,wBAAcM,cAAcxB,WAAWwB,cAAczB;QACtD,OAAM;AAEL,cAAI6B,aAAa;YACfN,UAAUO,KAAKC,IAAIT,YAAYC,UAAUE,cAAcF,QAA7C;YACVvB,UAAU;YACVgC,UAAUF,KAAKC,IAAIT,YAAYU,WAAWb,YAAYM,cAAcF,WAAWH,YAArE;YACVnB,UAAU;YACVF,OAAO,CAAA;UALQ;AAOjBkC,qBAAWJ,YAAYP,YAAYC,UAAUD,YAAYvB,OAAO0B,cAAcF,UAAUE,cAAc1B,KAA5F;AACVmB;AACAD;AAEAT,cAAIQ,MAAMW,KAAKE,UAAf;QACD;MACF;AAED,aAAOrB;IACR;AAED,aAASD,UAAU2B,OAAO5B,MAAM;AAC9B,UAAI,OAAO4B,UAAU,UAAU;AAC7B,YAAK,OAAQC,KAAKD,KAAd,KAA0B,WAAYC,KAAKD,KAAlB,GAA2B;AACtD;;aAAO;;YAAAE,OAAAA,YAAWF,KAAX,EAAkB,CAAlB;;QACR;AAED,YAAI,CAAC5B,MAAM;AACT,gBAAM,IAAI+B,MAAM,kDAAV;QACP;AACD;;WAAO;;UAAAC,QAAAA,iBAAgBpC,QAAWA,QAAWI,MAAM4B,KAA5C;;MACR;AAED,aAAOA;IACR;AAED,aAASvB,gBAAgB4B,OAAO;AAC9B,aAAOA,MAAM7B,eAAe6B,MAAM7B,gBAAgB6B,MAAM3B;IACzD;AAED,aAASG,YAAYN,OAAOL,MAAMC,QAAQ;AACxC,UAAID,SAASC,QAAQ;AACnB,eAAOD;MACR,OAAM;AACLK,cAAM+B,WAAW;AACjB,eAAO;UAACpC;UAAMC;QAAP;MACR;IACF;AAED,aAASqB,WAAWS,MAAMM,OAAO;AAC/B,aAAON,KAAKZ,WAAWkB,MAAMlB,YACvBY,KAAKZ,WAAWY,KAAKnC,WAAYyC,MAAMlB;IAC9C;AAED,aAASK,UAAU/B,MAAM6C,QAAQ;AAC/B,aAAO;QACLnB,UAAU1B,KAAK0B;QAAUvB,UAAUH,KAAKG;QACxCgC,UAAUnC,KAAKmC,WAAWU;QAAQzC,UAAUJ,KAAKI;QACjDF,OAAOF,KAAKE;MAHP;IAKR;AAED,aAASkC,WAAWpC,MAAMsB,YAAYwB,WAAWC,aAAaC,YAAY;AAGxE,UAAIzC,OAAO;QAACsC,QAAQvB;QAAYpB,OAAO4C;QAAWlC,OAAO;MAA9C,GACPqC,QAAQ;QAACJ,QAAQE;QAAa7C,OAAO8C;QAAYpC,OAAO;MAAhD;AAGZsC,oBAAclD,MAAMO,MAAM0C,KAAb;AACbC,oBAAclD,MAAMiD,OAAO1C,IAAd;AAGb,aAAOA,KAAKK,QAAQL,KAAKL,MAAMsB,UAAUyB,MAAMrC,QAAQqC,MAAM/C,MAAMsB,QAAQ;AACzE,YAAIC,cAAclB,KAAKL,MAAMK,KAAKK,KAAhB,GACduC,eAAeF,MAAM/C,MAAM+C,MAAMrC,KAAlB;AAEnB,aAAKa,YAAY,CAAD,MAAQ,OAAOA,YAAY,CAAD,MAAQ,SAC1C0B,aAAa,CAAD,MAAQ,OAAOA,aAAa,CAAD,MAAQ,MAAM;AAE3DC,uBAAapD,MAAMO,MAAM0C,KAAb;QACb,WAAUxB,YAAY,CAAD,MAAQ,OAAO0B,aAAa,CAAD,MAAQ,KAAK;AAAA,cAAA;AAE5D,WAAA;UAAAnD,KAAKE,OAAM4B,KAAX;;YAAA;;YAAA;;cAAoBuB,cAAc9C,IAAD;YAAjC;UAAA;QACD,WAAU4C,aAAa,CAAD,MAAQ,OAAO1B,YAAY,CAAD,MAAQ,KAAK;AAAA,cAAA;AAE5D,WAAA;UAAAzB,KAAKE,OAAM4B,KAAX;;YAAA;;YAAA;;cAAoBuB,cAAcJ,KAAD;YAAjC;UAAA;QACD,WAAUxB,YAAY,CAAD,MAAQ,OAAO0B,aAAa,CAAD,MAAQ,KAAK;AAE5DG,kBAAQtD,MAAMO,MAAM0C,KAAb;QACR,WAAUE,aAAa,CAAD,MAAQ,OAAO1B,YAAY,CAAD,MAAQ,KAAK;AAE5D6B,kBAAQtD,MAAMiD,OAAO1C,MAAM,IAApB;QACR,WAAUkB,gBAAgB0B,cAAc;AAEvCnD,eAAKE,MAAM4B,KAAKL,WAAhB;AACAlB,eAAKK;AACLqC,gBAAMrC;QACP,OAAM;AAEL+B,mBAAS3C,MAAMqD,cAAc9C,IAAD,GAAQ8C,cAAcJ,KAAD,CAAzC;QACT;MACF;AAGDM,qBAAevD,MAAMO,IAAP;AACdgD,qBAAevD,MAAMiD,KAAP;AAEdlD,oBAAcC,IAAD;IACd;AAED,aAASoD,aAAapD,MAAMO,MAAM0C,OAAO;AACvC,UAAIO,YAAYH,cAAc9C,IAAD,GACzBkD,eAAeJ,cAAcJ,KAAD;AAEhC,UAAIS,WAAWF,SAAD,KAAeE,WAAWD,YAAD,GAAgB;AAErD;;WAAI;;UAAAE,OAAAA,iBAAgBH,WAAWC,YAA3B,KACGG,mBAAmBX,OAAOO,WAAWA,UAAUhC,SAASiC,aAAajC,MAAnD;UAA4D;AAAA,cAAA;AACnF,WAAA;UAAAxB,KAAKE,OAAM4B,KAAX;;YAAA;;YAAA;;cAAoB0B;YAApB;UAAA;AACA;QACD;;WAAU;;UAAAG,OAAAA,iBAAgBF,cAAcD,SAA9B,KACJI,mBAAmBrD,MAAMkD,cAAcA,aAAajC,SAASgC,UAAUhC,MAArD;UAA8D;AAAA,cAAA;AACrF,WAAA;UAAAxB,KAAKE,OAAM4B,KAAX;;YAAA;;YAAA;;cAAoB2B;YAApB;UAAA;AACA;QACD;MACF;;SAAU;;QAAAI,OAAAA,YAAWL,WAAWC,YAAtB;QAAqC;AAAA,YAAA;AAC9C,SAAA;QAAAzD,KAAKE,OAAM4B,KAAX;;UAAA;;UAAA;;YAAoB0B;UAApB;QAAA;AACA;MACD;AAEDb,eAAS3C,MAAMwD,WAAWC,YAAlB;IACT;AAED,aAASH,QAAQtD,MAAMO,MAAM0C,OAAOa,MAAM;AACxC,UAAIN,YAAYH,cAAc9C,IAAD,GACzBkD,eAAeM,eAAed,OAAOO,SAAR;AACjC,UAAIC,aAAaO,QAAQ;AAAA,YAAA;AACvB,SAAA;QAAAhE,KAAKE,OAAM4B,KAAX;;UAAA;;UAAA;;YAAoB2B,aAAaO;UAAjC;QAAA;MACD,OAAM;AACLrB,iBAAS3C,MAAM8D,OAAOL,eAAeD,WAAWM,OAAON,YAAYC,YAA3D;MACT;IACF;AAED,aAASd,SAAS3C,MAAMO,MAAM0C,OAAO;AACnCjD,WAAK2C,WAAW;AAChB3C,WAAKE,MAAM4B,KAAK;QACda,UAAU;QACVpC;QACAC,QAAQyC;MAHM,CAAhB;IAKD;AAED,aAASC,cAAclD,MAAMiE,QAAQhB,OAAO;AAC1C,aAAOgB,OAAOpB,SAASI,MAAMJ,UAAUoB,OAAOrD,QAAQqD,OAAO/D,MAAMsB,QAAQ;AACzE,YAAI0C,OAAOD,OAAO/D,MAAM+D,OAAOrD,OAApB;AACXZ,aAAKE,MAAM4B,KAAKoC,IAAhB;AACAD,eAAOpB;MACR;IACF;AACD,aAASU,eAAevD,MAAMiE,QAAQ;AACpC,aAAOA,OAAOrD,QAAQqD,OAAO/D,MAAMsB,QAAQ;AACzC,YAAI0C,OAAOD,OAAO/D,MAAM+D,OAAOrD,OAApB;AACXZ,aAAKE,MAAM4B,KAAKoC,IAAhB;MACD;IACF;AAED,aAASb,cAAcc,OAAO;AAC5B,UAAIxD,MAAM,CAAA,GACNyD,YAAYD,MAAMjE,MAAMiE,MAAMvD,KAAlB,EAAyB,CAAzB;AAChB,aAAOuD,MAAMvD,QAAQuD,MAAMjE,MAAMsB,QAAQ;AACvC,YAAI0C,OAAOC,MAAMjE,MAAMiE,MAAMvD,KAAlB;AAGX,YAAIwD,cAAc,OAAOF,KAAK,CAAD,MAAQ,KAAK;AACxCE,sBAAY;QACb;AAED,YAAIA,cAAcF,KAAK,CAAD,GAAK;AACzBvD,cAAImB,KAAKoC,IAAT;AACAC,gBAAMvD;QACP,OAAM;AACL;QACD;MACF;AAED,aAAOD;IACR;AACD,aAASoD,eAAeI,OAAOE,cAAc;AAC3C,UAAIC,UAAU,CAAA,GACVN,SAAS,CAAA,GACTO,aAAa,GACbC,iBAAiB,OACjBC,aAAa;AACjB,aAAOF,aAAaF,aAAa7C,UACxB2C,MAAMvD,QAAQuD,MAAMjE,MAAMsB,QAAQ;AACzC,YAAIkD,SAASP,MAAMjE,MAAMiE,MAAMvD,KAAlB,GACT+D,QAAQN,aAAaE,UAAD;AAGxB,YAAII,MAAM,CAAD,MAAQ,KAAK;AACpB;QACD;AAEDH,yBAAiBA,kBAAkBE,OAAO,CAAD,MAAQ;AAEjDV,eAAOlC,KAAK6C,KAAZ;AACAJ;AAIA,YAAIG,OAAO,CAAD,MAAQ,KAAK;AACrBD,uBAAa;AAEb,iBAAOC,OAAO,CAAD,MAAQ,KAAK;AACxBJ,oBAAQxC,KAAK4C,MAAb;AACAA,qBAASP,MAAMjE,MAAM,EAAEiE,MAAMvD,KAApB;UACV;QACF;AAED,YAAI+D,MAAMC,OAAO,CAAb,MAAoBF,OAAOE,OAAO,CAAd,GAAkB;AACxCN,kBAAQxC,KAAK4C,MAAb;AACAP,gBAAMvD;QACP,OAAM;AACL6D,uBAAa;QACd;MACF;AAED,WAAKJ,aAAaE,UAAD,KAAgB,IAAI,CAAjC,MAAwC,OACrCC,gBAAgB;AACrBC,qBAAa;MACd;AAED,UAAIA,YAAY;AACd,eAAOH;MACR;AAED,aAAOC,aAAaF,aAAa7C,QAAQ;AACvCwC,eAAOlC,KAAKuC,aAAaE,YAAD,CAAxB;MACD;AAED,aAAO;QACLP;QACAM;MAFK;IAIR;AAED,aAASZ,WAAWY,SAAS;AAC3B,aAAOA,QAAQO,OAAO,SAASC,MAAMJ,QAAQ;AAC3C,eAAOI,QAAQJ,OAAO,CAAD,MAAQ;MAC9B,GAAE,IAFI;IAGR;AACD,aAASd,mBAAmBO,OAAOY,eAAeC,OAAO;AACvD,eAASC,IAAI,GAAGA,IAAID,OAAOC,KAAK;AAC9B,YAAIC,gBAAgBH,cAAcA,cAAcvD,SAASwD,QAAQC,CAAhC,EAAmCL,OAAO,CAAvD;AACpB,YAAIT,MAAMjE,MAAMiE,MAAMvD,QAAQqE,CAA1B,MAAiC,MAAMC,eAAe;AACxD,iBAAO;QACR;MACF;AAEDf,YAAMvD,SAASoE;AACf,aAAO;IACR;AAED,aAAS/E,oBAAoBC,OAAO;AAClC,UAAIC,WAAW;AACf,UAAIC,WAAW;AAEfF,YAAMiF,QAAQ,SAASjB,MAAM;AAC3B,YAAI,OAAOA,SAAS,UAAU;AAC5B,cAAIkB,UAAUnF,oBAAoBiE,KAAK3D,IAAN;AACjC,cAAI8E,aAAapF,oBAAoBiE,KAAK1D,MAAN;AAEpC,cAAIL,aAAaE,QAAW;AAC1B,gBAAI+E,QAAQjF,aAAakF,WAAWlF,UAAU;AAC5CA,0BAAYiF,QAAQjF;YACrB,OAAM;AACLA,yBAAWE;YACZ;UACF;AAED,cAAID,aAAaC,QAAW;AAC1B,gBAAI+E,QAAQhF,aAAaiF,WAAWjF,UAAU;AAC5CA,0BAAYgF,QAAQhF;YACrB,OAAM;AACLA,yBAAWC;YACZ;UACF;QACF,OAAM;AACL,cAAID,aAAaC,WAAc6D,KAAK,CAAD,MAAQ,OAAOA,KAAK,CAAD,MAAQ,MAAM;AAClE9D;UACD;AACD,cAAID,aAAaE,WAAc6D,KAAK,CAAD,MAAQ,OAAOA,KAAK,CAAD,MAAQ,MAAM;AAClE/D;UACD;QACF;MACF,CA5BD;AA8BA,aAAO;QAACA;QAAUC;MAAX;IACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvXM,aAASkF,aAAaC,iBAAiB;AAC5C,UAAIC,MAAMC,QAAQF,eAAd,GAAgC;AAClC,eAAOA,gBAAgBG,IAAIJ,YAApB,EAAkCK,QAAlC;MACR;AAED;;QAAA,cAAA;UAAA,CAAA;;UACKJ;QADL,GAAA,CAAA,GAAA;UAEEK,aAAaL,gBAAgBM;UAC7BC,WAAWP,gBAAgBQ;UAC3BF,aAAaN,gBAAgBK;UAC7BG,WAAWR,gBAAgBO;UAC3BE,OAAOT,gBAAgBS,MAAMN,IAAI,SAAAO,MAAQ;AACvC,mBAAO;cACLC,UAAUD,KAAKE;cACfC,UAAUH,KAAKI;cACfF,UAAUF,KAAKC;cACfG,UAAUJ,KAAKG;cACfE,gBAAgBL,KAAKK;cACrBC,OAAON,KAAKM,MAAMb,IAAI,SAAAc,GAAK;AACzB,oBAAIA,EAAEC,WAAW,GAAb,GAAmB;AAAE;;oBAAA,IAAA;;sBAAWD,EAAEE,MAAM,CAAR;oBAAX;;gBAA0B;AACnD,oBAAIF,EAAEC,WAAW,GAAb,GAAmB;AAAE;;oBAAA,IAAA;;sBAAWD,EAAEE,MAAM,CAAR;oBAAX;;gBAA0B;AACnD,uBAAOF;cACR,CAJM;YANF;UAYR,CAbM;QANT,CAAA;;IAqBD;;;;;;;;;;;;ACzBM,aAASG,oBAAoBC,SAAS;AAC3C,UAAIC,MAAM,CAAA,GACNC,QACAC;AACJ,eAASC,IAAI,GAAGA,IAAIJ,QAAQK,QAAQD,KAAK;AACvCF,iBAASF,QAAQI,CAAD;AAChB,YAAIF,OAAOI,OAAO;AAChBH,sBAAY;QACb,WAAUD,OAAOK,SAAS;AACzBJ,sBAAY;QACb,OAAM;AACLA,sBAAY;QACb;AAEDF,YAAIO,KAAK,CAACL,WAAWD,OAAOO,KAAnB,CAAT;MACD;AACD,aAAOR;IACR;;;;;;;;;;;;AClBM,aAASS,oBAAoBC,SAAS;AAC3C,UAAIC,MAAM,CAAA;AACV,eAASC,IAAI,GAAGA,IAAIF,QAAQG,QAAQD,KAAK;AACvC,YAAIE,SAASJ,QAAQE,CAAD;AACpB,YAAIE,OAAOC,OAAO;AAChBJ,cAAIK,KAAK,OAAT;QACD,WAAUF,OAAOG,SAAS;AACzBN,cAAIK,KAAK,OAAT;QACD;AAEDL,YAAIK,KAAKE,WAAWJ,OAAOK,KAAR,CAAnB;AAEA,YAAIL,OAAOC,OAAO;AAChBJ,cAAIK,KAAK,QAAT;QACD,WAAUF,OAAOG,SAAS;AACzBN,cAAIK,KAAK,QAAT;QACD;MACF;AACD,aAAOL,IAAIS,KAAK,EAAT;IACR;AAED,aAASF,WAAWG,GAAG;AACrB,UAAIC,IAAID;AACRC,UAAIA,EAAEC,QAAQ,MAAM,OAAhB;AACJD,UAAIA,EAAEC,QAAQ,MAAM,MAAhB;AACJD,UAAIA,EAAEC,QAAQ,MAAM,MAAhB;AACJD,UAAIA,EAAEC,QAAQ,MAAM,QAAhB;AAEJ,aAAOD;IACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbD,QAAA,QAAA,uBAAA,cAAA;AACA,QAAA,aAAA;AACA,QAAA,QAAA;AACA,QAAA,QAAA;AACA,QAAA,YAAA;AAEA,QAAA,OAAA;AACA,QAAA,QAAA;AAEA,QAAA,SAAA;AAEA,QAAA,SAAA;AACA,QAAA,SAAA;AACA,QAAA,SAAA;AACA,QAAA,WAAA;AACA,QAAA,UAAA;AAEA,QAAA,OAAA;AACA,QAAA,OAAA;;;;;;;;AClCA;AAAA;AAAA;AACA,QAAI,kBAAmB,WAAQ,QAAK,oBAAqB,OAAO,SAAU,SAAS,GAAG,GAAG,GAAG,IAAI;AAC5F,UAAI,OAAO,OAAW,MAAK;AAC3B,UAAI,OAAO,OAAO,yBAAyB,GAAG,CAAC;AAC/C,UAAI,CAAC,SAAS,SAAS,OAAO,CAAC,EAAE,aAAa,KAAK,YAAY,KAAK,eAAe;AACjF,eAAO,EAAE,YAAY,MAAM,KAAK,WAAW;AAAE,iBAAO,EAAE,CAAC;AAAA,QAAG,EAAE;AAAA,MAC9D;AACA,aAAO,eAAe,GAAG,IAAI,IAAI;AAAA,IACrC,IAAM,SAAS,GAAG,GAAG,GAAG,IAAI;AACxB,UAAI,OAAO,OAAW,MAAK;AAC3B,QAAE,EAAE,IAAI,EAAE,CAAC;AAAA,IACf;AACA,QAAI,qBAAsB,WAAQ,QAAK,uBAAwB,OAAO,SAAU,SAAS,GAAG,GAAG;AAC3F,aAAO,eAAe,GAAG,WAAW,EAAE,YAAY,MAAM,OAAO,EAAE,CAAC;AAAA,IACtE,IAAK,SAAS,GAAG,GAAG;AAChB,QAAE,SAAS,IAAI;AAAA,IACnB;AACA,QAAI,eAAgB,WAAQ,QAAK,gBAAiB,SAAU,KAAK;AAC7D,UAAI,OAAO,IAAI,WAAY,QAAO;AAClC,UAAI,SAAS,CAAC;AACd,UAAI,OAAO;AAAM,iBAAS,KAAK,IAAK,KAAI,MAAM,aAAa,OAAO,UAAU,eAAe,KAAK,KAAK,CAAC,EAAG,iBAAgB,QAAQ,KAAK,CAAC;AAAA;AACvI,yBAAmB,QAAQ,GAAG;AAC9B,aAAO;AAAA,IACX;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,yBAAyB,QAAQ,aAAa,QAAQ,WAAW;AACzE,QAAM,OAAO,aAAa,aAAe;AACzC,QAAM,SAAS;AACf,QAAI;AACJ,KAAC,SAAUE,WAAU;AACjB,MAAAA,UAASA,UAAS,SAAS,IAAI,CAAC,IAAI;AACpC,MAAAA,UAASA,UAAS,OAAO,IAAI,CAAC,IAAI;AAClC,MAAAA,UAASA,UAAS,SAAS,IAAI,CAAC,IAAI;AACpC,MAAAA,UAASA,UAAS,SAAS,IAAI,CAAC,IAAI;AAAA,IACxC,GAAG,aAAa,QAAQ,WAAW,WAAW,CAAC,EAAE;AAEjD,QAAI;AACJ,KAAC,SAAUC,aAAY;AACnB,MAAAA,YAAW,OAAO,IAAI;AACtB,MAAAA,YAAW,OAAO,IAAI;AACtB,MAAAA,YAAW,kBAAkB,IAAI;AACjC,MAAAA,YAAW,OAAO,IAAI;AACtB,MAAAA,YAAW,eAAe,IAAI;AAC9B,MAAAA,YAAW,WAAW,IAAI;AAC1B,MAAAA,YAAW,KAAK,IAAI;AACpB,MAAAA,YAAW,MAAM,IAAI;AAAA,IACzB,GAAG,eAAe,QAAQ,aAAa,aAAa,CAAC,EAAE;AAOvD,QAAM,iBAAiB,CAAC,UAAU;AAC9B,UAAI,UAAU;AACV,eAAO,CAAC;AACZ,YAAM,QAAQ,MAAM,QAAQ,OAAO,EAAE,EAAE,MAAM,IAAI;AACjD,aAAO;AAAA,IACX;AASA,QAAM,cAAc,CAAC,UAAU,UAAU,gBAAgB,WAAW,UAAU;AAC1E,YAAM,YAAY,OAAO,aAAa,EAAE,UAAU,QAAQ;AAC1D,YAAM,eAAe;AAAA,QACjB,MAAM,CAAC;AAAA,QACP,OAAO,CAAC;AAAA,MACZ;AACA,gBAAU,QAAQ,CAAC,EAAE,OAAO,SAAS,MAAM,MAAM;AAC7C,cAAM,kBAAkB,CAAC;AACzB,YAAI,OAAO;AACP,0BAAgB,OAAO,SAAS;AAChC,0BAAgB,QAAQ;AACxB,uBAAa,MAAM,KAAK,eAAe;AAAA,QAC3C;AACA,YAAI,SAAS;AACT,0BAAgB,OAAO,SAAS;AAChC,0BAAgB,QAAQ;AACxB,uBAAa,KAAK,KAAK,eAAe;AAAA,QAC1C;AACA,YAAI,CAAC,WAAW,CAAC,OAAO;AACpB,0BAAgB,OAAO,SAAS;AAChC,0BAAgB,QAAQ;AACxB,uBAAa,MAAM,KAAK,eAAe;AACvC,uBAAa,KAAK,KAAK,eAAe;AAAA,QAC1C;AACA,eAAO;AAAA,MACX,CAAC;AACD,aAAO;AAAA,IACX;AAgBA,QAAM,yBAAyB,CAAC,WAAW,WAAW,kBAAkB,OAAO,oBAAoB,WAAW,OAAO,cAAc,GAAG,YAAY,CAAC,MAAM;AACrJ,UAAI,YAAY,CAAC;AAEjB,UAAI,OAAO,cAAc,YAAY,OAAO,cAAc,UAAU;AAChE,oBAAY,KAAK,UAAU,UAAU,UAAU,GAAG,UAAU,UAAU,GAAG;AAAA,UACrE,gBAAgB;AAAA,UAChB,kBAAkB;AAAA,UAClB,YAAY;AAAA,QAChB,CAAC;AAAA,MACL,OACK;AACD,oBAAY,KAAK,SAAS,WAAW,SAAS;AAAA,MAClD;AACA,UAAI,kBAAkB;AACtB,UAAI,iBAAiB;AACrB,UAAI,kBAAkB,CAAC;AACvB,UAAI,UAAU;AACd,YAAM,YAAY,CAAC;AACnB,YAAM,oBAAoB,CAAC;AAC3B,YAAM,qBAAqB,CAAC,OAAO,WAAW,OAAO,SAAS,0BAA0B;AACpF,cAAM,QAAQ,eAAe,KAAK;AAClC,eAAO,MACF,IAAI,CAAC,MAAM,cAAc;AAC1B,gBAAM,OAAO,CAAC;AACd,gBAAM,QAAQ,CAAC;AACf,cAAI,kBAAkB,SAAS,GAAG,SAAS,IAAI,SAAS,EAAE,KACrD,yBAAyB,cAAc,GAAI;AAC5C,mBAAO;AAAA,UACX;AACA,cAAI,SAAS,SAAS;AAClB,gBAAI,gBAAgB;AACpB,gBAAI,SAAS;AACT,gCAAkB;AAClB,mBAAK,aAAa;AAClB,mBAAK,OAAO,SAAS;AACrB,mBAAK,QAAQ,QAAQ;AAKrB,oBAAM,WAAW,UAAU,YAAY,CAAC;AACxC,kBAAI,YAAY,SAAS,OAAO;AAC5B,sBAAM,gBAAgB,eAAe,SAAS,KAAK,EAAE,SAAS;AAC9D,oBAAI,eAAe;AACf,wBAAM,mBAAmB,mBAAmB,eAAe,WAAW,MAAM,OAAO,IAAI;AACvF,wBAAM,EAAE,OAAO,YAAY,YAAY,KAAM,IAAI,iBAAiB,CAAC,EAAE;AAIrE,oCAAkB,KAAK,GAAG,YAAY,CAAC,IAAI,SAAS,EAAE;AACtD,wBAAM,aAAa;AACnB,sBAAI,KAAK,UAAU,YAAY;AAE3B,oCAAgB;AAChB,0BAAM,OAAO;AACb,yBAAK,OAAO;AACZ,0BAAM,QAAQ;AAAA,kBAClB,OACK;AACD,0BAAM,OAAO;AAGb,wBAAI,iBAAiB;AACjB,4BAAM,QAAQ;AAAA,oBAClB,OACK;AACD,4BAAM,eAAe,YAAY,MAAM,YAAY,iBAAiB;AACpE,4BAAM,QAAQ,aAAa;AAC3B,2BAAK,QAAQ,aAAa;AAAA,oBAC9B;AAAA,kBACJ;AAAA,gBACJ;AAAA,cACJ;AAAA,YACJ,OACK;AACD,iCAAmB;AACnB,oBAAM,aAAa;AACnB,oBAAM,OAAO,SAAS;AACtB,oBAAM,QAAQ;AAAA,YAClB;AACA,gBAAI,iBAAiB,CAAC,uBAAuB;AACzC,kBAAI,CAAC,UAAU,SAAS,OAAO,GAAG;AAC9B,0BAAU,KAAK,OAAO;AAAA,cAC1B;AAAA,YACJ;AAAA,UACJ,OACK;AACD,8BAAkB;AAClB,+BAAmB;AACnB,iBAAK,aAAa;AAClB,iBAAK,OAAO,SAAS;AACrB,iBAAK,QAAQ;AACb,kBAAM,aAAa;AACnB,kBAAM,OAAO,SAAS;AACtB,kBAAM,QAAQ;AAAA,UAClB;AACA,eAAK,cAAc,QAAQ,cAAc,SAAS,SAAS,UAAU,SAAS,KAAK,KAAK,UAAU,EAAE,OAAO,cAAc,QAAQ,cAAc,SAAS,SAAS,UAAU,SAAS,KAAK,MAAM,UAAU,EAAE,MAAM,CAAC,UAAU,SAAS,OAAO,GAAG;AAC3O,sBAAU,KAAK,OAAO;AAAA,UAC1B;AACA,cAAI,CAAC,uBAAuB;AACxB,uBAAW;AAAA,UACf;AACA,iBAAO,EAAE,OAAO,KAAK;AAAA,QACzB,CAAC,EACI,OAAO,OAAO;AAAA,MACvB;AACA,gBAAU,QAAQ,CAAC,EAAE,OAAO,SAAS,MAAM,GAAG,UAAU;AACpD,0BAAkB;AAAA,UACd,GAAG;AAAA,UACH,GAAG,mBAAmB,OAAO,OAAO,OAAO,OAAO;AAAA,QACtD;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,QACH;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AACA,YAAQ,yBAAyB;AAAA;AAAA;;;ACnOjC;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,sBAAsB;AAC9B,aAAS,oBAAoB,iBAAiB,WAAW,YAAY;AACjE,UAAI,gBAAgB;AACpB,UAAI;AACJ,UAAI,aAAa,CAAC;AAClB,UAAI,SAAS,CAAC;AACd,sBAAgB,QAAQ,CAAC,MAAM,cAAc;AACzC,cAAM,aAAa,UAAU,KAAK,cAAY,YAAY,YAAY,cAAc,YAAY,YAAY,UAAU;AACtH,YAAI,CAAC,cAAc,gBAAgB,QAAW;AAE1C,yBAAe;AAAA,YACX,OAAO;AAAA,YACP,WAAW;AAAA,YACX,SAAS;AAAA,YACT,OAAO;AAAA,UACX;AACA,iBAAO,KAAK,YAAY;AACxB,qBAAW,SAAS,IAAI,aAAa;AACrC;AAAA,QACJ,WACS,CAAC,YAAY;AAElB,uBAAa,UAAU;AACvB,uBAAa;AACb,qBAAW,SAAS,IAAI,aAAa;AAAA,QACzC,OACK;AAED,yBAAe;AAAA,QACnB;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,QACH;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AACA,YAAQ,sBAAsB;AAAA;AAAA;;;ACtC9B;AAAA;AAAA;AAAA;AAIA,SAAS,QAAQ,OAAO,QAAQ;AAC5B,MAAI,UAAU,QAAQ;AAClB,WAAO;AAAA,EACX;AACA,MAAI,UAAU,KAAK,KAAK,UAAU,MAAM,GAAG;AACvC,WAAO;AAAA,EACX;AACA,SAAO;AACX;AACA,SAAS,eAAe,WAAW,YAAY;AAC3C,MAAI,UAAU,WAAW,WAAW,QAAQ;AACxC,WAAO;AAAA,EACX;AACA,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACvC,QAAI,CAAC,QAAQ,UAAU,CAAC,GAAG,WAAW,CAAC,CAAC,GAAG;AACvC,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;AAEA,SAAS,WAAW,UAAUC,UAAS;AACnC,MAAIA,aAAY,QAAQ;AAAE,IAAAA,WAAU;AAAA,EAAgB;AACpD,MAAI,QAAQ;AACZ,WAAS,WAAW;AAChB,QAAI,UAAU,CAAC;AACf,aAAS,KAAK,GAAG,KAAK,UAAU,QAAQ,MAAM;AAC1C,cAAQ,EAAE,IAAI,UAAU,EAAE;AAAA,IAC9B;AACA,QAAI,SAAS,MAAM,aAAa,QAAQA,SAAQ,SAAS,MAAM,QAAQ,GAAG;AACtE,aAAO,MAAM;AAAA,IACjB;AACA,QAAI,aAAa,SAAS,MAAM,MAAM,OAAO;AAC7C,YAAQ;AAAA,MACJ;AAAA,MACA,UAAU;AAAA,MACV,UAAU;AAAA,IACd;AACA,WAAO;AAAA,EACX;AACA,WAAS,QAAQ,SAAS,QAAQ;AAC9B,YAAQ;AAAA,EACZ;AACA,SAAO;AACX;AAhDA,IAAI;AAAJ;AAAA;AAAA,IAAI,YAAY,OAAO,SACnB,SAAS,SAAS,OAAO;AACrB,aAAO,OAAO,UAAU,YAAY,UAAU;AAAA,IAClD;AAAA;AAAA;;;ACHJ;AAAA;AACA,QAAI,kBAAmB,WAAQ,QAAK,oBAAqB,OAAO,SAAU,SAAS,GAAGC,IAAG,GAAG,IAAI;AAC5F,UAAI,OAAO,OAAW,MAAK;AAC3B,UAAI,OAAO,OAAO,yBAAyBA,IAAG,CAAC;AAC/C,UAAI,CAAC,SAAS,SAAS,OAAO,CAACA,GAAE,aAAa,KAAK,YAAY,KAAK,eAAe;AACjF,eAAO,EAAE,YAAY,MAAM,KAAK,WAAW;AAAE,iBAAOA,GAAE,CAAC;AAAA,QAAG,EAAE;AAAA,MAC9D;AACA,aAAO,eAAe,GAAG,IAAI,IAAI;AAAA,IACrC,IAAM,SAAS,GAAGA,IAAG,GAAG,IAAI;AACxB,UAAI,OAAO,OAAW,MAAK;AAC3B,QAAE,EAAE,IAAIA,GAAE,CAAC;AAAA,IACf;AACA,QAAI,qBAAsB,WAAQ,QAAK,uBAAwB,OAAO,SAAU,SAAS,GAAG,GAAG;AAC3F,aAAO,eAAe,GAAG,WAAW,EAAE,YAAY,MAAM,OAAO,EAAE,CAAC;AAAA,IACtE,IAAK,SAAS,GAAG,GAAG;AAChB,QAAE,SAAS,IAAI;AAAA,IACnB;AACA,QAAI,eAAgB,WAAQ,QAAK,gBAAiB,SAAU,KAAK;AAC7D,UAAI,OAAO,IAAI,WAAY,QAAO;AAClC,UAAI,SAAS,CAAC;AACd,UAAI,OAAO;AAAM,iBAAS,KAAK,IAAK,KAAI,MAAM,aAAa,OAAO,UAAU,eAAe,KAAK,KAAK,CAAC,EAAG,iBAAgB,QAAQ,KAAK,CAAC;AAAA;AACvI,yBAAmB,QAAQ,GAAG;AAC9B,aAAO;AAAA,IACX;AACA,QAAI,kBAAmB,WAAQ,QAAK,mBAAoB,SAAU,KAAK;AACnE,aAAQ,OAAO,IAAI,aAAc,MAAM,EAAE,WAAW,IAAI;AAAA,IAC5D;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,YAAQ,aAAa,QAAQ,mBAAmB;AAChD,QAAM,gBAAgB;AACtB,QAAM,QAAQ,aAAa,eAAgB;AAC3C,QAAM,eAAe,gBAAgB,oBAAqB;AAC1D,QAAM,kBAAkB;AACxB,WAAO,eAAe,SAAS,cAAc,EAAE,YAAY,MAAM,KAAK,WAAY;AAAE,aAAO,gBAAgB;AAAA,IAAY,EAAE,CAAC;AAC1H,QAAM,WAAW,gBAAgB,gBAAmB;AACpD,QAAM,0BAA0B;AAChC,QAAM,IAAI;AACV,QAAM,UAAU,EAAE,WAAW;AAC7B,QAAI;AACJ,KAAC,SAAUC,mBAAkB;AACzB,MAAAA,kBAAiB,MAAM,IAAI;AAC3B,MAAAA,kBAAiB,OAAO,IAAI;AAAA,IAChC,GAAG,qBAAqB,QAAQ,mBAAmB,mBAAmB,CAAC,EAAE;AACzE,QAAM,aAAN,cAAyB,MAAM,UAAU;AAAA,MACrC,YAAY,OAAO;AACf,cAAM,KAAK;AAKX,aAAK,kBAAkB,MAAM;AACzB,cAAI,KAAK,MAAM,eAAe,SAAS,GAAG;AACtC,iBAAK,SAAS;AAAA,cACV,gBAAgB,CAAC;AAAA,YACrB,CAAC;AACD,mBAAO;AAAA,UACX;AACA,iBAAO;AAAA,QACX;AAKA,aAAK,gBAAgB,CAAC,OAAO;AACzB,gBAAM,YAAY,KAAK,MAAM,eAAe,MAAM;AAClD,oBAAU,KAAK,EAAE;AACjB,eAAK,SAAS;AAAA,YACV,gBAAgB;AAAA,UACpB,CAAC;AAAA,QACL;AAOA,aAAK,gBAAgB,QAAQ,SAAS,OAAO;AAO7C,aAAK,yBAAyB,CAAC,OAAO;AAClC,cAAI,KAAK,MAAM,mBAAmB;AAC9B,mBAAO,CAAC,MAAM,KAAK,MAAM,kBAAkB,IAAI,CAAC;AAAA,UACpD;AACA,iBAAO,MAAM;AAAA,UAAE;AAAA,QACnB;AAOA,aAAK,iBAAiB,CAAC,WAAW,aAAa;AAC3C,iBAAO,UAAU,IAAI,CAAC,UAAU,MAAM;AAClC,oBAAS,GAAG,cAAc,KAAK,QAAQ,EAAE,YAAY,GAAG,aAAa,SAAS,KAAK,OAAO,UAAU;AAAA,cAC5F,CAAC,KAAK,OAAO,SAAS,GAAG,SAAS,SAAS,gBAAgB,SAAS;AAAA,cACpE,CAAC,KAAK,OAAO,WAAW,GAAG,SAAS,SAAS,gBAAgB,SAAS;AAAA,YAC1E,CAAC,GAAG,UAAU,WAAW,SAAS,SAAS,KAAK,IAAI,SAAS,MAAM,GAAG,CAAC;AAAA,UAC/E,CAAC;AAAA,QACL;AAcA,aAAK,aAAa,CAAC,YAAY,MAAM,QAAQ,OAAO,sBAAsB,qBAAqB;AAC3F,gBAAM,qBAAqB,GAAG,MAAM,IAAI,UAAU;AAClD,gBAAM,+BAA+B,GAAG,gBAAgB,IAAI,oBAAoB;AAChF,gBAAM,gBAAgB,KAAK,MAAM,eAAe,SAAS,kBAAkB,KACvE,KAAK,MAAM,eAAe,SAAS,4BAA4B;AACnE,gBAAM,QAAQ,SAAS,gBAAgB,SAAS;AAChD,gBAAM,UAAU,SAAS,gBAAgB,SAAS;AAClD,gBAAM,UAAU,SAAS,gBAAgB,SAAS;AAClD,cAAI;AACJ,cAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,sBAAU,KAAK,eAAe,OAAO,KAAK,MAAM,aAAa;AAAA,UACjE,WACS,KAAK,MAAM,eAAe;AAC/B,sBAAU,KAAK,MAAM,cAAc,KAAK;AAAA,UAC5C,OACK;AACD,sBAAU;AAAA,UACd;AACA,kBAAS,GAAG,cAAc,MAAM,MAAM,UAAU,EAAE,UAAU,CAAC,CAAC,KAAK,MAAM,oBAAqB,GAAG,cAAc,KAAK,MAAM,EAAE,SAAS,cAAc,KAAK,uBAAuB,kBAAkB,GAAG,YAAY,GAAG,aAAa,SAAS,KAAK,OAAO,QAAQ;AAAA,YAC7O,CAAC,KAAK,OAAO,WAAW,GAAG,CAAC;AAAA,YAC5B,CAAC,KAAK,OAAO,SAAS,GAAG;AAAA,YACzB,CAAC,KAAK,OAAO,WAAW,GAAG;AAAA,YAC3B,CAAC,KAAK,OAAO,WAAW,GAAG;AAAA,YAC3B,CAAC,KAAK,OAAO,iBAAiB,GAAG;AAAA,UACrC,CAAC,GAAG,WAAW,GAAG,cAAc,KAAK,OAAO,EAAE,WAAW,KAAK,OAAO,YAAY,UAAU,WAAW,CAAC,EAAE,CAAC,GAAI,CAAC,KAAK,MAAM,aAAa,CAAC,KAAK,MAAM,oBAAqB,GAAG,cAAc,KAAK,MAAM,EAAE,SAAS,wBAC3M,KAAK,uBAAuB,4BAA4B,GAAG,YAAY,GAAG,aAAa,SAAS,KAAK,OAAO,QAAQ;AAAA,YACpH,CAAC,KAAK,OAAO,WAAW,GAAG,CAAC;AAAA,YAC5B,CAAC,KAAK,OAAO,SAAS,GAAG;AAAA,YACzB,CAAC,KAAK,OAAO,WAAW,GAAG;AAAA,YAC3B,CAAC,KAAK,OAAO,WAAW,GAAG;AAAA,YAC3B,CAAC,KAAK,OAAO,iBAAiB,GAAG;AAAA,UACrC,CAAC,GAAG,WAAW,GAAG,cAAc,KAAK,OAAO,EAAE,WAAW,KAAK,OAAO,YAAY,UAAU,qBAAqB,CAAC,EAAE,CAAC,GAAI,KAAK,MAAM,eACjI,KAAK,MAAM,aAAa;AAAA,YACtB;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,QAAQ,KAAK;AAAA,UACjB,CAAC,IACC,MAAM,CAAC,KAAK,MAAM,gBAAiB,GAAG,cAAc,KAAK,MAAM,EAAE,YAAY,GAAG,aAAa,SAAS,KAAK,OAAO,QAAQ;AAAA,YACxH,CAAC,KAAK,OAAO,SAAS,GAAG,CAAC;AAAA,YAC1B,CAAC,KAAK,OAAO,SAAS,GAAG;AAAA,YACzB,CAAC,KAAK,OAAO,WAAW,GAAG;AAAA,YAC3B,CAAC,KAAK,OAAO,WAAW,GAAG;AAAA,YAC3B,CAAC,KAAK,OAAO,eAAe,GAAG;AAAA,UACnC,CAAC,GAAG,WAAW,GAAG,cAAc,MAAM,OAAO,EAAE,UAAU,CAAC,SAAS,KAAK,WAAW,GAAG,EAAE,CAAC,EAAE,CAAC,IAAK,GAAG,cAAc,KAAK,MAAM,EAAE,YAAY,GAAG,aAAa,SAAS,KAAK,OAAO,SAAS;AAAA,YACrL,CAAC,KAAK,OAAO,SAAS,GAAG,CAAC;AAAA,YAC1B,CAAC,KAAK,OAAO,SAAS,GAAG;AAAA,YACzB,CAAC,KAAK,OAAO,WAAW,GAAG;AAAA,YAC3B,CAAC,KAAK,OAAO,WAAW,GAAG;AAAA,YAC3B,CAAC,KAAK,OAAO,eAAe,GAAG;AAAA,UACnC,CAAC,GAAG,WAAW,GAAG,cAAc,KAAK,OAAO,EAAE,WAAW,KAAK,OAAO,aAAa,UAAU,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;AAAA,QAC5H;AASA,aAAK,kBAAkB,CAAC,EAAE,MAAM,MAAM,GAAG,UAAU;AAC/C,kBAAS,GAAG,cAAc,MAAM,MAAM,EAAE,WAAW,KAAK,OAAO,MAAM,UAAU,CAAC,KAAK,WAAW,KAAK,YAAY,KAAK,MAAM,iBAAiB,MAAM,KAAK,KAAK,GAAG,KAAK,WAAW,MAAM,YAAY,MAAM,MAAM,iBAAiB,OAAO,MAAM,KAAK,CAAC,EAAE,GAAG,KAAK;AAAA,QAChQ;AASA,aAAK,mBAAmB,CAAC,EAAE,MAAM,MAAM,GAAG,UAAU;AAChD,cAAI;AACJ,cAAI,KAAK,SAAS,gBAAgB,SAAS,WAAW,MAAM,SAAS,gBAAgB,SAAS,OAAO;AACjG,oBAAS,GAAG,cAAc,MAAM,MAAM,UAAU,EAAE,UAAU,EAAE,GAAG,cAAc,KAAK,MAAM,EAAE,WAAW,KAAK,OAAO,MAAM,UAAU,KAAK,WAAW,KAAK,YAAY,KAAK,MAAM,iBAAiB,MAAM,KAAK,OAAO,IAAI,EAAE,CAAC,IAAI,GAAG,cAAc,KAAK,MAAM,EAAE,WAAW,KAAK,OAAO,MAAM,UAAU,KAAK,WAAW,MAAM,MAAM,MAAM,iBAAiB,OAAO,MAAM,OAAO,MAAM,UAAU,EAAE,CAAC,CAAC,EAAE,GAAG,KAAK;AAAA,UAC3Y;AACA,cAAI,KAAK,SAAS,gBAAgB,SAAS,SAAS;AAChD,sBAAU,KAAK,WAAW,KAAK,YAAY,KAAK,MAAM,iBAAiB,MAAM,KAAK,OAAO,IAAI;AAAA,UACjG;AACA,cAAI,KAAK,SAAS,gBAAgB,SAAS,SAAS;AAChD,sBAAU,KAAK,WAAW,KAAK,YAAY,KAAK,MAAM,iBAAiB,MAAM,KAAK,OAAO,MAAM,YAAY,iBAAiB,KAAK;AAAA,UACrI;AACA,cAAI,MAAM,SAAS,gBAAgB,SAAS,OAAO;AAC/C,sBAAU,KAAK,WAAW,MAAM,MAAM,MAAM,iBAAiB,OAAO,MAAM,OAAO,MAAM,UAAU;AAAA,UACrG;AACA,kBAAS,GAAG,cAAc,KAAK,MAAM,EAAE,WAAW,KAAK,OAAO,MAAM,UAAU,QAAQ,GAAG,KAAK;AAAA,QAClG;AAMA,aAAK,oBAAoB,CAAC,OAAO,MAAM,KAAK,cAAc,EAAE;AAU5D,aAAK,6BAA6B,CAAC,KAAK,aAAa,qBAAqB,yBAAyB;AAC/F,gBAAM,EAAE,iBAAiB,UAAU,IAAI,KAAK;AAC5C,gBAAM,UAAU,KAAK,MAAM,0BAA2B,KAAK,MAAM,wBAAwB,KAAK,qBAAqB,oBAAoB,KAAO,GAAG,cAAc,MAAM,OAAO,EAAE,WAAW,KAAK,OAAO,iBAAiB,UAAU,CAAC,WAAW,KAAK,YAAY,EAAE,CAAC;AAChQ,gBAAM,WAAY,GAAG,cAAc,KAAK,MAAM,EAAE,WAAW,GAAG,cAAc,KAAK,KAAK,EAAE,SAAS,KAAK,kBAAkB,WAAW,GAAG,UAAU,GAAG,UAAU,QAAQ,CAAC,EAAE,CAAC;AACzK,gBAAM,kCAAkC,CAAC,aAAa,CAAC;AACvD,kBAAS,GAAG,cAAc,MAAM,MAAM,EAAE,WAAW,KAAK,OAAO,UAAU,UAAU,CAAC,CAAC,oBAAoB,GAAG,cAAc,KAAK,MAAM,EAAE,WAAW,KAAK,OAAO,eAAe,CAAC,GAAG,KAAK,MAAM,gBAAiB,GAAG,cAAc,KAAK,MAAM,EAAE,WAAW,KAAK,OAAO,eAAe,CAAC,IAAK,OAAO,GAAG,cAAc,KAAK,MAAM,EAAE,YAAY,GAAG,aAAa,SAAS;AAAA,YACjV,CAAC,KAAK,OAAO,cAAc,GAAG;AAAA,UAClC,CAAC,EAAE,CAAC,GAAG,mCAAoC,GAAG,cAAc,MAAM,MAAM,UAAU,EAAE,UAAU,EAAE,GAAG,cAAc,KAAK,MAAM,CAAC,CAAC,GAAG,OAAO,EAAE,CAAC,KAAO,GAAG,cAAc,MAAM,MAAM,UAAU,EAAE,UAAU,CAAC,SAAS,KAAK,MAAM,gBAAgB,GAAG,cAAc,KAAK,MAAM,CAAC,CAAC,IAAI,OAAO,GAAG,cAAc,KAAK,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,IAAK,GAAG,cAAc,KAAK,MAAM,CAAC,CAAC,IAAI,GAAG,cAAc,KAAK,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,GAAG,mBAAmB,IAAI,oBAAoB,EAAE;AAAA,QAChc;AAIA,aAAK,aAAa,MAAM;AACpB,gBAAM,EAAE,UAAU,UAAU,WAAW,iBAAiB,eAAe,YAAa,IAAI,KAAK;AAC7F,gBAAM,EAAE,iBAAiB,UAAU,KAAK,GAAG,gBAAgB,wBAAwB,UAAU,UAAU,iBAAiB,eAAe,aAAa,KAAK,MAAM,eAAe;AAC9K,gBAAM,aAAa,KAAK,MAAM,4BAA4B,IACpD,IACA,KAAK,MAAM,KAAK,MAAM,yBAAyB;AACrD,gBAAM,EAAE,YAAY,OAAO,KAAK,GAAG,wBAAwB,qBAAqB,iBAAiB,WAAW,UAAU;AACtH,iBAAO,gBAAgB,IAAI,CAAC,MAAM,cAAc;AAC5C,gBAAI,KAAK,MAAM,cAAc;AACzB,oBAAM,aAAa,WAAW,SAAS;AACvC,kBAAI,eAAe,QAAW;AAC1B,sBAAM,kBAAkB,OAAO,UAAU,EAAE,YAAY;AACvD,oBAAI,CAAC,KAAK,MAAM,eAAe,SAAS,UAAU,KAAK,iBAAiB;AACpE,0BAAS,GAAG,cAAc,KAAK,MAAM,UAAU,EAAE,UAAU,KAAK,2BAA2B,OAAO,UAAU,EAAE,OAAO,YAAY,KAAK,KAAK,YAAY,KAAK,MAAM,UAAU,EAAE,GAAG,SAAS;AAAA,gBAC9L,WACS,CAAC,KAAK,MAAM,eAAe,SAAS,UAAU,GAAG;AACtD,yBAAO;AAAA,gBACX;AAAA,cACJ;AAAA,YACJ;AACA,kBAAM,YAAY,YACZ,KAAK,gBAAgB,MAAM,SAAS,IACpC,KAAK,iBAAiB,MAAM,SAAS;AAC3C,mBAAO;AAAA,UACX,CAAC;AAAA,QACL;AACA,aAAK,SAAS,MAAM;AAChB,gBAAM,EAAE,UAAU,UAAU,cAAc,WAAW,YAAY,WAAW,iBAAiB,aAAa,MAAO,IAAI,KAAK;AAC1H,cAAI,KAAK,MAAM,kBAAkB,gBAAgB,WAAW,MAAM;AAC9D,gBAAI,OAAO,aAAa,YAAY,OAAO,aAAa,UAAU;AAC9D,oBAAM,MAAM,6CAA6C;AAAA,YAC7D;AAAA,UACJ;AACA,eAAK,SAAS,KAAK,cAAc,KAAK,MAAM,QAAQ,cAAc,KAAK;AACvE,gBAAM,QAAQ,KAAK,WAAW;AAC9B,cAAI,qBAAqB,kBAAkB,IAAI;AAC/C,cAAI,sBAAsB,kBAAkB,IAAI;AAChD,cAAI,aAAa;AACb,kCAAsB;AACtB,mCAAuB;AAAA,UAC3B;AACA,gBAAM,kBAAkB,KAAK,MAAM,eAAe,IAAI;AACtD,gBAAM,SAAS,aAAa,gBAAiB,GAAG,cAAc,MAAM,MAAM,EAAE,UAAU,EAAE,GAAG,cAAc,KAAK,MAAM,EAAE,UAAU,YAAY,qBAAqB,uBACjJ,iBAAiB,WAAW,KAAK,OAAO,YAAY,WAAW,GAAG,cAAc,KAAK,OAAO,EAAE,WAAW,KAAK,OAAO,aAAa,UAAU,UAAU,CAAC,EAAE,CAAC,GAAG,cAAe,GAAG,cAAc,KAAK,MAAM,EAAE,SAAS,qBAAqB,iBAAiB,WAAW,KAAK,OAAO,YAAY,WAAW,GAAG,cAAc,KAAK,OAAO,EAAE,WAAW,KAAK,OAAO,aAAa,UAAU,WAAW,CAAC,EAAE,CAAC,CAAE,EAAE,CAAC;AACxZ,kBAAS,GAAG,cAAc,KAAK,SAAS,EAAE,YAAY,GAAG,aAAa,SAAS,KAAK,OAAO,eAAe;AAAA,YAClG,CAAC,KAAK,OAAO,SAAS,GAAG;AAAA,UAC7B,CAAC,GAAG,WAAW,GAAG,cAAc,MAAM,SAAS,EAAE,UAAU,CAAC,OAAO,KAAK,EAAE,CAAC,EAAE,CAAC;AAAA,QACtF;AACA,aAAK,QAAQ;AAAA,UACT,gBAAgB,CAAC;AAAA,QACrB;AAAA,MACJ;AAAA,IACJ;AACA,eAAW,eAAe;AAAA,MACtB,UAAU;AAAA,MACV,UAAU;AAAA,MACV,WAAW;AAAA,MACX,gBAAgB,CAAC;AAAA,MACjB,iBAAiB;AAAA,MACjB,eAAe,gBAAgB,WAAW;AAAA,MAC1C,QAAQ,CAAC;AAAA,MACT,iBAAiB;AAAA,MACjB,aAAa;AAAA,MACb,2BAA2B;AAAA,MAC3B,cAAc;AAAA,MACd,cAAc;AAAA,MACd,aAAa;AAAA,MACb,OAAO;AAAA,IACX;AACA,YAAQ,UAAU;AAAA;AAAA;",
  "names": ["Diff", "prototype", "diff", "oldString", "newString", "options", "callback", "self", "done", "value", "setTimeout", "undefined", "castInput", "removeEmpty", "tokenize", "newLen", "length", "oldLen", "editLength", "maxEditLength", "Math", "min", "maxExecutionTime", "timeout", "Infinity", "abortAfterTimestamp", "Date", "now", "bestPath", "oldPos", "lastComponent", "newPos", "extractCommon", "join", "count", "minDiagonalToConsider", "maxDiagonalToConsider", "execEditLength", "diagonalPath", "max", "basePath", "removePath", "addPath", "canAdd", "addPathNewPos", "canRemove", "addToPath", "buildValues", "useLongestToken", "exec", "ret", "path", "added", "removed", "oldPosInc", "last", "previousComponent", "commonCount", "equals", "left", "right", "comparator", "ignoreCase", "toLowerCase", "array", "i", "push", "split", "chars", "components", "nextComponent", "reverse", "componentPos", "componentLen", "component", "slice", "map", "oldValue", "tmp", "finalComponent", "pop", "characterDiff", "Diff", "diffChars", "oldStr", "newStr", "options", "diff", "generateOptions", "options", "defaults", "callback", "name", "hasOwnProperty", "extendedWordChars", "reWhitespace", "wordDiff", "Diff", "equals", "left", "right", "options", "ignoreCase", "toLowerCase", "ignoreWhitespace", "test", "tokenize", "value", "tokens", "split", "i", "length", "splice", "diffWords", "oldStr", "newStr", "generateOptions", "diff", "diffWordsWithSpace", "lineDiff", "Diff", "tokenize", "value", "options", "stripTrailingCr", "replace", "retLines", "linesAndNewlines", "split", "length", "pop", "i", "line", "newlineIsToken", "ignoreWhitespace", "trim", "push", "diffLines", "oldStr", "newStr", "callback", "diff", "diffTrimmedLines", "generateOptions", "sentenceDiff", "Diff", "tokenize", "value", "split", "diffSentences", "oldStr", "newStr", "callback", "diff", "cssDiff", "Diff", "tokenize", "value", "split", "diffCss", "oldStr", "newStr", "callback", "diff", "objectPrototypeToString", "Object", "prototype", "toString", "jsonDiff", "Diff", "useLongestToken", "tokenize", "lineDiff", "castInput", "value", "options", "undefinedReplacement", "stringifyReplacer", "k", "v", "JSON", "stringify", "canonicalize", "equals", "left", "right", "call", "replace", "diffJson", "oldObj", "newObj", "diff", "obj", "stack", "replacementStack", "replacer", "key", "i", "length", "canonicalizedObj", "push", "Array", "pop", "toJSON", "sortedKeys", "hasOwnProperty", "sort", "arrayDiff", "Diff", "tokenize", "value", "slice", "join", "removeEmpty", "diffArrays", "oldArr", "newArr", "callback", "diff", "parsePatch", "uniDiff", "options", "diffstr", "split", "delimiters", "match", "list", "i", "parseIndex", "index", "push", "length", "line", "test", "header", "exec", "parseFileHeader", "hunks", "parseHunk", "strict", "Error", "JSON", "stringify", "fileHeader", "keyPrefix", "data", "fileName", "replace", "substr", "trim", "chunkHeaderIndex", "chunkHeaderLine", "chunkHeader", "hunk", "oldStart", "oldLines", "newStart", "newLines", "lines", "linedelimiters", "addCount", "removeCount", "indexOf", "operation", "start", "minLine", "maxLine", "wantForward", "backwardExhausted", "forwardExhausted", "localOffset", "iterator", "applyPatch", "source", "uniDiff", "options", "parsePatch", "Array", "isArray", "length", "Error", "lines", "split", "delimiters", "match", "hunks", "compareLine", "lineNumber", "line", "operation", "patchContent", "errorCount", "fuzzFactor", "minLine", "offset", "removeEOFNL", "addEOFNL", "hunkFits", "hunk", "toPos", "j", "content", "substr", "i", "maxLine", "oldLines", "localOffset", "oldStart", "iterator", "distanceIterator", "undefined", "diffOffset", "newLines", "delimiter", "linedelimiters", "splice", "previousOperation", "pop", "push", "_k", "join", "applyPatches", "currentIndex", "processIndex", "index", "complete", "loadFile", "err", "data", "updatedContent", "patched", "structuredPatch", "oldFileName", "newFileName", "oldStr", "newStr", "oldHeader", "newHeader", "options", "context", "diff", "diffLines", "push", "value", "lines", "contextLines", "map", "entry", "hunks", "oldRangeStart", "newRangeStart", "curRange", "oldLine", "newLine", "_loop", "i", "current", "replace", "split", "added", "removed", "prev", "slice", "length", "contextSize", "Math", "min", "hunk", "oldStart", "oldLines", "newStart", "newLines", "oldEOFNewline", "test", "newEOFNewline", "noNlBeforeAdds", "splice", "formatPatch", "Array", "isArray", "join", "ret", "apply", "createTwoFilesPatch", "createPatch", "fileName", "arrayEqual", "a", "b", "length", "arrayStartsWith", "array", "start", "i", "calcLineCount", "hunk", "calcOldNewLineCount", "lines", "oldLines", "newLines", "undefined", "merge", "mine", "theirs", "base", "loadPatch", "ret", "index", "newFileName", "fileNameChanged", "oldFileName", "oldHeader", "newHeader", "selectField", "hunks", "mineIndex", "theirsIndex", "mineOffset", "theirsOffset", "length", "mineCurrent", "oldStart", "Infinity", "theirsCurrent", "hunkBefore", "push", "cloneHunk", "mergedHunk", "Math", "min", "newStart", "mergeLines", "param", "test", "parsePatch", "Error", "structuredPatch", "patch", "conflict", "check", "offset", "mineLines", "theirOffset", "theirLines", "their", "insertLeading", "theirCurrent", "mutualChange", "collectChange", "removal", "insertTrailing", "myChanges", "theirChanges", "allRemoves", "arrayStartsWith", "skipRemoveSuperset", "arrayEqual", "swap", "collectContext", "merged", "insert", "line", "state", "operation", "matchChanges", "changes", "matchIndex", "contextChanges", "conflicted", "change", "match", "substr", "reduce", "prev", "removeChanges", "delta", "i", "changeContent", "forEach", "myCount", "theirCount", "reversePatch", "structuredPatch", "Array", "isArray", "map", "reverse", "oldFileName", "newFileName", "oldHeader", "newHeader", "hunks", "hunk", "oldLines", "newLines", "oldStart", "newStart", "linedelimiters", "lines", "l", "startsWith", "slice", "convertChangesToDMP", "changes", "ret", "change", "operation", "i", "length", "added", "removed", "push", "value", "convertChangesToXML", "changes", "ret", "i", "length", "change", "added", "push", "removed", "escapeHTML", "value", "join", "s", "n", "replace", "DiffType", "DiffMethod", "isEqual", "m", "LineNumberPrefix"]
}
