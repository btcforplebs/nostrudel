{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/database/database.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/database/common.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/utils.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/database/query-filter.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/database/query-misc.js", "../../node_modules/.pnpm/nostr-tools@2.7.2_typescript@5.6.2/node_modules/nostr-tools/lib/esm/kinds.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/database/ingest.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/debug.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/database/prune.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/cache/write-queue.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/cache/index-cache.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/lib/nanoid.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/relay/relay-core.js", "../../node_modules/.pnpm/nostr-idb@2.1.6_typescript@5.6.2/node_modules/nostr-idb/dist/relay/cache-relay.js"],
  "sourcesContent": ["import { deleteDB as idbDeleteDB, openDB as idbOpenDB, } from \"idb\";\nexport const NOSTR_IDB_NAME = \"nostr-idb\";\nexport const NOSTR_IDB_VERSION = 2;\nexport async function openDB(name = NOSTR_IDB_NAME, callbacks) {\n    return await idbOpenDB(name, NOSTR_IDB_VERSION, {\n        ...callbacks,\n        upgrade(db, oldVersion, newVersion, transaction, event) {\n            if (oldVersion === 1) {\n                db.deleteObjectStore(\"events\");\n                db.deleteObjectStore(\"used\");\n                // @ts-ignore\n                db.deleteObjectStore(\"seen\");\n            }\n            const events = db.createObjectStore(\"events\");\n            events.createIndex(\"id\", \"event.id\", { unique: true });\n            events.createIndex(\"pubkey\", \"event.pubkey\");\n            events.createIndex(\"kind\", \"event.kind\");\n            events.createIndex(\"created_at\", \"event.created_at\");\n            events.createIndex(\"tags\", \"tags\", { multiEntry: true });\n            const used = db.createObjectStore(\"used\", { keyPath: \"uid\" });\n            used.createIndex(\"date\", \"date\");\n            if (callbacks?.upgrade)\n                callbacks.upgrade(db, oldVersion, newVersion, transaction, event);\n        },\n    });\n}\nexport async function deleteDB(name = NOSTR_IDB_NAME, callbacks) {\n    return await idbDeleteDB(name, callbacks);\n}\nexport async function clearDB(db) {\n    await db.clear(\"events\");\n    await db.clear(\"used\");\n}\n", "const LETTERS = \"abcdefghijklmnopqrstuvwxyz\";\nexport const GENERIC_TAGS = (LETTERS + LETTERS.toUpperCase()).split(\"\");\n", "export function sortByDate(a, b) {\n    return b.created_at - a.created_at;\n}\n", "import { GENERIC_TAGS } from \"./common.js\";\nimport { sortByDate } from \"../utils.js\";\nexport function queryForPubkeys(db, authors = [], indexCache) {\n    const loaded = [];\n    const ids = new Set();\n    if (indexCache) {\n        for (const pubkey of authors) {\n            const cached = indexCache.getPubkeyIndex(pubkey);\n            if (cached) {\n                for (const id of cached)\n                    ids.add(id);\n                loaded.push(pubkey);\n            }\n        }\n    }\n    // all indexes where loaded from indexCache\n    if (loaded.length === authors.length)\n        return ids;\n    // load remaining indexes from db\n    const trans = db.transaction(\"events\", \"readonly\");\n    const objectStore = trans.objectStore(\"events\");\n    const index = objectStore.index(\"pubkey\");\n    const handleResults = (pubkey, result) => {\n        for (const id of result)\n            ids.add(id);\n        // add index to cache\n        if (indexCache)\n            indexCache.setPubkeyIndex(pubkey, new Set(result));\n    };\n    const promises = authors\n        .filter((p) => !loaded.includes(p))\n        .map((pubkey) => index.getAllKeys(pubkey).then((r) => handleResults(pubkey, r)));\n    trans.commit();\n    return Promise.all(promises).then(() => ids);\n}\nexport function queryForTag(db, tag, values, indexCache) {\n    const loaded = [];\n    const ids = new Set();\n    if (indexCache) {\n        for (const value of values) {\n            const cached = indexCache.getTagIndex(tag + value);\n            if (cached) {\n                for (const id of cached)\n                    ids.add(id);\n                loaded.push(value);\n            }\n        }\n    }\n    // all indexes where loaded from indexCache\n    if (loaded.length === values.length)\n        return ids;\n    // load remaining indexes from db\n    const trans = db.transaction(\"events\", \"readonly\");\n    const objectStore = trans.objectStore(\"events\");\n    const index = objectStore.index(\"tags\");\n    const handleResults = (value, result) => {\n        for (const id of result)\n            ids.add(id);\n        // add index to cache\n        if (indexCache)\n            indexCache.setTagIndex(tag + value, new Set(result));\n    };\n    const promises = values.map((v) => index.getAllKeys(tag + v).then((r) => handleResults(v, r)));\n    trans.commit();\n    return Promise.all(promises).then(() => ids);\n}\nexport function queryForKinds(db, kinds = [], indexCache) {\n    const loaded = [];\n    const ids = new Set();\n    // load from indexCache\n    if (indexCache) {\n        for (const kind of kinds) {\n            const cached = indexCache.getKindIndex(kind);\n            if (cached) {\n                for (const id of cached)\n                    ids.add(id);\n                loaded.push(kind);\n            }\n        }\n    }\n    // all indexes where loaded from indexCache\n    if (loaded.length === kinds.length)\n        return ids;\n    // load remaining indexes from db\n    const trans = db.transaction(\"events\", \"readonly\");\n    const index = trans.objectStore(\"events\").index(\"kind\");\n    const handleResults = (kind, result) => {\n        for (const id of result)\n            ids.add(id);\n        // add index to cache\n        if (indexCache)\n            indexCache.setKindIndex(kind, new Set(result));\n    };\n    const promises = kinds\n        .filter((k) => !loaded.includes(k))\n        .map((kind) => index.getAllKeys(kind).then((r) => handleResults(kind, r)));\n    trans.commit();\n    return Promise.all(promises).then(() => ids);\n}\nexport async function queryForTime(db, since, until) {\n    let range;\n    if (since !== undefined && until !== undefined)\n        range = IDBKeyRange.bound(since, until);\n    else if (since !== undefined)\n        range = IDBKeyRange.lowerBound(since);\n    else if (until !== undefined)\n        range = IDBKeyRange.upperBound(until);\n    else\n        throw new Error(\"Missing since or until\");\n    const ids = (await db.getAllKeysFromIndex(\"events\", \"created_at\", range)).reverse();\n    return ids;\n}\nexport async function getIdsForFilter(db, filter, indexCache) {\n    // search is not supported, return an empty set\n    if (filter.search)\n        return new Set();\n    if (filter.ids)\n        return new Set(filter.ids);\n    let ids = null;\n    const and = (iterable) => {\n        const set = iterable instanceof Set ? iterable : new Set(iterable);\n        if (!ids)\n            ids = set;\n        else\n            for (const id of ids)\n                if (!set.has(id))\n                    ids.delete(id);\n        return ids;\n    };\n    let timeFilterIds = null;\n    // query for time first if since is set\n    if (filter.since !== undefined) {\n        timeFilterIds = await queryForTime(db, filter.since, filter.until);\n        and(timeFilterIds);\n    }\n    for (const t of GENERIC_TAGS) {\n        const key = `#${t}`;\n        const values = filter[key];\n        if (values?.length)\n            and(await queryForTag(db, t, values, indexCache));\n    }\n    if (filter.authors)\n        and(await queryForPubkeys(db, filter.authors, indexCache));\n    if (filter.kinds)\n        and(await queryForKinds(db, filter.kinds, indexCache));\n    // query for time last if only until is set\n    if (filter.since === undefined && filter.until !== undefined) {\n        timeFilterIds = await queryForTime(db, filter.since, filter.until);\n        and(timeFilterIds);\n    }\n    // if the filter queried on time and has a limit. truncate the ids now\n    if (filter.limit && timeFilterIds) {\n        const limitIds = new Set();\n        for (const id of timeFilterIds) {\n            if (limitIds.size >= filter.limit)\n                break;\n            if (ids.has(id))\n                limitIds.add(id);\n        }\n        return limitIds;\n    }\n    if (ids === null)\n        throw new Error(\"Empty filter\");\n    return ids;\n}\nexport async function getIdsForFilters(db, filters, indexCache) {\n    if (filters.length === 0)\n        throw new Error(\"No Filters\");\n    let ids = new Set();\n    for (const filter of filters) {\n        const filterIds = await getIdsForFilter(db, filter, indexCache);\n        for (const id of filterIds)\n            ids.add(id);\n    }\n    return ids;\n}\nasync function loadEventsByUID(db, uids, filters, eventMap) {\n    const eventBuffer = [];\n    // load from in-memory event map\n    let remainingIds = [];\n    if (eventMap) {\n        for (const uid of uids) {\n            const event = eventMap.get(uid);\n            if (event)\n                eventBuffer.push(event);\n            else\n                remainingIds.push(uid);\n        }\n    }\n    else\n        remainingIds = uids;\n    const trans = db.transaction(\"events\", \"readonly\");\n    const objectStore = trans.objectStore(\"events\");\n    const handleEntry = (e) => e && eventBuffer.push(e.event);\n    const promises = Array.from(remainingIds).map((uid) => objectStore.get(uid).then(handleEntry));\n    trans.commit();\n    const sorted = await Promise.all(promises).then(() => eventBuffer.sort(sortByDate));\n    let minLimit = Infinity;\n    for (const filter of filters) {\n        if (filter.limit && filter.limit < minLimit)\n            minLimit = filter.limit;\n    }\n    if (sorted.length > minLimit)\n        sorted.length = minLimit;\n    return sorted;\n}\nexport async function getEventsForFilter(db, filter, indexCache, eventMap) {\n    const ids = await getIdsForFilter(db, filter, indexCache);\n    return await loadEventsByUID(db, Array.from(ids), [filter], eventMap);\n}\nexport async function getEventsForFilters(db, filters, indexCache, eventMap) {\n    const ids = await getIdsForFilters(db, filters, indexCache);\n    return await loadEventsByUID(db, Array.from(ids), filters, eventMap);\n}\nexport async function countEventsForFilter(db, filter, indexCache) {\n    const ids = await getIdsForFilter(db, filter, indexCache);\n    return ids.size;\n}\nexport async function countEventsForFilters(db, filters, indexCache) {\n    const ids = await getIdsForFilters(db, filters, indexCache);\n    return ids.size;\n}\n", "export async function getEventsFromAddressPointers(db, pointers) {\n    const trans = db.transaction(\"events\", \"readonly\");\n    const objectStore = trans.objectStore(\"events\");\n    const events = {};\n    const promises = pointers.map(async (pointer) => {\n        const key = `${pointer.kind}:${pointer.pubkey}:${pointer.identifier ?? \"\"}`;\n        const row = await objectStore.get(key);\n        if (row) {\n            const existing = events[key];\n            if (!existing || row.event.created_at > existing.created_at)\n                events[key] = row.event;\n        }\n    });\n    trans.commit();\n    const sorted = await Promise.all(promises).then(() => Object.values(events).sort((a, b) => b.created_at - a.created_at));\n    return sorted;\n}\nexport async function countEventsByPubkeys(db) {\n    let cursor = await db\n        .transaction(\"events\", \"readonly\")\n        .objectStore(\"events\")\n        .index(\"pubkey\")\n        .openKeyCursor();\n    if (!cursor)\n        return {};\n    const counts = {};\n    while (cursor) {\n        const pubkey = cursor.key;\n        counts[pubkey] = (counts[pubkey] || 0) + 1;\n        cursor = await cursor.continue();\n    }\n    return counts;\n}\nexport async function countEventsByKind(db) {\n    let cursor = await db\n        .transaction(\"events\", \"readonly\")\n        .objectStore(\"events\")\n        .index(\"kind\")\n        .openKeyCursor();\n    if (!cursor)\n        return {};\n    const counts = {};\n    while (cursor) {\n        const kind = cursor.key;\n        counts[kind] = (counts[kind] || 0) + 1;\n        cursor = await cursor.continue();\n    }\n    return counts;\n}\nexport function countEvents(db) {\n    return db.transaction(\"events\", \"readonly\").store.count();\n}\n", "// kinds.ts\nfunction isRegularKind(kind) {\n  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);\n}\nfunction isReplaceableKind(kind) {\n  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;\n}\nfunction isEphemeralKind(kind) {\n  return 2e4 <= kind && kind < 3e4;\n}\nfunction isParameterizedReplaceableKind(kind) {\n  return 3e4 <= kind && kind < 4e4;\n}\nfunction classifyKind(kind) {\n  if (isRegularKind(kind))\n    return \"regular\";\n  if (isReplaceableKind(kind))\n    return \"replaceable\";\n  if (isEphemeralKind(kind))\n    return \"ephemeral\";\n  if (isParameterizedReplaceableKind(kind))\n    return \"parameterized\";\n  return \"unknown\";\n}\nvar Metadata = 0;\nvar ShortTextNote = 1;\nvar RecommendRelay = 2;\nvar Contacts = 3;\nvar EncryptedDirectMessage = 4;\nvar EncryptedDirectMessages = 4;\nvar EventDeletion = 5;\nvar Repost = 6;\nvar Reaction = 7;\nvar BadgeAward = 8;\nvar GenericRepost = 16;\nvar ChannelCreation = 40;\nvar ChannelMetadata = 41;\nvar ChannelMessage = 42;\nvar ChannelHideMessage = 43;\nvar ChannelMuteUser = 44;\nvar OpenTimestamps = 1040;\nvar FileMetadata = 1063;\nvar LiveChatMessage = 1311;\nvar ProblemTracker = 1971;\nvar Report = 1984;\nvar Reporting = 1984;\nvar Label = 1985;\nvar CommunityPostApproval = 4550;\nvar JobRequest = 5999;\nvar JobResult = 6999;\nvar JobFeedback = 7e3;\nvar ZapGoal = 9041;\nvar ZapRequest = 9734;\nvar Zap = 9735;\nvar Highlights = 9802;\nvar Mutelist = 1e4;\nvar Pinlist = 10001;\nvar RelayList = 10002;\nvar BookmarkList = 10003;\nvar CommunitiesList = 10004;\nvar PublicChatsList = 10005;\nvar BlockedRelaysList = 10006;\nvar SearchRelaysList = 10007;\nvar InterestsList = 10015;\nvar UserEmojiList = 10030;\nvar FileServerPreference = 10096;\nvar NWCWalletInfo = 13194;\nvar LightningPubRPC = 21e3;\nvar ClientAuth = 22242;\nvar NWCWalletRequest = 23194;\nvar NWCWalletResponse = 23195;\nvar NostrConnect = 24133;\nvar HTTPAuth = 27235;\nvar Followsets = 3e4;\nvar Genericlists = 30001;\nvar Relaysets = 30002;\nvar Bookmarksets = 30003;\nvar Curationsets = 30004;\nvar ProfileBadges = 30008;\nvar BadgeDefinition = 30009;\nvar Interestsets = 30015;\nvar CreateOrUpdateStall = 30017;\nvar CreateOrUpdateProduct = 30018;\nvar LongFormArticle = 30023;\nvar DraftLong = 30024;\nvar Emojisets = 30030;\nvar Application = 30078;\nvar LiveEvent = 30311;\nvar UserStatuses = 30315;\nvar ClassifiedListing = 30402;\nvar DraftClassifiedListing = 30403;\nvar Date = 31922;\nvar Time = 31923;\nvar Calendar = 31924;\nvar CalendarEventRSVP = 31925;\nvar Handlerrecommendation = 31989;\nvar Handlerinformation = 31990;\nvar CommunityDefinition = 34550;\nexport {\n  Application,\n  BadgeAward,\n  BadgeDefinition,\n  BlockedRelaysList,\n  BookmarkList,\n  Bookmarksets,\n  Calendar,\n  CalendarEventRSVP,\n  ChannelCreation,\n  ChannelHideMessage,\n  ChannelMessage,\n  ChannelMetadata,\n  ChannelMuteUser,\n  ClassifiedListing,\n  ClientAuth,\n  CommunitiesList,\n  CommunityDefinition,\n  CommunityPostApproval,\n  Contacts,\n  CreateOrUpdateProduct,\n  CreateOrUpdateStall,\n  Curationsets,\n  Date,\n  DraftClassifiedListing,\n  DraftLong,\n  Emojisets,\n  EncryptedDirectMessage,\n  EncryptedDirectMessages,\n  EventDeletion,\n  FileMetadata,\n  FileServerPreference,\n  Followsets,\n  GenericRepost,\n  Genericlists,\n  HTTPAuth,\n  Handlerinformation,\n  Handlerrecommendation,\n  Highlights,\n  InterestsList,\n  Interestsets,\n  JobFeedback,\n  JobRequest,\n  JobResult,\n  Label,\n  LightningPubRPC,\n  LiveChatMessage,\n  LiveEvent,\n  LongFormArticle,\n  Metadata,\n  Mutelist,\n  NWCWalletInfo,\n  NWCWalletRequest,\n  NWCWalletResponse,\n  NostrConnect,\n  OpenTimestamps,\n  Pinlist,\n  ProblemTracker,\n  ProfileBadges,\n  PublicChatsList,\n  Reaction,\n  RecommendRelay,\n  RelayList,\n  Relaysets,\n  Report,\n  Reporting,\n  Repost,\n  SearchRelaysList,\n  ShortTextNote,\n  Time,\n  UserEmojiList,\n  UserStatuses,\n  Zap,\n  ZapGoal,\n  ZapRequest,\n  classifyKind,\n  isEphemeralKind,\n  isParameterizedReplaceableKind,\n  isRegularKind,\n  isReplaceableKind\n};\n", "import { kinds, validateEvent } from \"nostr-tools\";\nimport { GENERIC_TAGS } from \"./common.js\";\nimport { isParameterizedReplaceableKind, isReplaceableKind, } from \"nostr-tools/kinds\";\n/** Returns an events tags as an array of string for indexing */\nexport function getEventTags(event) {\n    return event.tags\n        .filter((t) => t.length >= 2 && t[0].length === 1 && GENERIC_TAGS.includes(t[0]))\n        .map((t) => t[0] + t[1]);\n}\n/** returns the events Unique ID */\nexport function getEventUID(event) {\n    if (kinds.isReplaceableKind(event.kind) ||\n        kinds.isParameterizedReplaceableKind(event.kind)) {\n        const d = event.tags.find((t) => t[0] === \"d\")?.[1];\n        return d\n            ? `${event.kind}:${event.pubkey}:${d}`\n            : `${event.kind}:${event.pubkey}`;\n    }\n    return event.id;\n}\nexport async function addEvents(db, events) {\n    // filter out invalid events\n    events = events.filter((event) => validateEvent(event));\n    const replaceableEvents = events.filter((e) => isReplaceableKind(e.kind) || isParameterizedReplaceableKind(e.kind));\n    const existingEvents = {};\n    if (replaceableEvents.length > 0) {\n        const readTransaction = db.transaction(\"events\", \"readonly\");\n        const promises = replaceableEvents.map((e) => {\n            const uid = getEventUID(e);\n            readTransaction.store\n                .get(uid)\n                .then((r) => r && (existingEvents[uid] = r.event.created_at));\n        });\n        readTransaction.commit();\n        await Promise.all(promises);\n    }\n    const writeTransaction = db.transaction(\"events\", \"readwrite\");\n    for (const event of events) {\n        const uid = getEventUID(event);\n        // if the event is replaceable, only write it if its newer\n        if (!existingEvents[uid] || event.created_at > existingEvents[uid]) {\n            writeTransaction.objectStore(\"events\").put({\n                event,\n                tags: getEventTags(event),\n            }, uid);\n        }\n    }\n    await writeTransaction.commit();\n}\nexport async function updateUsed(db, uids) {\n    const trans = db.transaction(\"used\", \"readwrite\");\n    const nowUnix = Math.floor(new Date().valueOf() / 1000);\n    for (const uid of uids) {\n        trans.objectStore(\"used\").put({\n            uid,\n            date: nowUnix,\n        });\n    }\n    await trans.commit();\n}\n", "import * as debug from \"debug\";\nexport const logger = debug.default(\"nostr-idb\");\n", "import { logger } from \"../debug.js\";\nimport { countEvents } from \"./query-misc.js\";\nconst log = logger.extend(\"prune\");\n/**\n * Prunes the database down based on when the event was last used\n * @param db the database\n * @param maxEvents the max number of events to leave in the db\n */\nexport async function pruneLastUsed(db, maxEvents, skip) {\n    const count = await countEvents(db);\n    if (count <= maxEvents)\n        return;\n    const diff = count - maxEvents;\n    if (diff <= 0)\n        return;\n    log(`Pruning database to ${maxEvents}`);\n    const used = (await db.getAll(\"used\")).sort((a, b) => a.date - b.date);\n    const eventsTransaction = db.transaction(\"events\", \"readwrite\");\n    const usedTransaction = db.transaction(\"used\", \"readwrite\");\n    const promises = [];\n    let i = diff;\n    while (i > 0) {\n        const entry = used.shift();\n        if (!entry)\n            break;\n        const uid = entry.uid;\n        if (skip) {\n            const row = await db.get(\"events\", uid);\n            if (row && skip(row.event))\n                continue;\n        }\n        promises.push(eventsTransaction.store.delete(uid));\n        promises.push(usedTransaction.store.delete(uid));\n        i--;\n    }\n    eventsTransaction.commit();\n    usedTransaction.commit();\n    await Promise.all(promises);\n    log(`Removed ${diff} old events`);\n}\n", "import { matchFilters } from \"nostr-tools\";\nimport { addEvents, getEventUID, updateUsed } from \"../database/ingest.js\";\nimport { logger } from \"../debug.js\";\nconst log = logger.extend(\"writeQueue\");\nexport class WriteQueue {\n    db;\n    queuedIds = new Set();\n    eventQueue = [];\n    lastUsedQueue = new Set();\n    constructor(db) {\n        this.db = db;\n    }\n    addEvent(event) {\n        if (this.queuedIds.has(event.id))\n            return;\n        this.eventQueue.push(event);\n        this.queuedIds.add(event.id);\n        this.useEvent(event);\n    }\n    addEvents(events) {\n        const arr = events.filter((e) => !this.queuedIds.has(e.id));\n        if (arr.length === 0)\n            return;\n        this.eventQueue.push(...arr);\n        this.useEvents(arr);\n    }\n    useEvent(event) {\n        this.lastUsedQueue.add(getEventUID(event));\n    }\n    useEvents(events) {\n        for (const event of events)\n            this.lastUsedQueue.add(getEventUID(event));\n    }\n    matchPending(filters) {\n        return this.eventQueue.filter((e) => matchFilters(filters, e));\n    }\n    async flush(count = 1000) {\n        if (this.eventQueue.length > 0) {\n            const events = [];\n            for (let i = 0; i < count; i++) {\n                const event = this.eventQueue.shift();\n                if (!event)\n                    break;\n                events.push(event);\n                this.queuedIds.delete(event.id);\n            }\n            await addEvents(this.db, events);\n            log(`Wrote ${events.length} to database`);\n            if (this.eventQueue.length > 0)\n                log(`${this.eventQueue.length} left`);\n        }\n        if (this.lastUsedQueue.size > 0) {\n            await updateUsed(this.db, this.lastUsedQueue);\n            this.lastUsedQueue.clear();\n        }\n    }\n    clear() {\n        this.eventQueue = [];\n    }\n}\n", "import { getEventTags } from \"../database/ingest.js\";\nimport { logger } from \"../debug.js\";\nconst log = logger.extend(\"cache:indexes\");\nclass Index extends Set {\n    type;\n    key;\n    constructor(values, type, key) {\n        super(values);\n        this.type = type;\n        this.key = key;\n    }\n}\nexport class IndexCache {\n    kinds = new Map();\n    pubkeys = new Map();\n    tags = new Map();\n    get count() {\n        return this.kinds.size + this.pubkeys.size + this.tags.size;\n    }\n    max = 1000;\n    lastUsed = [];\n    useIndex(index) {\n        const i = this.lastUsed.indexOf(index);\n        if (i !== -1)\n            this.lastUsed.splice(i, i + 1);\n        this.lastUsed.push(index);\n    }\n    getKindIndex(kind) {\n        const index = this.kinds.get(kind);\n        if (index)\n            this.useIndex(index);\n        return index;\n    }\n    setKindIndex(kind, uids) {\n        const index = new Index(uids, \"kind\", kind);\n        this.kinds.set(kind, index);\n        this.useIndex(index);\n        this.pruneIndexes();\n    }\n    getPubkeyIndex(pubkey) {\n        const index = this.pubkeys.get(pubkey);\n        if (index)\n            this.useIndex(index);\n        return index;\n    }\n    setPubkeyIndex(pubkey, uids) {\n        const index = new Index(uids, \"pubkey\", pubkey);\n        this.pubkeys.set(pubkey, index);\n        this.useIndex(index);\n        this.pruneIndexes();\n    }\n    getTagIndex(tagAndValue) {\n        const index = this.tags.get(tagAndValue);\n        if (index)\n            this.useIndex(index);\n        return index;\n    }\n    setTagIndex(tagAndValue, uids) {\n        const index = new Index(uids, \"tag\", tagAndValue);\n        this.tags.set(tagAndValue, index);\n        this.useIndex(index);\n        this.pruneIndexes();\n    }\n    addEventToIndexes(event) {\n        this.getKindIndex(event.kind)?.add(event.id);\n        this.getPubkeyIndex(event.pubkey)?.add(event.id);\n        const tags = getEventTags(event);\n        for (const tag of tags) {\n            this.getTagIndex(tag)?.add(event.id);\n        }\n    }\n    pruneIndexes() {\n        while (this.lastUsed.length > 0 && this.lastUsed.length > this.max) {\n            const index = this.lastUsed.shift();\n            if (!index)\n                return;\n            log(`Forgetting ${index.type}:${index.key}`);\n            switch (index.type) {\n                case \"kind\":\n                    this.kinds.delete(index.key);\n                    break;\n                case \"pubkey\":\n                    this.pubkeys.delete(index.key);\n                    break;\n                case \"tag\":\n                    this.tags.delete(index.key);\n                    break;\n            }\n        }\n    }\n}\n", "// copied from nanoid@5.0.4\nexport let nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63;\n    if (byte < 36) {\n        id += byte.toString(36);\n    }\n    else if (byte < 62) {\n        id += (byte - 26).toString(36).toUpperCase();\n    }\n    else if (byte > 62) {\n        id += \"-\";\n    }\n    else {\n        id += \"_\";\n    }\n    return id;\n}, \"\");\n", "import { kinds, matchFilters } from \"nostr-tools\";\nimport { WriteQueue } from \"../cache/write-queue.js\";\nimport { IndexCache } from \"../cache/index-cache.js\";\nimport { getEventsForFilters, countEventsForFilters, } from \"../database/query-filter.js\";\nimport { sortByDate } from \"../utils.js\";\nimport { nanoid } from \"../lib/nanoid.js\";\nimport { logger } from \"../debug.js\";\nimport { getEventUID } from \"../database/ingest.js\";\nimport { pruneLastUsed } from \"../database/prune.js\";\nconst defaultOptions = {\n    batchWrite: 1000,\n    writeInterval: 100,\n    cacheIndexes: 1000,\n    pruneInterval: 1000 * 60,\n    maxEvents: 10000,\n};\nconst log = logger.extend(\"relay\");\n/** Main class that implements the relay logic */\nexport class RelayCore {\n    options;\n    writeInterval;\n    pruneInterval;\n    get running() {\n        return !!this.writeInterval;\n    }\n    eventMap = new Map();\n    writeQueue;\n    indexCache;\n    db;\n    baseEoseTimeout = 4400;\n    subscriptions = new Map();\n    constructor(db, opts = {}) {\n        this.db = db;\n        this.options = { ...defaultOptions, ...opts };\n        this.writeQueue = new WriteQueue(db);\n        this.indexCache = new IndexCache();\n        this.indexCache.max = this.options.cacheIndexes;\n    }\n    async start() {\n        log(\"Starting\");\n        this.writeInterval = self.setInterval(() => {\n            this.writeQueue.flush(this.options.batchWrite);\n        }, this.options.writeInterval);\n        this.pruneInterval = self.setInterval(() => {\n            pruneLastUsed(this.db, this.options.maxEvents);\n        }, this.options.pruneInterval);\n    }\n    async stop() {\n        if (this.writeInterval) {\n            self.clearInterval(this.writeInterval);\n            this.writeInterval = undefined;\n        }\n        if (this.pruneInterval) {\n            self.clearInterval(this.pruneInterval);\n            this.pruneInterval = undefined;\n        }\n        log(\"Stopped\");\n    }\n    async publish(event) {\n        if (!kinds.isEphemeralKind(event.kind)) {\n            this.writeQueue.addEvent(event);\n            this.indexCache.addEventToIndexes(event);\n        }\n        const uid = getEventUID(event);\n        let subs = 0;\n        if (!this.eventMap.has(uid)) {\n            if (!kinds.isEphemeralKind(event.kind))\n                this.eventMap.set(uid, event);\n            for (const [id, sub] of this.subscriptions) {\n                if (sub.onevent && matchFilters(sub.filters, event)) {\n                    sub.onevent(event);\n                    subs++;\n                }\n            }\n        }\n        return `Sent to ${subs} subscriptions`;\n    }\n    async count(filters) {\n        return await countEventsForFilters(this.db, filters);\n    }\n    addToEventMaps(events) {\n        for (const event of events)\n            this.eventMap.set(getEventUID(event), event);\n    }\n    async executeSubscription(sub) {\n        const start = new Date().valueOf();\n        log(`Running ${sub.id}`, sub.filters);\n        // load any events from the write queue\n        const eventsFromQueue = this.writeQueue.matchPending(sub.filters);\n        return new Promise((res, rej) => {\n            const timeout = setTimeout(() => {\n                if (sub.oneose)\n                    sub.oneose();\n                res();\n            }, this.baseEoseTimeout);\n            // get events\n            getEventsForFilters(this.db, sub.filters, this.indexCache, this.eventMap).then((filterEvents) => {\n                clearTimeout(timeout);\n                this.addToEventMaps(filterEvents);\n                if (sub.onevent) {\n                    const idsFromQueue = new Set(eventsFromQueue.map((e) => e.id));\n                    const events = eventsFromQueue.length > 0\n                        ? [\n                            ...filterEvents.filter((e) => !idsFromQueue.has(e.id)),\n                            ...eventsFromQueue,\n                        ].sort(sortByDate)\n                        : filterEvents;\n                    for (const event of events) {\n                        try {\n                            sub.onevent(event);\n                            this.writeQueue.useEvent(event);\n                        }\n                        catch (error) {\n                            log(`onevent failed with error`, error);\n                        }\n                    }\n                    const delta = new Date().valueOf() - start;\n                    log(`Finished ${sub.id} took ${delta}ms and got ${events.length} events`);\n                }\n                if (sub.oneose)\n                    sub.oneose();\n                res();\n            });\n        });\n    }\n    subscribe(filters, options) {\n        // remove any duplicate subscriptions\n        if (options.id && this.subscriptions.has(options.id)) {\n            this.subscriptions.delete(options.id);\n        }\n        const id = options.id || nanoid();\n        const sub = {\n            id,\n            filters,\n            close: () => this.subscriptions.delete(id),\n            fire: () => this.executeSubscription(sub),\n            ...options,\n        };\n        this.subscriptions.set(id, sub);\n        this.executeSubscription(sub);\n        return sub;\n    }\n    unsubscribe(id) {\n        const sub = this.subscriptions.get(id);\n        if (sub) {\n            log(`Closing ${id}`);\n            sub.onclose?.(\"unsubscribe\");\n            this.subscriptions.delete(id);\n        }\n    }\n}\n", "import { RelayCore, } from \"./relay-core.js\";\nexport class CacheRelay {\n    get url() {\n        return \"nostr-idb://cache-relay\";\n    }\n    get connected() {\n        return !!this.core.running;\n    }\n    db;\n    core;\n    constructor(db, opts = {}) {\n        this.db = db;\n        this.core = new RelayCore(db, opts);\n    }\n    async connect() {\n        this.core.start();\n    }\n    async close() {\n        this.core.stop();\n    }\n    async publish(event) {\n        return this.core.publish(event);\n    }\n    async count(filters, params) {\n        return this.core.count(filters);\n    }\n    subscribe(filters, options) {\n        return this.core.subscribe(filters, options);\n    }\n}\n"],
  "mappings": "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",
  "names": ["openDB", "deleteDB", "log", "log", "log"]
}
